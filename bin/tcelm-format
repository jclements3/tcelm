#!/usr/bin/env node
// tcelm-format - Format Elm source code
//
// Usage:
//   tcelm-format [OPTIONS] [FILES...]
//
// Options:
//   --stdin         Read from stdin
//   --validate      Check if files are formatted (exit 1 if not)
//   --yes           Overwrite files in place
//   --output FILE   Write to FILE instead of stdout
//   --help          Show this help

const fs = require('fs');
const path = require('path');

// Load the compiled Elm app
const elmModule = require('./tcelm-format.js');
const Elm = elmModule.Elm || global.Elm || this.Elm;

if (!Elm || !Elm.Tools || !Elm.Tools.Format) {
    console.error('Failed to load Elm.Tools.Format module');
    process.exit(1);
}

// Parse arguments
const args = process.argv.slice(2);
const options = {
    validate: false,
    overwrite: false,
    outputFile: null,
    useStdin: false,
    files: [],
    help: false
};

for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--stdin') {
        options.useStdin = true;
    } else if (arg === '--validate') {
        options.validate = true;
    } else if (arg === '--yes') {
        options.overwrite = true;
    } else if (arg === '--output' || arg === '-o') {
        options.outputFile = args[++i];
    } else if (arg === '--help' || arg === '-h') {
        options.help = true;
    } else if (!arg.startsWith('-')) {
        options.files.push(arg);
    }
}

if (options.help) {
    console.log(`tcelm-format - Format Elm source code

USAGE:
    tcelm-format [OPTIONS] [FILES...]

OPTIONS:
    --stdin         Read from stdin instead of files
    --validate      Check if files are formatted (exit 1 if not)
    --yes           Overwrite files in place without prompting
    --output FILE   Write output to FILE
    -o FILE         Same as --output
    --help, -h      Show this help message

EXAMPLES:
    tcelm-format src/Main.elm           Format and print to stdout
    tcelm-format --yes src/*.elm        Format files in place
    tcelm-format --validate src/*.elm   Check if files need formatting
    cat Main.elm | tcelm-format --stdin Format from stdin

STYLE:
    tcelm-format uses a 94-column aligned style:
    - Horizontal-first layout (single line when it fits)
    - Alignment-based wrapping for long lines
    - K&R closing delimiters (} ] ) on same line as last element)
    - Operator alignment within blocks
    - Doc comments with indented continuation and closing on last line
`);
    process.exit(0);
}

function formatSource(source, filePath) {
    return new Promise((resolve, reject) => {
        const app = Elm.Tools.Format.init();

        app.ports.sendOutput.subscribe(function(result) {
            if (result.success) {
                resolve({ formatted: result.code, original: source, path: filePath });
            } else {
                reject(new Error(result.error));
            }
        });

        app.ports.receiveSource.send(source);
    });
}

async function processFile(filePath) {
    let source;
    try {
        source = fs.readFileSync(filePath, 'utf8');
    } catch (e) {
        console.error(`Error reading ${filePath}: ${e.message}`);
        return false;
    }

    try {
        const result = await formatSource(source, filePath);

        if (options.validate) {
            if (result.formatted !== result.original) {
                console.error(`${filePath} needs formatting`);
                return false;
            }
            return true;
        } else if (options.overwrite) {
            if (result.formatted !== result.original) {
                fs.writeFileSync(filePath, result.formatted);
                console.error(`Formatted ${filePath}`);
            }
            return true;
        } else if (options.outputFile) {
            fs.writeFileSync(options.outputFile, result.formatted);
            return true;
        } else {
            process.stdout.write(result.formatted);
            return true;
        }
    } catch (e) {
        console.error(`Error formatting ${filePath}: ${e.message}`);
        return false;
    }
}

async function processStdin() {
    return new Promise((resolve) => {
        let source = '';
        process.stdin.setEncoding('utf8');
        process.stdin.on('data', chunk => source += chunk);
        process.stdin.on('end', async () => {
            try {
                const result = await formatSource(source, 'stdin');

                if (options.validate) {
                    if (result.formatted !== result.original) {
                        console.error('stdin needs formatting');
                        resolve(false);
                    } else {
                        resolve(true);
                    }
                } else if (options.outputFile) {
                    fs.writeFileSync(options.outputFile, result.formatted);
                    resolve(true);
                } else {
                    process.stdout.write(result.formatted);
                    resolve(true);
                }
            } catch (e) {
                console.error(`Error formatting stdin: ${e.message}`);
                resolve(false);
            }
        });
    });
}

async function main() {
    if (options.useStdin) {
        const success = await processStdin();
        process.exit(success ? 0 : 1);
    } else if (options.files.length === 0) {
        console.error('Usage: tcelm-format [OPTIONS] [FILES...]');
        console.error('Try --help for more information.');
        process.exit(1);
    } else {
        let allSuccess = true;
        for (const file of options.files) {
            const success = await processFile(file);
            if (!success) allSuccess = false;
        }
        process.exit(allSuccess ? 0 : 1);
    }
}

main();
