module Generate.C exposing (generate, generateModule, generateNativeWorkerModule, generateRtemsModule)

{-| C Code Generator for tcelm

Transforms Elm AST into C code using the tcelm runtime with arena allocation.

For RTEMS targets, generates task definitions and shell registration.

-}

import AST.Source as Src exposing (Expr, Expr_(..), Module, Pattern, Pattern_(..), Type, Value)
import Codegen.Lambda exposing (LambdaState, LiftedLambda)
import Codegen.Shared as Shared exposing (escapeC, extractCtorName, getModuleName, getModulePrefix, mangle, mangleLocal, mangleWithPrefix, patternVars, uniqueStrings)




{-| Generate C code for an entire module
-}
generateModule : Module -> String
generateModule mod =
    let
        moduleName =
            getModuleName mod

        -- Convert module name to C prefix (e.g., "AST.Source" -> "AST_Source")
        modulePrefix =
            getModulePrefix mod

        includes =
            [ "#include <stdio.h>"
            , "#include <string.h>"
            , "#include \"tcelm_arena.h\""
            , "#include \"tcelm_types.h\""
            , "#include \"tcelm_basics.h\""
            , "#include \"tcelm_platform.h\""
            , ""
            ]

        header =
            [ "/*"
            , " * Generated by tcelm from " ++ moduleName
            , " * DO NOT EDIT - This file is auto-generated"
            , " */"
            , ""
            ]

        -- Collect all lambdas from module values
        initialState =
            { nextId = 0, lambdas = [] }

        lambdaState =
            List.foldl (collectLambdasFromValue modulePrefix) initialState mod.values

        -- Generate lifted lambda forward declarations and implementations
        liftedLambdaForwardDecls =
            List.map generateLiftedLambdaForwardDecl lambdaState.lambdas

        liftedLambdaImpls =
            List.map generateLiftedLambda lambdaState.lambdas

        -- Generate forward declarations with module prefix
        forwardDecls =
            List.map (generateForwardDeclWithPrefix modulePrefix) mod.values

        -- Generate function implementations with module prefix
        -- Pass lambda counter state so lambdas emit references to lifted functions
        valueDefs =
            generateValuesWithLiftedLambdas modulePrefix mod.values

        -- Generate type definitions for custom types
        typeDefs =
            List.map generateUnion mod.unions
                ++ List.map generateAlias mod.aliases

        -- Generate port stubs
        portStubs =
            List.map (generatePortStub modulePrefix) mod.ports
    in
    String.join "\n"
        (header
            ++ includes
            ++ [ "/* Type definitions */" ]
            ++ typeDefs
            ++ [ "", "/* Forward declarations */" ]
            ++ liftedLambdaForwardDecls
            ++ forwardDecls
            ++ [ "", "/* Port stubs */" ]
            ++ portStubs
            ++ [ "", "/* Lifted lambda implementations */" ]
            ++ liftedLambdaImpls
            ++ [ "", "/* Function implementations */" ]
            ++ valueDefs
        )


{-| Generate values with lifted lambda references
    Uses counter-based approach to match lambdas with their lifted versions
-}
generateValuesWithLiftedLambdas : String -> List (Src.Located Value) -> List String
generateValuesWithLiftedLambdas modulePrefix values =
    let
        ( _, results ) =
            List.foldl
                (\value ( counter, acc ) ->
                    let
                        ( newCounter, code ) =
                            generateValueWithLiftedLambdas modulePrefix counter value
                    in
                    ( newCounter, acc ++ [ code ] )
                )
                ( 0, [] )
                values
    in
    results


{-| Generate a single value with lifted lambda references
    Returns (new counter, generated code)
-}
generateValueWithLiftedLambdas : String -> Int -> Src.Located Value -> ( Int, String )
generateValueWithLiftedLambdas modulePrefix lambdaCounter (Src.At _ value) =
    let
        (Src.At _ name) =
            value.name

        args =
            value.args

        arity =
            List.length args

        -- Full name: elm_Module_Name_functionName
        fullName =
            "elm_" ++ modulePrefix ++ "_" ++ name

        -- Collect local variable names from patterns
        localVars =
            patternVarss args

        -- Generate pattern bindings for arguments
        bindings =
            List.map2 generateArgBinding args (List.indexedMap (\i _ -> "arg" ++ String.fromInt i) args)
                |> List.concat

        -- Generate body with lambda counter
        ( newCounter, body ) =
            generateExprWithLiftedLambdas modulePrefix localVars lambdaCounter value.body

        -- Implementation function (NOT static - exported for cross-module linking)
        implFunc =
            String.join "\n"
                [ ""
                , "tcelm_value_t *" ++ fullName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args) {"
                , if arity == 0 then
                    "    (void)args;"

                  else
                    String.join "\n" (List.indexedMap (\i _ -> "    tcelm_value_t *arg" ++ String.fromInt i ++ " = args[" ++ String.fromInt i ++ "];") args)
                , String.join "\n" (List.map (\b -> "    " ++ b) bindings)
                , "    return " ++ body ++ ";"
                , "}"
                ]

        -- Direct-call wrapper for cross-module calls
        directCallWrapper =
            if arity == 0 then
                String.join "\n"
                    [ ""
                    , "tcelm_value_t *" ++ fullName ++ "(tcelm_arena_t *arena) {"
                    , "    return " ++ fullName ++ "_impl(arena, NULL);"
                    , "}"
                    ]

            else
                let
                    paramList =
                        List.indexedMap (\i _ -> "tcelm_value_t *__arg" ++ String.fromInt i) args
                            |> String.join ", "

                    argsArrayInit =
                        List.indexedMap (\i _ -> "__arg" ++ String.fromInt i) args
                            |> String.join ", "
                in
                String.join "\n"
                    [ ""
                    , "tcelm_value_t *" ++ fullName ++ "(tcelm_arena_t *arena, " ++ paramList ++ ") {"
                    , "    tcelm_value_t *__args[] = {" ++ argsArrayInit ++ "};"
                    , "    return " ++ fullName ++ "_impl(arena, __args);"
                    , "}"
                    ]
    in
    ( newCounter, implFunc ++ directCallWrapper )


{-| Generate expression with lifted lambda references
    Returns (new counter, generated code)
-}
generateExprWithLiftedLambdas : String -> List String -> Int -> Expr -> ( Int, String )
generateExprWithLiftedLambdas modulePrefix locals counter (Src.At _ expr) =
    case expr of
        Lambda args body ->
            let
                -- This lambda corresponds to __lambda_{counter}
                lambdaName =
                    "__lambda_" ++ String.fromInt counter

                lambdaLocals =
                    patternVarss args

                -- Find free vars (only lambdaLocals are bound)
                -- Captures are free vars that come from outer scope (locals)
                captures =
                    collectFreeVars lambdaLocals body
                        |> List.filter (\v -> List.member v locals)
                        |> uniqueStrings

                numCaptures =
                    List.length captures

                arity =
                    List.length args

                totalArity =
                    numCaptures + arity

                -- First, traverse the body to update counter for nested lambdas
                ( counterAfterBody, _ ) =
                    generateExprWithLiftedLambdas modulePrefix (lambdaLocals ++ locals) (counter + 1) body

                -- Generate code to create closure and apply captures
                closureCode =
                    if numCaptures == 0 then
                        -- No captures, just create the closure
                        "tcelm_closure(arena, " ++ lambdaName ++ "_impl, " ++ String.fromInt arity ++ ")"

                    else
                        -- Create closure with full arity, then apply captured values
                        let
                            captureApplies =
                                List.foldl
                                    (\capName accCode ->
                                        "tcelm_apply(arena, " ++ accCode ++ ", " ++ mangleLocal capName ++ ")"
                                    )
                                    ("tcelm_closure(arena, " ++ lambdaName ++ "_impl, " ++ String.fromInt totalArity ++ ")")
                                    captures
                        in
                        captureApplies
            in
            ( counterAfterBody, closureCode )

        Let defs body ->
            let
                letLocals =
                    List.concatMap
                        (\(Src.At _ def) ->
                            case def of
                                Src.Define (Src.At _ defName) _ _ _ ->
                                    [ defName ]

                                Src.Destruct pat _ ->
                                    patternVars pat
                        )
                        defs

                allLocals =
                    letLocals ++ locals

                -- Process definitions (track destruct index for unique naming)
                ( counterAfterDefs, defBindings, _ ) =
                    List.foldl
                        (\(Src.At _ def) ( c, acc, destructIdx ) ->
                            case def of
                                Src.Define (Src.At _ defName) defArgs defBody _ ->
                                    if List.isEmpty defArgs then
                                        let
                                            ( c2, defCode ) =
                                                generateExprWithLiftedLambdas modulePrefix allLocals c defBody
                                        in
                                        ( c2, acc ++ [ "tcelm_value_t *" ++ mangleLocal defName ++ " = " ++ defCode ++ ";" ], destructIdx )

                                    else
                                        -- Local function - generate as closure
                                        -- This is handled like a lambda
                                        let
                                            lambdaName =
                                                "__lambda_" ++ String.fromInt c

                                            defLocals =
                                                patternVarss defArgs

                                            -- Find free vars (only defLocals are bound)
                                            -- Captures are free vars from outer scope
                                            captures =
                                                collectFreeVars defLocals defBody
                                                    |> List.filter (\v -> List.member v allLocals)
                                                    |> uniqueStrings

                                            numCaptures =
                                                List.length captures

                                            defArity =
                                                List.length defArgs

                                            totalArity =
                                                numCaptures + defArity

                                            ( c2, _ ) =
                                                generateExprWithLiftedLambdas modulePrefix (defLocals ++ allLocals) (c + 1) defBody

                                            closureCode =
                                                if numCaptures == 0 then
                                                    "tcelm_closure(arena, " ++ lambdaName ++ "_impl, " ++ String.fromInt defArity ++ ")"

                                                else
                                                    List.foldl
                                                        (\capName accCode ->
                                                            "tcelm_apply(arena, " ++ accCode ++ ", " ++ mangleLocal capName ++ ")"
                                                        )
                                                        ("tcelm_closure(arena, " ++ lambdaName ++ "_impl, " ++ String.fromInt totalArity ++ ")")
                                                        captures
                                        in
                                        ( c2, acc ++ [ "tcelm_value_t *" ++ mangleLocal defName ++ " = " ++ closureCode ++ ";" ], destructIdx )

                                Src.Destruct pat defBody ->
                                    let
                                        ( c2, defCode ) =
                                            generateExprWithLiftedLambdas modulePrefix allLocals c defBody

                                        -- Use unique index for destruct name
                                        destructName =
                                            "__destruct_" ++ String.fromInt destructIdx

                                        -- First bind the computed value to a temp, then destructure it
                                        bindingCode =
                                            "tcelm_value_t *" ++ destructName ++ " = " ++ defCode ++ ";"

                                        patternBindings =
                                            generatePatternBindingsLocal destructName pat
                                    in
                                    ( c2, acc ++ [ bindingCode ] ++ patternBindings, destructIdx + 1 )
                        )
                        ( counter, [], 0 )
                        defs

                -- Process body
                ( counterAfterBody, bodyCode ) =
                    generateExprWithLiftedLambdas modulePrefix allLocals counterAfterDefs body
            in
            ( counterAfterBody
            , "({\n        " ++ String.join "\n        " defBindings ++ "\n        " ++ bodyCode ++ ";\n    })"
            )

        If branches elseExpr ->
            let
                ( counterAfterBranches, branchCodes ) =
                    List.foldl
                        (\( cond, thenExpr ) ( c, acc ) ->
                            let
                                ( c2, condCode ) =
                                    generateExprWithLiftedLambdas modulePrefix locals c cond

                                ( c3, thenCode ) =
                                    generateExprWithLiftedLambdas modulePrefix locals c2 thenExpr
                            in
                            ( c3, acc ++ [ ( condCode, thenCode ) ] )
                        )
                        ( counter, [] )
                        branches

                ( counterAfterElse, elseCode ) =
                    generateExprWithLiftedLambdas modulePrefix locals counterAfterBranches elseExpr
            in
            ( counterAfterElse
            , generateIfChain branchCodes elseCode
            )

        Case scrutinee branches ->
            let
                ( counterAfterScrutinee, scrutineeCode ) =
                    generateExprWithLiftedLambdas modulePrefix locals counter scrutinee

                ( counterAfterBranches, branchCodes ) =
                    List.foldl
                        (\( pat, _, branchExpr ) ( c, acc ) ->
                            let
                                patLocals =
                                    patternVars pat ++ locals

                                ( c2, branchCode ) =
                                    generateExprWithLiftedLambdas modulePrefix patLocals c branchExpr
                            in
                            ( c2, acc ++ [ ( pat, branchCode ) ] )
                        )
                        ( counterAfterScrutinee, [] )
                        branches
            in
            ( counterAfterBranches
            , generateCaseExprWithLiftedLambdas scrutineeCode branchCodes
            )

        Call fn args ->
            let
                ( counterAfterFn, fnCode ) =
                    generateExprWithLiftedLambdas modulePrefix locals counter fn

                ( counterAfterArgs, argCodes ) =
                    List.foldl
                        (\arg ( c, acc ) ->
                            let
                                ( c2, argCode ) =
                                    generateExprWithLiftedLambdas modulePrefix locals c arg
                            in
                            ( c2, acc ++ [ argCode ] )
                        )
                        ( counterAfterFn, [] )
                        args

                -- Check if it's a constructor call
                isConstructorCall =
                    case fn of
                        Src.At _ (Var Src.CapVar _) ->
                            True

                        Src.At _ (VarQual Src.CapVar _ _) ->
                            True

                        _ ->
                            False

                -- Check if it's a direct qualified call to stdlib
                isDirectCall =
                    case fn of
                        Src.At _ (VarQual Src.LowVar _ _) ->
                            True

                        _ ->
                            False
            in
            if isConstructorCall then
                let
                    ( ctorNameUpper, ctorNameOrig ) =
                        case fn of
                            Src.At _ (Var Src.CapVar name) ->
                                let
                                    shortName =
                                        extractCtorName name
                                in
                                ( String.toUpper shortName, shortName )

                            Src.At _ (VarQual Src.CapVar _ name) ->
                                ( String.toUpper name, name )

                            _ ->
                                ( "UNKNOWN", "Unknown" )

                    numArgs =
                        List.length argCodes
                in
                ( counterAfterArgs
                , if numArgs == 0 then
                    "tcelm_custom(arena, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ ctorNameOrig ++ "\", 0)"

                  else
                    "tcelm_custom(arena, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ ctorNameOrig ++ "\", " ++ String.fromInt numArgs ++ ", " ++ String.join ", " argCodes ++ ")"
                )

            else if isDirectCall then
                let
                    ( modulePath, fnNameLocal ) =
                        case fn of
                            Src.At _ (VarQual Src.LowVar mp n) ->
                                ( mp, n )

                            _ ->
                                ( "", "" )

                    fnName =
                        mapStdLibFunction modulePath fnNameLocal

                    numArgs =
                        List.length argCodes

                    maybeArity =
                        getStdLibArity modulePath fnNameLocal

                    needsArena =
                        stdLibNeedsArena modulePath fnNameLocal
                in
                case maybeArity of
                    Just stdArity ->
                        ( counterAfterArgs
                        , if numArgs >= stdArity then
                            if needsArena then
                                fnName ++ "(arena" ++ (if List.isEmpty argCodes then "" else ", " ++ String.join ", " argCodes) ++ ")"

                            else
                                fnName ++ "(" ++ String.join ", " argCodes ++ ")"

                          else
                            -- Partial application - fall through to general case
                            "tcelm_apply_n(arena, " ++ fnCode ++ ", " ++ String.fromInt numArgs ++ ", " ++ String.join ", " argCodes ++ ")"
                        )

                    Nothing ->
                        ( counterAfterArgs
                        , "tcelm_apply_n(arena, " ++ fnCode ++ ", " ++ String.fromInt numArgs ++ ", " ++ String.join ", " argCodes ++ ")"
                        )

            else
                ( counterAfterArgs
                , if List.isEmpty argCodes then
                    fnCode

                  else
                    "tcelm_apply_n(arena, " ++ fnCode ++ ", " ++ String.fromInt (List.length argCodes) ++ ", " ++ String.join ", " argCodes ++ ")"
                )

        Binops pairs final ->
            let
                ( counterAfterPairs, pairCodes ) =
                    List.foldl
                        (\( e, op ) ( c, acc ) ->
                            let
                                ( c2, code ) =
                                    generateExprWithLiftedLambdas modulePrefix locals c e
                            in
                            ( c2, acc ++ [ ( code, op ) ] )
                        )
                        ( counter, [] )
                        pairs

                ( counterAfterFinal, finalCode ) =
                    generateExprWithLiftedLambdas modulePrefix locals counterAfterPairs final

                -- Fold the binops from left to right
                result =
                    List.foldl
                        (\( leftCode, Src.At _ op ) rightCode ->
                            generateBinop op leftCode rightCode
                        )
                        finalCode
                        (List.reverse pairCodes)
            in
            ( counterAfterFinal, result )

        List items ->
            let
                ( counterAfterItems, itemCodes ) =
                    List.foldl
                        (\item ( c, acc ) ->
                            let
                                ( c2, code ) =
                                    generateExprWithLiftedLambdas modulePrefix locals c item
                            in
                            ( c2, acc ++ [ code ] )
                        )
                        ( counter, [] )
                        items
            in
            ( counterAfterItems
            , generateListLiteral itemCodes
            )

        Tuple first second rest ->
            let
                allElems =
                    first :: second :: rest

                ( counterAfterElems, elemCodes ) =
                    List.foldl
                        (\elem ( c, acc ) ->
                            let
                                ( c2, code ) =
                                    generateExprWithLiftedLambdas modulePrefix locals c elem
                            in
                            ( c2, acc ++ [ code ] )
                        )
                        ( counter, [] )
                        allElems
            in
            ( counterAfterElems
            , case elemCodes of
                [ a, b ] ->
                    "tcelm_tuple2(arena, " ++ a ++ ", " ++ b ++ ")"

                [ a, b, c ] ->
                    "tcelm_tuple3(arena, " ++ a ++ ", " ++ b ++ ", " ++ c ++ ")"

                _ ->
                    "/* unsupported tuple size */"
            )

        Record fields ->
            let
                ( counterAfterFields, fieldCodes ) =
                    List.foldl
                        (\( Src.At _ fieldName, fieldExpr ) ( c, acc ) ->
                            let
                                ( c2, code ) =
                                    generateExprWithLiftedLambdas modulePrefix locals c fieldExpr
                            in
                            ( c2, acc ++ [ ( fieldName, code ) ] )
                        )
                        ( counter, [] )
                        fields

                numFields =
                    List.length fieldCodes

                fieldArgs =
                    List.map (\( n, v ) -> "\"" ++ n ++ "\", " ++ v) fieldCodes
                        |> String.join ", "
            in
            ( counterAfterFields
            , "tcelm_record(arena, " ++ String.fromInt numFields ++ ", " ++ fieldArgs ++ ")"
            )

        Update (Src.At _ recName) fields ->
            let
                ( counterAfterFields, fieldCodes ) =
                    List.foldl
                        (\( Src.At _ fieldName, fieldExpr ) ( c, acc ) ->
                            let
                                ( c2, code ) =
                                    generateExprWithLiftedLambdas modulePrefix locals c fieldExpr
                            in
                            ( c2, acc ++ [ ( fieldName, code ) ] )
                        )
                        ( counter, [] )
                        fields

                -- Chain record updates
                baseRec =
                    if List.member recName locals then
                        mangleLocal recName

                    else
                        mangle recName

                updateChain =
                    List.foldl
                        (\( fieldName, fieldCode ) acc ->
                            "tcelm_record_update(arena, " ++ acc ++ ", \"" ++ fieldName ++ "\", " ++ fieldCode ++ ")"
                        )
                        baseRec
                        fieldCodes
            in
            ( counterAfterFields, updateChain )

        Access inner (Src.At _ fieldName) ->
            let
                ( counterAfterInner, innerCode ) =
                    generateExprWithLiftedLambdas modulePrefix locals counter inner
            in
            ( counterAfterInner
            , "tcelm_record_get(" ++ innerCode ++ ", \"" ++ fieldName ++ "\")"
            )

        Negate inner ->
            let
                ( counterAfterInner, innerCode ) =
                    generateExprWithLiftedLambdas modulePrefix locals counter inner
            in
            ( counterAfterInner
            , "tcelm_negate(arena, " ++ innerCode ++ ")"
            )

        Int n ->
            ( counter, "tcelm_int(arena, " ++ String.fromInt n ++ ")" )

        Float f ->
            ( counter, "tcelm_float(arena, " ++ String.fromFloat f ++ ")" )

        Chr c ->
            ( counter
            , case String.uncons c of
                Just ( ch, _ ) ->
                    "tcelm_char(arena, " ++ String.fromInt (Char.toCode ch) ++ ")"

                Nothing ->
                    "tcelm_char(arena, 0)"
            )

        Str s ->
            ( counter, "tcelm_string(arena, \"" ++ escapeC s ++ "\")" )

        Var varType name ->
            ( counter
            , case varType of
                Src.LowVar ->
                    if List.member name locals then
                        mangleLocal name

                    else
                        case name of
                            "identity" ->
                                "tcelm_closure(arena, tcelm_identity_impl, 1)"

                            "toFloat" ->
                                "tcelm_closure(arena, tcelm_to_float_impl, 1)"

                            "min" ->
                                "tcelm_closure(arena, tcelm_min_impl, 2)"

                            "max" ->
                                "tcelm_closure(arena, tcelm_max_impl, 2)"

                            "not" ->
                                "tcelm_closure(arena, tcelm_not_impl, 1)"

                            "negate" ->
                                "tcelm_closure(arena, tcelm_negate_impl, 1)"

                            "abs" ->
                                "tcelm_closure(arena, tcelm_abs_impl, 1)"

                            _ ->
                                let
                                    qualName =
                                        mangleWithPrefix modulePrefix name
                                in
                                -- Handle both zero-arity values (call directly) and functions (create closure)
                                "(" ++ qualName ++ "_ARITY == 0 ? " ++ qualName ++ "(arena) : tcelm_closure(arena, " ++ qualName ++ "_impl, " ++ qualName ++ "_ARITY))"

                Src.CapVar ->
                    let
                        shortName =
                            extractCtorName name
                    in
                    "tcelm_custom(arena, TCELM_CTOR_" ++ String.toUpper shortName ++ ", \"" ++ shortName ++ "\", 0)"
            )

        VarQual varType modPath name ->
            ( counter
            , case varType of
                Src.LowVar ->
                    -- Special handling for Cmd.none and Sub.none - they're values, not functions
                    if modPath == "Cmd" && name == "none" then
                        "elm_Cmd_none"

                    else if modPath == "Sub" && name == "none" then
                        "elm_Sub_none"

                    else
                        let
                            fnName =
                                mapStdLibFunction modPath name

                            maybeArity =
                                getStdLibArity modPath name
                        in
                        case maybeArity of
                            Just arity ->
                                "tcelm_closure(arena, " ++ fnName ++ "_impl, " ++ String.fromInt arity ++ ")"

                            Nothing ->
                                "tcelm_closure(arena, " ++ fnName ++ "_impl, 1)"

                Src.CapVar ->
                    "tcelm_custom(arena, TCELM_CTOR_" ++ String.toUpper name ++ ", \"" ++ name ++ "\", 0)"
            )

        Unit ->
            ( counter, "TCELM_UNIT" )

        Accessor fieldName ->
            ( counter
            , "({\n        static tcelm_value_t *__accessor_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                ++ "            return tcelm_record_get(args[0], \""
                ++ fieldName
                ++ "\");\n        }\n"
                ++ "        (void)__a;\n"
                ++ "        tcelm_closure(arena, __accessor_impl, 1);\n    })"
            )

        _ ->
            ( counter, "/* unsupported expr */" )


{-| Generate case expression with lifted lambdas
-}
generateCaseExprWithLiftedLambdas : String -> List ( Pattern, String ) -> String
generateCaseExprWithLiftedLambdas scrutineeCode branches =
    let
        branchCode =
            List.map
                (\( pat, bodyCode ) ->
                    generateCaseBranch pat bodyCode
                )
                branches
                |> String.join "\n        "
    in
    "({\n        tcelm_value_t *__case_subject = " ++ scrutineeCode ++ ";\n        " ++ branchCode ++ "\n        TCELM_UNIT; /* unreachable */\n    })"




{-| Generate if/else chain from pre-generated condition and body code strings
-}
generateIfChain : List ( String, String ) -> String -> String
generateIfChain branches elseCode =
    case branches of
        [] ->
            elseCode

        [ ( condCode, thenCode ) ] ->
            "(TCELM_AS_BOOL(" ++ condCode ++ ") ? " ++ thenCode ++ " : " ++ elseCode ++ ")"

        ( condCode, thenCode ) :: rest ->
            "(TCELM_AS_BOOL(" ++ condCode ++ ") ? " ++ thenCode ++ " : " ++ generateIfChain rest elseCode ++ ")"


{-| Generate list literal from pre-generated element code strings
-}
generateListLiteral : List String -> String
generateListLiteral items =
    case items of
        [] ->
            "TCELM_NIL"

        x :: xs ->
            "tcelm_cons(arena, " ++ x ++ ", " ++ generateListLiteral xs ++ ")"


{-| Generate a case branch with pattern matching
-}
generateCaseBranch : Pattern -> String -> String
generateCaseBranch pattern bodyCode =
    let
        condition =
            generatePatternMatch "__case_subject" pattern

        bindings =
            generatePatternBindingsLocal "__case_subject" pattern
    in
    "if (" ++ condition ++ ") {\n            " ++ String.join "\n            " bindings ++ "\n            " ++ bodyCode ++ ";\n        }"


{-| Generate C code for a single expression (for testing)
-}
generate : Expr -> String
generate expr =
    generateExpr expr


{-| Generate forward declaration for a value

Includes the _impl function declaration and the _ARITY define.
-}
generateForwardDecl : Src.Located Value -> String
generateForwardDecl (Src.At _ value) =
    let
        (Src.At _ name) =
            value.name

        mangledName =
            mangle name

        arity =
            List.length value.args
    in
    "#define " ++ mangledName ++ "_ARITY " ++ String.fromInt arity ++ "\n"
        ++ "static tcelm_value_t *" ++ mangledName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args);"


{-| Generate forward declaration for a value with module prefix

The function name will be elm_Module_Name_functionName for cross-module linking.
Generates declarations for both _impl and direct-call versions.
-}
generateForwardDeclWithPrefix : String -> Src.Located Value -> String
generateForwardDeclWithPrefix modulePrefix (Src.At _ value) =
    let
        (Src.At _ name) =
            value.name

        -- Full name: elm_Module_Name_functionName
        fullName =
            "elm_" ++ modulePrefix ++ "_" ++ name

        arity =
            List.length value.args

        -- Parameter list for direct-call wrapper
        paramList =
            if arity == 0 then
                ""
            else
                ", " ++ (List.indexedMap (\i _ -> "tcelm_value_t *") value.args |> String.join ", ")
    in
    "#define " ++ fullName ++ "_ARITY " ++ String.fromInt arity ++ "\n"
        ++ "tcelm_value_t *" ++ fullName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args);\n"
        ++ "tcelm_value_t *" ++ fullName ++ "(tcelm_arena_t *arena" ++ paramList ++ ");"


{-| Generate a value definition

Generates just the implementation function. Closures are created inline when needed.
Also stores arity info in a #define for reference creation.
-}
generateValue : Src.Located Value -> String
generateValue (Src.At _ value) =
    let
        (Src.At _ name) =
            value.name

        args =
            value.args

        arity =
            List.length args

        mangledName =
            mangle name

        -- Collect local variable names from patterns
        localVars =
            patternVarss args

        -- Generate pattern bindings for arguments
        bindings =
            List.map2 generateArgBinding args (List.indexedMap (\i _ -> "arg" ++ String.fromInt i) args)
                |> List.concat

        body =
            generateExprWithLocals localVars value.body

        -- Implementation function (takes args array for closure compatibility)
        implFunc =
            String.join "\n"
                [ ""
                , "static tcelm_value_t *" ++ mangledName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args) {"
                , if arity == 0 then
                    "    (void)args;"
                  else
                    String.join "\n" (List.indexedMap (\i _ -> "    tcelm_value_t *arg" ++ String.fromInt i ++ " = args[" ++ String.fromInt i ++ "];") args)
                , String.join "\n" (List.map (\b -> "    " ++ b) bindings)
                , "    return " ++ body ++ ";"
                , "}"
                ]
    in
    implFunc


{-| Generate a value definition with module prefix for cross-module linking.

The function name will be elm_Module_Name_functionName.
Generates both:
- elm_Module_Name_func_impl(arena, args[]) - for closure-based calls
- elm_Module_Name_func(arena, arg0, arg1, ...) - for direct calls from other modules
-}
generateValueWithPrefix : String -> Src.Located Value -> String
generateValueWithPrefix modulePrefix (Src.At _ value) =
    let
        (Src.At _ name) =
            value.name

        args =
            value.args

        arity =
            List.length args

        -- Full name: elm_Module_Name_functionName
        fullName =
            "elm_" ++ modulePrefix ++ "_" ++ name

        -- Collect local variable names from patterns
        localVars =
            patternVarss args

        -- Generate pattern bindings for arguments
        bindings =
            List.map2 generateArgBinding args (List.indexedMap (\i _ -> "arg" ++ String.fromInt i) args)
                |> List.concat

        body =
            generateExprWithLocalsAndPrefix modulePrefix localVars value.body

        -- Implementation function (NOT static - exported for cross-module linking)
        implFunc =
            String.join "\n"
                [ ""
                , "tcelm_value_t *" ++ fullName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args) {"
                , if arity == 0 then
                    "    (void)args;"
                  else
                    String.join "\n" (List.indexedMap (\i _ -> "    tcelm_value_t *arg" ++ String.fromInt i ++ " = args[" ++ String.fromInt i ++ "];") args)
                , String.join "\n" (List.map (\b -> "    " ++ b) bindings)
                , "    return " ++ body ++ ";"
                , "}"
                ]

        -- Direct-call wrapper for cross-module calls
        -- elm_Module_func(arena, a0, a1, ...) calls elm_Module_func_impl(arena, {a0, a1, ...})
        directCallWrapper =
            if arity == 0 then
                String.join "\n"
                    [ ""
                    , "tcelm_value_t *" ++ fullName ++ "(tcelm_arena_t *arena) {"
                    , "    return " ++ fullName ++ "_impl(arena, NULL);"
                    , "}"
                    ]
            else
                let
                    paramList =
                        List.indexedMap (\i _ -> "tcelm_value_t *__arg" ++ String.fromInt i) args
                            |> String.join ", "

                    argsArrayInit =
                        List.indexedMap (\i _ -> "__arg" ++ String.fromInt i) args
                            |> String.join ", "
                in
                String.join "\n"
                    [ ""
                    , "tcelm_value_t *" ++ fullName ++ "(tcelm_arena_t *arena, " ++ paramList ++ ") {"
                    , "    tcelm_value_t *__args[] = {" ++ argsArrayInit ++ "};"
                    , "    return " ++ fullName ++ "_impl(arena, __args);"
                    , "}"
                    ]
    in
    implFunc ++ directCallWrapper


{-| Collect variable names from a list of patterns.
    Uses patternVars from Codegen.Shared.
-}
patternVarss : List Pattern -> List String
patternVarss patterns =
    List.concatMap patternVars patterns


{-| Collect all lambdas from an expression, assigning unique IDs
    Returns updated state with new lambdas added
-}
collectLambdasFromExpr : String -> List String -> Expr -> LambdaState -> LambdaState
collectLambdasFromExpr modulePrefix outerLocals (Src.At _ expr) state =
    case expr of
        Lambda args body ->
            let
                -- Variables bound by the lambda's arguments
                lambdaLocals =
                    patternVarss args

                -- Find free vars in body (only lambdaLocals are bound)
                freeVars =
                    collectFreeVars lambdaLocals body

                -- Captures are free vars that come from outer scope
                captures =
                    List.filter (\v -> List.member v outerLocals) freeVars
                        |> uniqueStrings

                newLambda =
                    { id = state.nextId
                    , modulePrefix = modulePrefix
                    , captures = captures
                    , args = args
                    , body = body
                    , outerLocals = outerLocals
                    }

                stateWithLambda =
                    { nextId = state.nextId + 1
                    , lambdas = state.lambdas ++ [ newLambda ]
                    }

                -- Also collect lambdas from the lambda body
                allLocals =
                    lambdaLocals ++ outerLocals
            in
            collectLambdasFromExpr modulePrefix allLocals body stateWithLambda

        Let defs body ->
            let
                -- Collect locals bound by let definitions
                letLocals =
                    List.concatMap
                        (\(Src.At _ def) ->
                            case def of
                                Src.Define (Src.At _ name) _ _ _ ->
                                    [ name ]

                                Src.Destruct pat _ ->
                                    patternVars pat
                        )
                        defs

                allLocals =
                    letLocals ++ outerLocals

                -- Collect from definition bodies, treating local functions as lambdas
                stateAfterDefs =
                    List.foldl
                        (\(Src.At _ def) st ->
                            case def of
                                Src.Define _ defArgs defBody _ ->
                                    if List.isEmpty defArgs then
                                        -- Simple value binding - just descend into body
                                        collectLambdasFromExpr modulePrefix allLocals defBody st

                                    else
                                        -- Local function - treat as a lambda
                                        let
                                            defLocals =
                                                patternVarss defArgs

                                            -- Find free vars in body (only defLocals are bound)
                                            freeVars =
                                                collectFreeVars defLocals defBody

                                            -- Captures are free vars that come from outer scope
                                            captures =
                                                List.filter (\v -> List.member v allLocals) freeVars
                                                    |> uniqueStrings

                                            newLambda =
                                                { id = st.nextId
                                                , modulePrefix = modulePrefix
                                                , captures = captures
                                                , args = defArgs
                                                , body = defBody
                                                , outerLocals = allLocals
                                                }

                                            stateWithLambda =
                                                { nextId = st.nextId + 1
                                                , lambdas = st.lambdas ++ [ newLambda ]
                                                }
                                        in
                                        -- Also collect lambdas from the function body
                                        collectLambdasFromExpr modulePrefix (defLocals ++ allLocals) defBody stateWithLambda

                                Src.Destruct _ defBody ->
                                    collectLambdasFromExpr modulePrefix allLocals defBody st
                        )
                        state
                        defs
            in
            collectLambdasFromExpr modulePrefix allLocals body stateAfterDefs

        If branches elseExpr ->
            let
                stateAfterBranches =
                    List.foldl
                        (\( cond, thenExpr ) st ->
                            collectLambdasFromExpr modulePrefix outerLocals thenExpr
                                (collectLambdasFromExpr modulePrefix outerLocals cond st)
                        )
                        state
                        branches
            in
            collectLambdasFromExpr modulePrefix outerLocals elseExpr stateAfterBranches

        Case scrutinee branches ->
            let
                stateAfterScrutinee =
                    collectLambdasFromExpr modulePrefix outerLocals scrutinee state
            in
            List.foldl
                (\( pat, _, branchExpr ) st ->
                    let
                        patLocals =
                            patternVars pat ++ outerLocals
                    in
                    collectLambdasFromExpr modulePrefix patLocals branchExpr st
                )
                stateAfterScrutinee
                branches

        Call fn args ->
            let
                stateAfterFn =
                    collectLambdasFromExpr modulePrefix outerLocals fn state
            in
            List.foldl (collectLambdasFromExpr modulePrefix outerLocals) stateAfterFn args

        Binops pairs final ->
            let
                stateAfterPairs =
                    List.foldl
                        (\( e, _ ) st -> collectLambdasFromExpr modulePrefix outerLocals e st)
                        state
                        pairs
            in
            collectLambdasFromExpr modulePrefix outerLocals final stateAfterPairs

        List items ->
            List.foldl (collectLambdasFromExpr modulePrefix outerLocals) state items

        Tuple first second rest ->
            List.foldl (collectLambdasFromExpr modulePrefix outerLocals) state (first :: second :: rest)

        Record fields ->
            List.foldl
                (\( _, fieldExpr ) st -> collectLambdasFromExpr modulePrefix outerLocals fieldExpr st)
                state
                fields

        Update _ fields ->
            List.foldl
                (\( _, fieldExpr ) st -> collectLambdasFromExpr modulePrefix outerLocals fieldExpr st)
                state
                fields

        Access inner _ ->
            collectLambdasFromExpr modulePrefix outerLocals inner state

        Negate inner ->
            collectLambdasFromExpr modulePrefix outerLocals inner state

        _ ->
            state


{-| Collect free variables referenced in an expression (not in boundVars)
-}
collectFreeVars : List String -> Expr -> List String
collectFreeVars boundVars (Src.At _ expr) =
    case expr of
        Var Src.LowVar name ->
            if List.member name boundVars then
                []

            else
                [ name ]

        Lambda args body ->
            let
                lambdaBound =
                    patternVarss args ++ boundVars
            in
            collectFreeVars lambdaBound body

        Let defs body ->
            let
                letBound =
                    List.concatMap
                        (\(Src.At _ def) ->
                            case def of
                                Src.Define (Src.At _ name) _ _ _ ->
                                    [ name ]

                                Src.Destruct pat _ ->
                                    patternVars pat
                        )
                        defs
                        ++ boundVars

                defVars =
                    List.concatMap
                        (\(Src.At _ def) ->
                            case def of
                                Src.Define _ defArgs defBody _ ->
                                    collectFreeVars (patternVarss defArgs ++ letBound) defBody

                                Src.Destruct _ defBody ->
                                    collectFreeVars letBound defBody
                        )
                        defs
            in
            defVars ++ collectFreeVars letBound body

        If branches elseExpr ->
            let
                branchVars =
                    List.concatMap
                        (\( cond, thenExpr ) ->
                            collectFreeVars boundVars cond ++ collectFreeVars boundVars thenExpr
                        )
                        branches
            in
            branchVars ++ collectFreeVars boundVars elseExpr

        Case scrutinee branches ->
            let
                scrutineeVars =
                    collectFreeVars boundVars scrutinee

                branchVars =
                    List.concatMap
                        (\( pat, _, branchExpr ) ->
                            collectFreeVars (patternVars pat ++ boundVars) branchExpr
                        )
                        branches
            in
            scrutineeVars ++ branchVars

        Call fn args ->
            collectFreeVars boundVars fn ++ List.concatMap (collectFreeVars boundVars) args

        Binops pairs final ->
            List.concatMap (\( e, _ ) -> collectFreeVars boundVars e) pairs
                ++ collectFreeVars boundVars final

        List items ->
            List.concatMap (collectFreeVars boundVars) items

        Tuple first second rest ->
            List.concatMap (collectFreeVars boundVars) (first :: second :: rest)

        Record fields ->
            List.concatMap (\( _, e ) -> collectFreeVars boundVars e) fields

        Update _ fields ->
            List.concatMap (\( _, e ) -> collectFreeVars boundVars e) fields

        Access inner _ ->
            collectFreeVars boundVars inner

        Negate inner ->
            collectFreeVars boundVars inner

        _ ->
            []


{-| Collect all lambdas from a module value (function definition)
-}
collectLambdasFromValue : String -> Src.Located Value -> LambdaState -> LambdaState
collectLambdasFromValue modulePrefix (Src.At _ value) state =
    let
        localVars =
            patternVarss value.args
    in
    collectLambdasFromExpr modulePrefix localVars value.body state


{-| Generate a lifted lambda as a module-level function
    Captured variables become the first N parameters.
    Takes starting counter for nested lambdas and returns (new counter, code).
-}
generateLiftedLambdaWithCounter : Int -> LiftedLambda -> ( Int, String )
generateLiftedLambdaWithCounter startCounter lambda =
    let
        lambdaName =
            "__lambda_" ++ String.fromInt lambda.id

        -- Total parameters: captures + lambda args
        numCaptures =
            List.length lambda.captures

        numArgs =
            List.length lambda.args

        totalArity =
            numCaptures + numArgs

        -- Generate parameter bindings - captures come first, then lambda args
        captureBindings =
            List.indexedMap
                (\i name -> "tcelm_value_t *" ++ mangleLocal name ++ " = args[" ++ String.fromInt i ++ "];")
                lambda.captures

        argBindings =
            List.indexedMap
                (\i pattern ->
                    generateLambdaArgBindingLocal pattern ("args[" ++ String.fromInt (numCaptures + i) ++ "]")
                )
                lambda.args
                |> List.concat

        -- Generate body with all locals in scope, using lifted lambda references
        lambdaLocals =
            patternVarss lambda.args

        allLocals =
            lambdaLocals ++ lambda.captures ++ lambda.outerLocals

        -- Use the counter-based generator so nested lambdas are properly referenced
        ( newCounter, bodyCode ) =
            generateExprWithLiftedLambdas lambda.modulePrefix allLocals startCounter lambda.body

        code =
            String.join "\n"
                [ ""
                , "static tcelm_value_t *" ++ lambdaName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args) {"
                , if totalArity == 0 then
                    "    (void)args;"

                  else
                    String.join "\n" (List.map (\b -> "    " ++ b) (captureBindings ++ argBindings))
                , "    return " ++ bodyCode ++ ";"
                , "}"
                ]
    in
    ( newCounter, code )


{-| Generate a lifted lambda (wrapper for backward compatibility)
-}
generateLiftedLambda : LiftedLambda -> String
generateLiftedLambda lambda =
    -- Start from the next lambda ID after this one
    let
        ( _, code ) =
            generateLiftedLambdaWithCounter (lambda.id + 1) lambda
    in
    code


{-| Generate forward declaration for a lifted lambda
-}
generateLiftedLambdaForwardDecl : LiftedLambda -> String
generateLiftedLambdaForwardDecl lambda =
    let
        lambdaName =
            "__lambda_" ++ String.fromInt lambda.id

        totalArity =
            List.length lambda.captures + List.length lambda.args
    in
    "#define " ++ lambdaName ++ "_ARITY " ++ String.fromInt totalArity ++ "\n"
        ++ "static tcelm_value_t *" ++ lambdaName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args);"


{-| Generate C code for an entire module
-}
generateExprWithLocals : List String -> Expr -> String
generateExprWithLocals locals expr =
    -- For now, delegate to regular generateExpr but track locals
    -- This will be enhanced to use mangleLocal for local vars
    generateExprInContext locals expr


{-| Generate expression with knowledge of local variables and module prefix
-}
generateExprWithLocalsAndPrefix : String -> List String -> Expr -> String
generateExprWithLocalsAndPrefix modulePrefix locals expr =
    generateExprInContextWithPrefix modulePrefix locals expr


{-| Generate expression in context of local variables with module prefix for function names
-}
generateExprInContextWithPrefix : String -> List String -> Expr -> String
generateExprInContextWithPrefix modulePrefix locals (Src.At _ expr) =
    case expr of
        Int n ->
            "tcelm_int(arena, " ++ String.fromInt n ++ ")"

        Float f ->
            "tcelm_float(arena, " ++ String.fromFloat f ++ ")"

        Chr c ->
            case String.uncons c of
                Just ( ch, _ ) ->
                    "tcelm_char(arena, " ++ String.fromInt (Char.toCode ch) ++ ")"

                Nothing ->
                    "tcelm_char(arena, 0)"

        Str s ->
            "tcelm_string(arena, \"" ++ escapeC s ++ "\")"

        Var varType name ->
            case varType of
                Src.LowVar ->
                    if List.member name locals then
                        mangleLocal name
                    else
                        case name of
                            "identity" ->
                                "tcelm_closure(arena, tcelm_identity_impl, 1)"

                            "toFloat" ->
                                "tcelm_closure(arena, tcelm_to_float_impl, 1)"

                            "min" ->
                                "tcelm_closure(arena, tcelm_min_impl, 2)"

                            "max" ->
                                "tcelm_closure(arena, tcelm_max_impl, 2)"

                            _ ->
                                -- Use qualified name for intra-module function references
                                -- Handle both zero-arity values (call directly) and functions (create closure)
                                let
                                    qualName = mangleWithPrefix modulePrefix name
                                in
                                "(" ++ qualName ++ "_ARITY == 0 ? " ++ qualName ++ "(arena) : tcelm_closure(arena, " ++ qualName ++ "_impl, " ++ qualName ++ "_ARITY))"

                Src.CapVar ->
                    let
                        shortName = extractCtorName name
                    in
                    case shortName of
                        "True" -> "tcelm_custom(arena, TCELM_CTOR_TRUE, \"True\", 0)"
                        "False" -> "tcelm_custom(arena, TCELM_CTOR_FALSE, \"False\", 0)"
                        "Nothing" -> "tcelm_custom(arena, TCELM_CTOR_NOTHING, \"Nothing\", 0)"
                        "Just" -> makeConstructorClosure "Just" 1
                        "Ok" -> makeConstructorClosure "Ok" 1
                        "Err" -> makeConstructorClosure "Err" 1
                        "LT" -> "tcelm_custom(arena, TCELM_CTOR_LT, \"LT\", 0)"
                        "EQ" -> "tcelm_custom(arena, TCELM_CTOR_EQ, \"EQ\", 0)"
                        "GT" -> "tcelm_custom(arena, TCELM_CTOR_GT, \"GT\", 0)"
                        "Parser" -> makeConstructorClosure "Parser" 1
                        "Good" -> makeConstructorClosure "Good" 3
                        "Bad" -> makeConstructorClosure "Bad" 2
                        "Empty" -> "tcelm_custom(arena, TCELM_CTOR_EMPTY, \"Empty\", 0)"
                        "AddRight" -> makeConstructorClosure "AddRight" 2
                        "Append" -> makeConstructorClosure "Append" 2
                        "At" -> makeConstructorClosure "At" 2
                        _ -> "tcelm_custom(arena, TCELM_CTOR_" ++ String.toUpper shortName ++ ", \"" ++ shortName ++ "\", 0)"

        VarQual varType modulePath name ->
            case varType of
                Src.LowVar ->
                    case getStdLibArity modulePath name of
                        Just arity ->
                            let
                                fnName = mapStdLibFunction modulePath name
                                needsArena = stdLibNeedsArena modulePath name
                                argBindings = List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (arity - 1))
                                callArgs = if needsArena then "__a, " ++ String.join ", " argBindings else String.join ", " argBindings
                            in
                            "({\n"
                                ++ "                auto tcelm_value_t *__fn_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                                ++ "                    (void)__a;\n"
                                ++ "                    return " ++ fnName ++ "(" ++ callArgs ++ ");\n"
                                ++ "                }\n"
                                ++ "                tcelm_closure(arena, __fn_impl, " ++ String.fromInt arity ++ ");\n"
                                ++ "            })"

                        Nothing ->
                            mapStdLibFunction modulePath name

                Src.CapVar ->
                    mapStdLibFunction modulePath name

        List exprs ->
            generateListInContextWithPrefix modulePrefix locals exprs

        Op opName ->
            "/* op " ++ opName ++ " */"

        Negate inner ->
            "tcelm_negate_int(arena, " ++ generateExprInContextWithPrefix modulePrefix locals inner ++ ")"

        Binops pairs finalExpr ->
            generateBinopsInContextWithPrefix modulePrefix locals pairs finalExpr

        Lambda args body ->
            generateLambdaInContextWithPrefix modulePrefix locals args body

        Call fn args ->
            generateCallInContextWithPrefix modulePrefix locals fn args

        If branches elseExpr ->
            generateIfInContextWithPrefix modulePrefix locals branches elseExpr

        Let defs body ->
            generateLetInContextWithPrefix modulePrefix locals defs body

        Case subject branches ->
            -- Strip guards from branches (guards not yet supported in code gen)
            let
                strippedBranches = List.map (\( pat, _, body ) -> ( pat, body )) branches
            in
            generateCaseInContextWithPrefix modulePrefix locals subject strippedBranches

        Accessor field ->
            "/* accessor ." ++ field ++ " */"

        Access record (Src.At _ field) ->
            "tcelm_record_get(" ++ generateExprInContextWithPrefix modulePrefix locals record ++ ", \"" ++ field ++ "\")"

        Update (Src.At _ recordName) fields ->
            generateRecordUpdateInContextWithPrefix modulePrefix locals recordName fields

        Record fields ->
            generateRecordInContextWithPrefix modulePrefix locals fields

        Unit ->
            "TCELM_UNIT"

        Tuple a b rest ->
            case rest of
                [] ->
                    "tcelm_tuple2(arena, " ++ generateExprInContextWithPrefix modulePrefix locals a ++ ", " ++ generateExprInContextWithPrefix modulePrefix locals b ++ ")"

                [ c ] ->
                    "tcelm_tuple3(arena, "
                        ++ generateExprInContextWithPrefix modulePrefix locals a ++ ", "
                        ++ generateExprInContextWithPrefix modulePrefix locals b ++ ", "
                        ++ generateExprInContextWithPrefix modulePrefix locals c ++ ")"

                _ ->
                    "/* tuple with more than 3 elements not supported */"


{-| Generate list with prefix
-}
generateListInContextWithPrefix : String -> List String -> List Expr -> String
generateListInContextWithPrefix modulePrefix locals exprs =
    case exprs of
        [] -> "TCELM_NIL"
        x :: xs -> "tcelm_cons(arena, " ++ generateExprInContextWithPrefix modulePrefix locals x ++ ", " ++ generateListInContextWithPrefix modulePrefix locals xs ++ ")"


{-| Generate binops with prefix
-}
generateBinopsInContextWithPrefix : String -> List String -> List ( Expr, Src.Located String ) -> Expr -> String
generateBinopsInContextWithPrefix modulePrefix locals pairs finalExpr =
    case pairs of
        [] -> generateExprInContextWithPrefix modulePrefix locals finalExpr
        ( leftExpr, Src.At _ op ) :: rest ->
            let
                rightExpr = generateBinopsInContextWithPrefix modulePrefix locals rest finalExpr
                l = generateExprInContextWithPrefix modulePrefix locals leftExpr
            in
            generateBinop op l rightExpr


{-| Generate lambda with prefix
-}
generateLambdaInContextWithPrefix : String -> List String -> List Pattern -> Expr -> String
generateLambdaInContextWithPrefix modulePrefix outerLocals args body =
    let
        arity = List.length args
        lambdaLocals = patternVarss args
        allLocals = lambdaLocals ++ outerLocals
        paramBindings = List.indexedMap (\i pattern -> generateLambdaArgBindingLocal pattern ("args[" ++ String.fromInt i ++ "]")) args
            |> List.concat |> String.join "\n                "
        bodyCode = generateExprInContextWithPrefix modulePrefix allLocals body
    in
    if arity == 0 then
        "({\n            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                (void)args;\n                tcelm_arena_t *arena = __a;\n"
            ++ "                return " ++ bodyCode ++ ";\n            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, 0);\n        })"
    else
        "({\n            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                tcelm_arena_t *arena = __a;\n                " ++ paramBindings ++ "\n"
            ++ "                return " ++ bodyCode ++ ";\n            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, " ++ String.fromInt arity ++ ");\n        })"


{-| Generate call with prefix
-}
generateCallInContextWithPrefix : String -> List String -> Expr -> List Expr -> String
generateCallInContextWithPrefix modulePrefix locals fn args =
    let
        argsC = List.map (generateExprInContextWithPrefix modulePrefix locals) args
        isConstructorCall = case fn of
            Src.At _ (Var Src.CapVar _) -> True
            Src.At _ (VarQual Src.CapVar _ _) -> True
            _ -> False
        isDirectCall = case fn of
            Src.At _ (VarQual Src.LowVar _ _) -> True
            _ -> False
    in
    if isConstructorCall then
        let
            ( ctorNameUpper, ctorNameOrig ) = case fn of
                Src.At _ (Var Src.CapVar name) -> let shortName = extractCtorName name in ( String.toUpper shortName, shortName )
                Src.At _ (VarQual Src.CapVar _ name) -> ( String.toUpper name, name )
                _ -> ( "UNKNOWN", "Unknown" )
            arity = List.length args
        in
        if arity == 0 then
            "tcelm_custom(arena, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ ctorNameOrig ++ "\", 0)"
        else
            "tcelm_custom(arena, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ ctorNameOrig ++ "\", " ++ String.fromInt arity ++ ", " ++ String.join ", " argsC ++ ")"
    else if isDirectCall then
        let
            ( modulePath, fnNameLocal ) = case fn of
                Src.At _ (VarQual Src.LowVar mp n) -> ( mp, n )
                _ -> ( "", "" )
            fnName = mapStdLibFunction modulePath fnNameLocal
            numArgs = List.length args
            maybeArity = getStdLibArity modulePath fnNameLocal
            needsArena = stdLibNeedsArena modulePath fnNameLocal
        in
        case maybeArity of
            Just arity ->
                if numArgs >= arity then
                    if needsArena then fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"
                    else fnName ++ "(" ++ String.join ", " argsC ++ ")"
                else
                    let
                        remaining = arity - numArgs
                        capturedVars = List.indexedMap (\i _ -> "__c" ++ String.fromInt i) argsC
                        captureDecls = List.map2 (\c a -> "tcelm_value_t *" ++ c ++ " = " ++ a ++ ";") capturedVars argsC
                        applyArgs = capturedVars ++ List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (remaining - 1))
                        callArgs = if needsArena then "__a, " ++ String.join ", " applyArgs else String.join ", " applyArgs
                    in
                    "({\n" ++ String.join "\n" (List.map (\d -> "                " ++ d) captureDecls)
                        ++ "\n                auto tcelm_value_t *__partial_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                        ++ "                    (void)__a;\n                    return " ++ fnName ++ "(" ++ callArgs ++ ");\n"
                        ++ "                }\n                tcelm_closure(arena, __partial_impl, " ++ String.fromInt remaining ++ ");\n            })"
            Nothing -> fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"
    else
        let
            fnExpr = generateExprInContextWithPrefix modulePrefix locals fn
        in
        case List.length args of
            0 -> fnExpr
            1 -> "tcelm_apply(arena, " ++ fnExpr ++ ", " ++ String.join "" argsC ++ ")"
            n -> "tcelm_apply_n(arena, " ++ fnExpr ++ ", " ++ String.fromInt n ++ ", " ++ String.join ", " argsC ++ ")"


{-| Generate if with prefix
-}
generateIfInContextWithPrefix : String -> List String -> List ( Expr, Expr ) -> Expr -> String
generateIfInContextWithPrefix modulePrefix locals branches elseExpr =
    case branches of
        [] -> generateExprInContextWithPrefix modulePrefix locals elseExpr
        [ ( cond, then_ ) ] ->
            "(TCELM_AS_BOOL(" ++ generateExprInContextWithPrefix modulePrefix locals cond ++ ") ? "
                ++ generateExprInContextWithPrefix modulePrefix locals then_ ++ " : "
                ++ generateExprInContextWithPrefix modulePrefix locals elseExpr ++ ")"
        ( cond, then_ ) :: rest ->
            "(TCELM_AS_BOOL(" ++ generateExprInContextWithPrefix modulePrefix locals cond ++ ") ? "
                ++ generateExprInContextWithPrefix modulePrefix locals then_ ++ " : "
                ++ generateIfInContextWithPrefix modulePrefix locals rest elseExpr ++ ")"


{-| Generate let with prefix
-}
generateLetInContextWithPrefix : String -> List String -> List (Src.Located Src.Def) -> Expr -> String
generateLetInContextWithPrefix modulePrefix outerLocals defs body =
    let
        -- Collect all local names (both simple bindings and local functions)
        letLocals = List.concatMap (\(Src.At _ def) ->
            case def of
                Src.Define (Src.At _ name) _ _ _ -> [ name ]
                Src.Destruct pat _ -> patternVars pat
            ) defs
        allLocals = letLocals ++ outerLocals
        defStrs = List.map (generateLocatedDefInContextWithPrefix modulePrefix allLocals) defs
        bodyStr = generateExprInContextWithPrefix modulePrefix allLocals body
    in
    "({\n" ++ String.join "\n" (List.map (\d -> "        " ++ d) defStrs) ++ "\n        " ++ bodyStr ++ ";\n    })"


{-| Generate a located definition with prefix
-}
generateLocatedDefInContextWithPrefix : String -> List String -> Src.Located Src.Def -> String
generateLocatedDefInContextWithPrefix modulePrefix locals (Src.At _ def) =
    case def of
        Src.Define (Src.At _ name) args body _ ->
            if List.isEmpty args then
                "tcelm_value_t *" ++ mangleLocal name ++ " = " ++ generateExprInContextWithPrefix modulePrefix locals body ++ ";"
            else
                -- Local function with arguments - generate GCC nested function + closure
                let
                    arity = List.length args
                    funcLocals = patternVarss args
                    allLocals = funcLocals ++ locals
                    mangledName = mangleLocal name
                    implName = mangledName ++ "_impl"

                    argBindings =
                        List.map2 generateArgBinding args (List.indexedMap (\i _ -> "arg" ++ String.fromInt i) args)
                            |> List.concat

                    bodyCode = generateExprInContextWithPrefix modulePrefix allLocals body

                    -- Generate the nested function
                    nestedFunc =
                        "auto tcelm_value_t *" ++ implName ++ "(tcelm_arena_t *arena, tcelm_value_t **args) {\n"
                            ++ (if arity == 0 then
                                    "            (void)args;\n"
                                else
                                    String.join "\n"
                                        (List.indexedMap
                                            (\i _ -> "            tcelm_value_t *arg" ++ String.fromInt i ++ " = args[" ++ String.fromInt i ++ "];")
                                            args
                                        )
                                        ++ "\n"
                               )
                            ++ (if List.isEmpty argBindings then "" else String.join "\n" (List.map (\b -> "            " ++ b) argBindings) ++ "\n")
                            ++ "            return " ++ bodyCode ++ ";\n"
                            ++ "        }"

                    -- Create closure for the function
                    closureDecl =
                        "tcelm_value_t *" ++ mangledName ++ " = tcelm_closure(arena, " ++ implName ++ ", " ++ String.fromInt arity ++ ");"
                in
                nestedFunc ++ "\n        " ++ closureDecl
        Src.Destruct pattern body ->
            let
                destExpr = generateExprInContextWithPrefix modulePrefix locals body
                bindings = generatePatternBindingsLocal "__destruct" pattern
            in
            "tcelm_value_t *__destruct = " ++ destExpr ++ ";\n        " ++ String.join "\n        " bindings


{-| Generate case with prefix
-}
generateCaseInContextWithPrefix : String -> List String -> Expr -> List ( Pattern, Expr ) -> String
generateCaseInContextWithPrefix modulePrefix locals subject branches =
    let
        subjectVar = "__case_subject"
        branchStrs = List.indexedMap (generateBranchInContextWithPrefix modulePrefix locals subjectVar) branches
    in
    "({\n        tcelm_value_t *" ++ subjectVar ++ " = " ++ generateExprInContextWithPrefix modulePrefix locals subject ++ ";\n"
        ++ String.join "\n" branchStrs ++ "\n        TCELM_UNIT; /* unreachable */\n    })"


{-| Generate a case branch with prefix
-}
generateBranchInContextWithPrefix : String -> List String -> String -> Int -> ( Pattern, Expr ) -> String
generateBranchInContextWithPrefix modulePrefix outerLocals subjectVar index ( pattern, body ) =
    let
        patternLocals = patternVars pattern
        allLocals = patternLocals ++ outerLocals
        condition = generatePatternMatch subjectVar pattern
        bindings = generatePatternBindingsLocal subjectVar pattern
        bodyStr = generateExprInContextWithPrefix modulePrefix allLocals body
    in
    "        if (" ++ condition ++ ") {\n"
        ++ String.join "\n" (List.map (\b -> "            " ++ b) bindings)
        ++ (if List.isEmpty bindings then "" else "\n")
        ++ "            " ++ bodyStr ++ ";\n        }"


{-| Generate record with prefix
-}
generateRecordInContextWithPrefix : String -> List String -> List ( Src.Located String, Expr ) -> String
generateRecordInContextWithPrefix modulePrefix locals fields =
    let
        fieldCount = List.length fields
        fieldStrs = List.map (\( Src.At _ name, value ) -> "\"" ++ name ++ "\", " ++ generateExprInContextWithPrefix modulePrefix locals value) fields
    in
    "tcelm_record(arena, " ++ String.fromInt fieldCount ++ ", " ++ String.join ", " fieldStrs ++ ")"


{-| Generate record update with prefix
-}
generateRecordUpdateInContextWithPrefix : String -> List String -> String -> List ( Src.Located String, Expr ) -> String
generateRecordUpdateInContextWithPrefix modulePrefix locals recordName fields =
    case fields of
        [] -> if List.member recordName locals then mangleLocal recordName else mangleWithPrefix modulePrefix recordName
        ( Src.At _ fieldName, value ) :: rest ->
            "tcelm_record_update(arena, " ++ generateRecordUpdateInContextWithPrefix modulePrefix locals recordName rest
                ++ ", \"" ++ fieldName ++ "\", " ++ generateExprInContextWithPrefix modulePrefix locals value ++ ")"


{-| Generate expression in context of local variables
-}
generateExprInContext : List String -> Expr -> String
generateExprInContext locals (Src.At _ expr) =
    case expr of
        Int n ->
            "tcelm_int(arena, " ++ String.fromInt n ++ ")"

        Float f ->
            "tcelm_float(arena, " ++ String.fromFloat f ++ ")"

        Chr c ->
            case String.uncons c of
                Just ( ch, _ ) ->
                    "tcelm_char(arena, " ++ String.fromInt (Char.toCode ch) ++ ")"

                Nothing ->
                    "tcelm_char(arena, 0)"

        Str s ->
            "tcelm_string(arena, \"" ++ escapeC s ++ "\")"

        Var varType name ->
            case varType of
                Src.LowVar ->
                    if List.member name locals then
                        -- Local variable - use directly
                        mangleLocal name
                    else
                        -- Check for known Basics functions used unqualified
                        case name of
                            "identity" ->
                                "tcelm_closure(arena, tcelm_identity_impl, 1)"

                            "toFloat" ->
                                "tcelm_closure(arena, tcelm_to_float_impl, 1)"

                            "min" ->
                                "tcelm_closure(arena, tcelm_min_impl, 2)"

                            "max" ->
                                "tcelm_closure(arena, tcelm_max_impl, 2)"

                            _ ->
                                -- Top-level function/value - call directly if arity 0, else create closure
                                "(" ++ mangle name ++ "_ARITY == 0 ? " ++ mangle name ++ "(arena) : tcelm_closure(arena, " ++ mangle name ++ "_impl, " ++ mangle name ++ "_ARITY))"

                Src.CapVar ->
                    -- Constructor reference - handle known cases
                    -- Extract short name for qualified constructors like AST.Source.At -> At
                    let
                        shortName = extractCtorName name
                    in
                    case shortName of
                        -- Boolean
                        "True" ->
                            "tcelm_custom(arena, TCELM_CTOR_TRUE, \"True\", 0)"

                        "False" ->
                            "tcelm_custom(arena, TCELM_CTOR_FALSE, \"False\", 0)"

                        -- Maybe
                        "Nothing" ->
                            "tcelm_custom(arena, TCELM_CTOR_NOTHING, \"Nothing\", 0)"

                        "Just" ->
                            -- 1-ary constructor: closure that creates Just
                            makeConstructorClosure "Just" 1

                        -- Result
                        "Ok" ->
                            makeConstructorClosure "Ok" 1

                        "Err" ->
                            makeConstructorClosure "Err" 1

                        -- Ordering
                        "LT" ->
                            "tcelm_custom(arena, TCELM_CTOR_LT, \"LT\", 0)"

                        "EQ" ->
                            "tcelm_custom(arena, TCELM_CTOR_EQ, \"EQ\", 0)"

                        "GT" ->
                            "tcelm_custom(arena, TCELM_CTOR_GT, \"GT\", 0)"

                        -- Parser types from Parse/Primitives.elm
                        "Parser" ->
                            makeConstructorClosure "Parser" 1

                        "Good" ->
                            makeConstructorClosure "Good" 3

                        "Bad" ->
                            makeConstructorClosure "Bad" 2

                        "Empty" ->
                            "tcelm_custom(arena, TCELM_CTOR_EMPTY, \"Empty\", 0)"

                        "AddRight" ->
                            makeConstructorClosure "AddRight" 2

                        "Append" ->
                            makeConstructorClosure "Append" 2

                        -- AST types
                        "At" ->
                            makeConstructorClosure "At" 2

                        _ ->
                            -- Unknown constructor - generate as nullary by default
                            -- This may need extension for specific constructors
                            "tcelm_custom(arena, TCELM_CTOR_" ++ String.toUpper shortName ++ ", \"" ++ shortName ++ "\", 0)"

        VarQual varType modulePath name ->
            -- When used as a value, stdlib functions need to be wrapped in closures
            case varType of
                Src.LowVar ->
                    case getStdLibArity modulePath name of
                        Just arity ->
                            -- Generate a closure wrapper for the stdlib function
                            let
                                fnName =
                                    mapStdLibFunction modulePath name

                                needsArena =
                                    stdLibNeedsArena modulePath name

                                argBindings =
                                    List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (arity - 1))

                                callArgs =
                                    if needsArena then
                                        "__a, " ++ String.join ", " argBindings
                                    else
                                        String.join ", " argBindings
                            in
                            "({\n"
                                ++ "                auto tcelm_value_t *__fn_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                                ++ "                    (void)__a;\n"
                                ++ "                    return "
                                ++ fnName
                                ++ "("
                                ++ callArgs
                                ++ ");\n"
                                ++ "                }\n"
                                ++ "                tcelm_closure(arena, __fn_impl, "
                                ++ String.fromInt arity
                                ++ ");\n"
                                ++ "            })"

                        Nothing ->
                            -- Unknown function - just return the mangled name
                            mapStdLibFunction modulePath name

                Src.CapVar ->
                    -- Constructor reference
                    mapStdLibFunction modulePath name

        List exprs ->
            generateListInContext locals exprs

        Op opName ->
            "/* op " ++ opName ++ " */"

        Negate inner ->
            "tcelm_negate_int(arena, " ++ generateExprInContext locals inner ++ ")"

        Binops pairs finalExpr ->
            generateBinopsInContext locals pairs finalExpr

        Lambda args body ->
            generateLambdaInContext locals args body

        Call fn args ->
            generateCallInContext locals fn args

        If branches elseExpr ->
            generateIfInContext locals branches elseExpr

        Let defs body ->
            generateLetInContext locals defs body

        Case subject branches ->
            -- Strip guards from branches (guards not yet supported in code gen)
            let
                strippedBranches = List.map (\( pat, _, body ) -> ( pat, body )) branches
            in
            generateCaseInContext locals subject strippedBranches

        Accessor field ->
            "/* accessor ." ++ field ++ " */"

        Access record (Src.At _ field) ->
            "tcelm_record_get(" ++ generateExprInContext locals record ++ ", \"" ++ field ++ "\")"

        Update (Src.At _ recordName) fields ->
            generateRecordUpdateInContext locals recordName fields

        Record fields ->
            generateRecordInContext locals fields

        Unit ->
            "TCELM_UNIT"

        Tuple a b rest ->
            case rest of
                [] ->
                    "tcelm_tuple2(arena, " ++ generateExprInContext locals a ++ ", " ++ generateExprInContext locals b ++ ")"

                [ c ] ->
                    "tcelm_tuple3(arena, "
                        ++ generateExprInContext locals a
                        ++ ", "
                        ++ generateExprInContext locals b
                        ++ ", "
                        ++ generateExprInContext locals c
                        ++ ")"

                _ ->
                    "/* tuple with more than 3 elements not supported */"


{-| Generate list expression with locals context
-}
generateListInContext : List String -> List Expr -> String
generateListInContext locals exprs =
    case exprs of
        [] ->
            "TCELM_NIL"

        x :: xs ->
            "tcelm_cons(arena, "
                ++ generateExprInContext locals x
                ++ ", "
                ++ generateListInContext locals xs
                ++ ")"


{-| Generate binops with locals context
-}
generateBinopsInContext : List String -> List ( Expr, Src.Located String ) -> Expr -> String
generateBinopsInContext locals pairs finalExpr =
    case pairs of
        [] ->
            generateExprInContext locals finalExpr

        ( leftExpr, Src.At _ op ) :: rest ->
            let
                rightExpr =
                    generateBinopsInContext locals rest finalExpr

                l =
                    generateExprInContext locals leftExpr
            in
            generateBinopInContext locals op l rightExpr


{-| Generate a single binop with locals
-}
generateBinopInContext : List String -> String -> String -> String -> String
generateBinopInContext locals op l r =
    -- Same as generateBinop but with context
    generateBinop op l r


{-| Generate lambda with locals context
-}
generateLambdaInContext : List String -> List Pattern -> Expr -> String
generateLambdaInContext outerLocals args body =
    let
        arity =
            List.length args

        -- Collect new locals from lambda args
        lambdaLocals =
            patternVarss args

        allLocals =
            lambdaLocals ++ outerLocals

        paramBindings =
            List.indexedMap
                (\i pattern ->
                    let
                        argName = "args[" ++ String.fromInt i ++ "]"
                    in
                    generateLambdaArgBindingLocal pattern argName
                )
                args
                |> List.concat
                |> String.join "\n                "

        bodyCode =
            generateExprInContext allLocals body
    in
    if arity == 0 then
        "({\n"
            ++ "            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                (void)args;\n"
            ++ "                tcelm_arena_t *arena = __a;\n"
            ++ "                return " ++ bodyCode ++ ";\n"
            ++ "            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, 0);\n"
            ++ "        })"
    else
        "({\n"
            ++ "            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                tcelm_arena_t *arena = __a;\n"
            ++ "                " ++ paramBindings ++ "\n"
            ++ "                return " ++ bodyCode ++ ";\n"
            ++ "            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, " ++ String.fromInt arity ++ ");\n"
            ++ "        })"


{-| Sanitize an expression to make it a valid C identifier suffix
-}
sanitizeForCIdent : String -> String
sanitizeForCIdent s =
    -- Truncate long expressions to avoid extremely long identifiers
    let
        truncated =
            if String.length s > 60 then
                String.left 60 s

            else
                s
    in
    String.replace "[" "_" truncated
        |> String.replace "]" ""
        |> String.replace "(" "_"
        |> String.replace ")" ""
        |> String.replace "{" "_"
        |> String.replace "}" ""
        |> String.replace "," "_"
        |> String.replace " " ""
        |> String.replace "\"" ""
        |> String.replace "'" ""
        |> String.replace "-" "_"
        |> String.replace "." "_"
        |> String.replace "+" "_"
        |> String.replace "*" "_"
        |> String.replace "/" "_"
        |> String.replace "=" "_"
        |> String.replace "<" "_"
        |> String.replace ">" "_"
        |> String.replace "!" "_"
        |> String.replace "&" "_"
        |> String.replace "|" "_"
        |> String.replace ";" "_"
        |> String.replace ":" "_"
        |> String.replace "\\" "_"
        |> String.replace "\n" "_"
        |> String.replace "\t" "_"


{-| Generate lambda arg binding using local mangling
-}
generateLambdaArgBindingLocal : Pattern -> String -> List String
generateLambdaArgBindingLocal pattern argExpr =
    let
        -- Create unique temp names based on argExpr
        suffix =
            sanitizeForCIdent argExpr

        t1Name =
            "__t1_" ++ suffix

        t2Name =
            "__t2_" ++ suffix

        headName =
            "__head_" ++ suffix

        tailName =
            "__tail_" ++ suffix
    in
    case patternValue pattern of
        PVar varName ->
            [ "tcelm_value_t *" ++ mangleLocal varName ++ " = " ++ argExpr ++ ";" ]

        PAnything ->
            [ "(void)" ++ argExpr ++ ";" ]

        PRecord fields ->
            List.map
                (\(Src.At _ fieldName) ->
                    "tcelm_value_t *"
                        ++ mangleLocal fieldName
                        ++ " = tcelm_record_get("
                        ++ argExpr
                        ++ ", \""
                        ++ fieldName
                        ++ "\");"
                )
                fields

        PTuple p1 p2 rest ->
            case rest of
                [] ->
                    -- 2-tuple
                    [ "tcelm_value_t *" ++ t1Name ++ " = tcelm_tuple2_first(" ++ argExpr ++ ");"
                    , "tcelm_value_t *" ++ t2Name ++ " = tcelm_tuple2_second(" ++ argExpr ++ ");"
                    ]
                        ++ generateLambdaArgBindingLocal p1 t1Name
                        ++ generateLambdaArgBindingLocal p2 t2Name

                [ p3 ] ->
                    -- 3-tuple
                    let
                        t3Name =
                            "__t3_" ++ suffix
                    in
                    [ "tcelm_value_t *" ++ t1Name ++ " = tcelm_tuple3_first(" ++ argExpr ++ ");"
                    , "tcelm_value_t *" ++ t2Name ++ " = tcelm_tuple3_second(" ++ argExpr ++ ");"
                    , "tcelm_value_t *" ++ t3Name ++ " = tcelm_tuple3_third(" ++ argExpr ++ ");"
                    ]
                        ++ generateLambdaArgBindingLocal p1 t1Name
                        ++ generateLambdaArgBindingLocal p2 t2Name
                        ++ generateLambdaArgBindingLocal p3 t3Name

                _ ->
                    [ "/* tuple with more than 3 elements not supported */" ]

        PCons head tail ->
            [ "tcelm_value_t *" ++ headName ++ " = tcelm_list_head(" ++ argExpr ++ ");"
            , "tcelm_value_t *" ++ tailName ++ " = tcelm_list_tail(" ++ argExpr ++ ");"
            ]
                ++ generateLambdaArgBindingLocal head headName
                ++ generateLambdaArgBindingLocal tail tailName

        PCtor _ _ args ->
            List.indexedMap
                (\i arg ->
                    generateLambdaArgBindingLocal arg ("tcelm_custom_arg(" ++ argExpr ++ ", " ++ String.fromInt i ++ ")")
                )
                args
                |> List.concat

        PCtorQual _ _ _ args ->
            List.indexedMap
                (\i arg ->
                    generateLambdaArgBindingLocal arg ("tcelm_custom_arg(" ++ argExpr ++ ", " ++ String.fromInt i ++ ")")
                )
                args
                |> List.concat

        _ ->
            [ "/* complex lambda pattern not yet supported */" ]


{-| Generate call with locals context
-}
generateCallInContext : List String -> Expr -> List Expr -> String
generateCallInContext locals fn args =
    let
        argsC =
            List.map (generateExprInContext locals) args

        isConstructorCall =
            case fn of
                Src.At _ (Var Src.CapVar _) ->
                    True

                Src.At _ (VarQual Src.CapVar _ _) ->
                    True

                _ ->
                    False

        isDirectCall =
            case fn of
                Src.At _ (VarQual Src.LowVar _ _) ->
                    True

                _ ->
                    False
    in
    if isConstructorCall then
        let
            ( ctorNameUpper, ctorNameOrig ) =
                case fn of
                    Src.At _ (Var Src.CapVar name) ->
                        let
                            shortName = extractCtorName name
                        in
                        ( String.toUpper shortName, shortName )

                    Src.At _ (VarQual Src.CapVar _ name) ->
                        ( String.toUpper name, name )

                    _ ->
                        ( "UNKNOWN", "Unknown" )

            arity =
                List.length args
        in
        if arity == 0 then
            "tcelm_custom(arena, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ ctorNameOrig ++ "\", 0)"
        else
            "tcelm_custom(arena, TCELM_CTOR_"
                ++ ctorNameUpper
                ++ ", \""
                ++ ctorNameOrig
                ++ "\", "
                ++ String.fromInt arity
                ++ ", "
                ++ String.join ", " argsC
                ++ ")"

    else if isDirectCall then
        -- Direct call to a qualified function (VarQual LowVar)
        let
            -- Get module path and name directly (don't use generateExprInContext which generates closures)
            ( modulePath, fnNameLocal ) =
                case fn of
                    Src.At _ (VarQual Src.LowVar mp n) ->
                        ( mp, n )

                    _ ->
                        ( "", "" )

            -- Get the C function name for this stdlib function
            fnName =
                mapStdLibFunction modulePath fnNameLocal

            numArgs =
                List.length args

            maybeArity =
                getStdLibArity modulePath fnNameLocal

            needsArena =
                stdLibNeedsArena modulePath fnNameLocal
        in
        case maybeArity of
            Just arity ->
                if numArgs >= arity then
                    -- Full application - direct call
                    if needsArena then
                        fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"
                    else
                        fnName ++ "(" ++ String.join ", " argsC ++ ")"

                else
                    -- Partial application - generate closure
                    let
                        remaining =
                            arity - numArgs

                        capturedVars =
                            List.indexedMap (\i _ -> "__c" ++ String.fromInt i) argsC

                        captureDecls =
                            List.map2 (\c a -> "tcelm_value_t *" ++ c ++ " = " ++ a ++ ";") capturedVars argsC

                        applyArgs =
                            capturedVars ++ List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (remaining - 1))

                        callArgs =
                            if needsArena then
                                "__a, " ++ String.join ", " applyArgs
                            else
                                String.join ", " applyArgs
                    in
                    "({\n"
                        ++ String.join "\n" (List.map (\d -> "                " ++ d) captureDecls)
                        ++ "\n                auto tcelm_value_t *__partial_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                        ++ "                    (void)__a;\n"
                        ++ "                    return "
                        ++ fnName
                        ++ "("
                        ++ callArgs
                        ++ ");\n"
                        ++ "                }\n"
                        ++ "                tcelm_closure(arena, __partial_impl, "
                        ++ String.fromInt remaining
                        ++ ");\n"
                        ++ "            })"

            Nothing ->
                -- Unknown function - assume full application with arena
                fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"

    else
        -- Closure application - the function expression generates a closure
        let
            fnExpr =
                generateExprInContext locals fn
        in
        case List.length args of
            0 ->
                fnExpr

            1 ->
                "tcelm_apply(arena, " ++ fnExpr ++ ", " ++ String.join "" argsC ++ ")"

            n ->
                "tcelm_apply_n(arena, "
                    ++ fnExpr
                    ++ ", "
                    ++ String.fromInt n
                    ++ ", "
                    ++ String.join ", " argsC
                    ++ ")"


{-| Generate if expression with locals
-}
generateIfInContext : List String -> List ( Expr, Expr ) -> Expr -> String
generateIfInContext locals branches elseExpr =
    case branches of
        [] ->
            generateExprInContext locals elseExpr

        [ ( cond, then_ ) ] ->
            "(TCELM_AS_BOOL("
                ++ generateExprInContext locals cond
                ++ ") ? "
                ++ generateExprInContext locals then_
                ++ " : "
                ++ generateExprInContext locals elseExpr
                ++ ")"

        ( cond, then_ ) :: rest ->
            "(TCELM_AS_BOOL("
                ++ generateExprInContext locals cond
                ++ ") ? "
                ++ generateExprInContext locals then_
                ++ " : "
                ++ generateIfInContext locals rest elseExpr
                ++ ")"


{-| Generate let expression with locals
-}
generateLetInContext : List String -> List (Src.Located Src.Def) -> Expr -> String
generateLetInContext outerLocals defs body =
    let
        -- Collect new locals from let bindings (both simple bindings and local functions)
        letLocals =
            List.concatMap
                (\(Src.At _ def) ->
                    case def of
                        Src.Define (Src.At _ name) _ _ _ ->
                            [ name ]

                        Src.Destruct pat _ ->
                            patternVars pat
                )
                defs

        allLocals =
            letLocals ++ outerLocals

        defStrs =
            List.map (generateLocatedDefInContext allLocals) defs

        bodyStr =
            generateExprInContext allLocals body
    in
    "({\n"
        ++ String.join "\n" (List.map (\d -> "        " ++ d) defStrs)
        ++ "\n        "
        ++ bodyStr
        ++ ";\n    })"


{-| Generate a located definition in context
-}
generateLocatedDefInContext : List String -> Src.Located Src.Def -> String
generateLocatedDefInContext locals (Src.At _ def) =
    case def of
        Src.Define (Src.At _ name) args body _ ->
            if List.isEmpty args then
                "tcelm_value_t *" ++ mangleLocal name ++ " = " ++ generateExprInContext locals body ++ ";"

            else
                -- Local function with arguments - generate GCC nested function + closure
                let
                    arity = List.length args
                    funcLocals = patternVarss args
                    allLocals = funcLocals ++ locals
                    mangledName = mangleLocal name
                    implName = mangledName ++ "_impl"

                    argBindings =
                        List.map2 generateArgBinding args (List.indexedMap (\i _ -> "arg" ++ String.fromInt i) args)
                            |> List.concat

                    bodyCode = generateExprInContext allLocals body

                    -- Generate the nested function
                    nestedFunc =
                        "auto tcelm_value_t *" ++ implName ++ "(tcelm_arena_t *arena, tcelm_value_t **args) {\n"
                            ++ (if arity == 0 then
                                    "            (void)args;\n"
                                else
                                    String.join "\n"
                                        (List.indexedMap
                                            (\i _ -> "            tcelm_value_t *arg" ++ String.fromInt i ++ " = args[" ++ String.fromInt i ++ "];")
                                            args
                                        )
                                        ++ "\n"
                               )
                            ++ (if List.isEmpty argBindings then "" else String.join "\n" (List.map (\b -> "            " ++ b) argBindings) ++ "\n")
                            ++ "            return " ++ bodyCode ++ ";\n"
                            ++ "        }"

                    -- Create closure for the function
                    closureDecl =
                        "tcelm_value_t *" ++ mangledName ++ " = tcelm_closure(arena, " ++ implName ++ ", " ++ String.fromInt arity ++ ");"
                in
                nestedFunc ++ "\n        " ++ closureDecl

        Src.Destruct pattern body ->
            -- Destructuring let binding: let (Pattern x) = expr in ...
            let
                destExpr = generateExprInContext locals body
                bindings = generatePatternBindingsLocal "__destruct" pattern
            in
            "tcelm_value_t *__destruct = " ++ destExpr ++ ";\n        "
                ++ String.join "\n        " bindings


{-| Generate case with locals
-}
generateCaseInContext : List String -> Expr -> List ( Pattern, Expr ) -> String
generateCaseInContext locals subject branches =
    let
        subjectVar =
            "__case_subject"

        branchStrs =
            List.indexedMap (generateBranchInContext locals subjectVar) branches
    in
    "({\n"
        ++ "        tcelm_value_t *"
        ++ subjectVar
        ++ " = "
        ++ generateExprInContext locals subject
        ++ ";\n"
        ++ String.join "\n" branchStrs
        ++ "\n        TCELM_UNIT; /* unreachable */\n    })"


{-| Generate a case branch with locals
-}
generateBranchInContext : List String -> String -> Int -> ( Pattern, Expr ) -> String
generateBranchInContext outerLocals subjectVar index ( pattern, body ) =
    let
        -- Collect new locals from pattern
        patternLocals =
            patternVars pattern

        allLocals =
            patternLocals ++ outerLocals

        condition =
            generatePatternMatch subjectVar pattern

        bindings =
            generatePatternBindingsLocal subjectVar pattern

        bodyStr =
            generateExprInContext allLocals body
    in
    "        if ("
        ++ condition
        ++ ") {\n"
        ++ String.join "\n" (List.map (\b -> "            " ++ b) bindings)
        ++ (if List.isEmpty bindings then
                ""

            else
                "\n"
           )
        ++ "            "
        ++ bodyStr
        ++ ";\n        }"


{-| Generate pattern bindings using local mangling
-}
generatePatternBindingsLocal : String -> Pattern -> List String
generatePatternBindingsLocal subject (Src.At _ pattern) =
    case pattern of
        PVar name ->
            [ "tcelm_value_t *" ++ mangleLocal name ++ " = " ++ subject ++ ";" ]

        PCons head tail ->
            let
                headBindings =
                    generatePatternBindingsLocal ("tcelm_list_head(" ++ subject ++ ")") head

                tailBindings =
                    generatePatternBindingsLocal ("tcelm_list_tail(" ++ subject ++ ")") tail
            in
            headBindings ++ tailBindings

        PCtor _ _ args ->
            List.indexedMap
                (\i arg ->
                    generatePatternBindingsLocal
                        ("tcelm_custom_arg(" ++ subject ++ ", " ++ String.fromInt i ++ ")")
                        arg
                )
                args
                |> List.concat

        PCtorQual _ _ _ args ->
            List.indexedMap
                (\i arg ->
                    generatePatternBindingsLocal
                        ("tcelm_custom_arg(" ++ subject ++ ", " ++ String.fromInt i ++ ")")
                        arg
                )
                args
                |> List.concat

        PAlias innerPattern (Src.At _ aliasName) ->
            [ "tcelm_value_t *" ++ mangleLocal aliasName ++ " = " ++ subject ++ ";" ]
                ++ generatePatternBindingsLocal subject innerPattern

        PRecord fields ->
            List.map
                (\(Src.At _ fieldName) ->
                    "tcelm_value_t *"
                        ++ mangleLocal fieldName
                        ++ " = tcelm_record_get("
                        ++ subject
                        ++ ", \""
                        ++ fieldName
                        ++ "\");"
                )
                fields

        PTuple p1 p2 rest ->
            let
                suffix =
                    sanitizeForCIdent subject

                t1Name =
                    "__tuple_1_" ++ suffix

                t2Name =
                    "__tuple_2_" ++ suffix

                t3Name =
                    "__tuple_3_" ++ suffix
            in
            case rest of
                [] ->
                    -- 2-tuple
                    [ "tcelm_value_t *" ++ t1Name ++ " = tcelm_tuple2_first(" ++ subject ++ ");"
                    , "tcelm_value_t *" ++ t2Name ++ " = tcelm_tuple2_second(" ++ subject ++ ");"
                    ]
                        ++ generatePatternBindingsLocal t1Name p1
                        ++ generatePatternBindingsLocal t2Name p2

                [ p3 ] ->
                    -- 3-tuple
                    [ "tcelm_value_t *" ++ t1Name ++ " = tcelm_tuple3_first(" ++ subject ++ ");"
                    , "tcelm_value_t *" ++ t2Name ++ " = tcelm_tuple3_second(" ++ subject ++ ");"
                    , "tcelm_value_t *" ++ t3Name ++ " = tcelm_tuple3_third(" ++ subject ++ ");"
                    ]
                        ++ generatePatternBindingsLocal t1Name p1
                        ++ generatePatternBindingsLocal t2Name p2
                        ++ generatePatternBindingsLocal t3Name p3

                _ ->
                    [ "/* tuple with more than 3 elements not supported */" ]

        PList patterns ->
            -- Generate bindings for list element patterns using local mangling
            List.indexedMap
                (\i pat ->
                    let
                        nestedTails =
                            if i == 0 then
                                subject
                            else
                                List.repeat i "tcelm_list_tail("
                                    |> String.concat
                                    |> (\prefix -> prefix ++ subject ++ String.repeat i ")")

                        accessor =
                            "tcelm_list_head(" ++ nestedTails ++ ")"
                    in
                    generatePatternBindingsLocal accessor pat
                )
                patterns
                |> List.concat

        _ ->
            []


{-| Generate record expression with locals
-}
generateRecordInContext : List String -> List ( Src.Located String, Expr ) -> String
generateRecordInContext locals fields =
    let
        fieldCount =
            List.length fields

        fieldStrs =
            List.map
                (\( Src.At _ name, value ) ->
                    "\"" ++ name ++ "\", " ++ generateExprInContext locals value
                )
                fields
    in
    "tcelm_record(arena, "
        ++ String.fromInt fieldCount
        ++ ", "
        ++ String.join ", " fieldStrs
        ++ ")"


{-| Generate record update with locals
-}
generateRecordUpdateInContext : List String -> String -> List ( Src.Located String, Expr ) -> String
generateRecordUpdateInContext locals recordName fields =
    case fields of
        [] ->
            if List.member recordName locals then
                mangleLocal recordName
            else
                mangle recordName

        ( Src.At _ fieldName, value ) :: rest ->
            "tcelm_record_update(arena, "
                ++ generateRecordUpdateInContext locals recordName rest
                ++ ", \""
                ++ fieldName
                ++ "\", "
                ++ generateExprInContext locals value
                ++ ")"


{-| Generate bindings for a function argument pattern

Uses a special prefix for local variables to distinguish from top-level functions.
-}
generateArgBinding : Pattern -> String -> List String
generateArgBinding pattern argName =
    let
        -- Create unique temp names based on argName
        suffix =
            sanitizeForCIdent argName

        t1Name =
            "__t1_" ++ suffix

        t2Name =
            "__t2_" ++ suffix

        t3Name =
            "__t3_" ++ suffix
    in
    case patternValue pattern of
        PVar varName ->
            [ "tcelm_value_t *" ++ mangleLocal varName ++ " = " ++ argName ++ ";" ]

        PAnything ->
            [ "(void)" ++ argName ++ ";" ]

        PRecord fields ->
            List.map
                (\(Src.At _ fieldName) ->
                    "tcelm_value_t *"
                        ++ mangle fieldName
                        ++ " = tcelm_record_get("
                        ++ argName
                        ++ ", \""
                        ++ fieldName
                        ++ "\");"
                )
                fields

        PTuple p1 p2 rest ->
            case rest of
                [] ->
                    -- 2-tuple
                    [ "tcelm_value_t *" ++ t1Name ++ " = tcelm_tuple2_first(" ++ argName ++ ");"
                    , "tcelm_value_t *" ++ t2Name ++ " = tcelm_tuple2_second(" ++ argName ++ ");"
                    ]
                        ++ generateArgBinding p1 t1Name
                        ++ generateArgBinding p2 t2Name

                [ p3 ] ->
                    -- 3-tuple
                    [ "tcelm_value_t *" ++ t1Name ++ " = tcelm_tuple3_first(" ++ argName ++ ");"
                    , "tcelm_value_t *" ++ t2Name ++ " = tcelm_tuple3_second(" ++ argName ++ ");"
                    , "tcelm_value_t *" ++ t3Name ++ " = tcelm_tuple3_third(" ++ argName ++ ");"
                    ]
                        ++ generateArgBinding p1 t1Name
                        ++ generateArgBinding p2 t2Name
                        ++ generateArgBinding p3 t3Name

                _ ->
                    [ "/* tuple with more than 3 elements not supported */" ]

        PCtor _ _ args ->
            -- Constructor pattern: extract arguments from custom type
            List.indexedMap
                (\i arg ->
                    let
                        argExpr = "tcelm_custom_arg(" ++ argName ++ ", " ++ String.fromInt i ++ ")"
                    in
                    generateArgBinding arg argExpr
                )
                args
                |> List.concat

        PCtorQual _ _ _ args ->
            -- Qualified constructor pattern: extract arguments
            List.indexedMap
                (\i arg ->
                    let
                        argExpr = "tcelm_custom_arg(" ++ argName ++ ", " ++ String.fromInt i ++ ")"
                    in
                    generateArgBinding arg argExpr
                )
                args
                |> List.concat

        PAlias innerPattern (Src.At _ aliasName) ->
            [ "tcelm_value_t *" ++ mangle aliasName ++ " = " ++ argName ++ ";" ]
                ++ generateArgBinding innerPattern argName

        _ ->
            [ "/* complex pattern not yet supported */" ]


{-| Extract the pattern value from a located pattern
-}
patternValue : Pattern -> Pattern_
patternValue (Src.At _ p) =
    p


{-| Generate C code for an expression
-}
generateExpr : Expr -> String
generateExpr (Src.At _ expr) =
    case expr of
        Int n ->
            "tcelm_int(arena, " ++ String.fromInt n ++ ")"

        Float f ->
            "tcelm_float(arena, " ++ String.fromFloat f ++ ")"

        Chr c ->
            -- Chr contains a String (the character)
            case String.uncons c of
                Just ( ch, _ ) ->
                    "tcelm_char(arena, " ++ String.fromInt (Char.toCode ch) ++ ")"

                Nothing ->
                    "tcelm_char(arena, 0)"

        Str s ->
            "tcelm_string(arena, \"" ++ escapeC s ++ "\")"

        Var varType name ->
            case varType of
                Src.LowVar ->
                    -- Variable reference - just use the name
                    -- If this is used in a call context, it will be handled there
                    mangle name

                Src.CapVar ->
                    -- Constructor reference
                    -- Extract short name for qualified constructors like AST.Source.At -> At
                    let
                        shortName = extractCtorName name
                    in
                    case shortName of
                        "True" ->
                            "tcelm_custom(arena, TCELM_CTOR_TRUE, \"True\", 0)"

                        "False" ->
                            "tcelm_custom(arena, TCELM_CTOR_FALSE, \"False\", 0)"

                        "Nothing" ->
                            "tcelm_custom(arena, TCELM_CTOR_NOTHING, \"Nothing\", 0)"

                        "LT" ->
                            "tcelm_custom(arena, TCELM_CTOR_LT, \"LT\", 0)"

                        "EQ" ->
                            "tcelm_custom(arena, TCELM_CTOR_EQ, \"EQ\", 0)"

                        "GT" ->
                            "tcelm_custom(arena, TCELM_CTOR_GT, \"GT\", 0)"

                        _ ->
                            -- Other constructors - reference as closure for partial application
                            -- This will need enhancement for proper constructor currying
                            mangle shortName

        VarQual varType modulePath name ->
            -- Qualified variable like List.map
            -- When used as a value, stdlib functions need closures
            case varType of
                Src.LowVar ->
                    case getStdLibArity modulePath name of
                        Just arity ->
                            let
                                fnName =
                                    mapStdLibFunction modulePath name

                                needsArena =
                                    stdLibNeedsArena modulePath name

                                argBindings =
                                    List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (arity - 1))

                                callArgs =
                                    if needsArena then
                                        "__a, " ++ String.join ", " argBindings
                                    else
                                        String.join ", " argBindings
                            in
                            "({\n"
                                ++ "                auto tcelm_value_t *__fn_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                                ++ "                    (void)__a;\n"
                                ++ "                    return "
                                ++ fnName
                                ++ "("
                                ++ callArgs
                                ++ ");\n"
                                ++ "                }\n"
                                ++ "                tcelm_closure(arena, __fn_impl, "
                                ++ String.fromInt arity
                                ++ ");\n"
                                ++ "            })"

                        Nothing ->
                            mapStdLibFunction modulePath name

                Src.CapVar ->
                    mapStdLibFunction modulePath name

        List exprs ->
            generateList exprs

        Op opName ->
            -- Operator reference (for partial application)
            "/* op " ++ opName ++ " */"

        Negate inner ->
            let
                innerC =
                    generateExpr inner
            in
            "tcelm_negate_int(arena, " ++ innerC ++ ")"

        Binops pairs finalExpr ->
            generateBinops pairs finalExpr

        Lambda args body ->
            generateLambda args body

        Call fn args ->
            generateCall fn args

        If branches elseExpr ->
            generateIf branches elseExpr

        Let defs body ->
            generateLet defs body

        Case subject branches ->
            -- Strip guards from branches (guards not yet supported in code gen)
            let
                strippedBranches = List.map (\( pat, _, body ) -> ( pat, body )) branches
            in
            generateCase subject strippedBranches

        Accessor field ->
            "/* accessor ." ++ field ++ " */"

        Access record (Src.At _ field) ->
            "tcelm_record_get(" ++ generateExpr record ++ ", \"" ++ field ++ "\")"

        Update (Src.At _ recordName) fields ->
            generateRecordUpdate recordName fields

        Record fields ->
            generateRecord fields

        Unit ->
            "TCELM_UNIT"

        Tuple a b rest ->
            case rest of
                [] ->
                    "tcelm_tuple2(arena, " ++ generateExpr a ++ ", " ++ generateExpr b ++ ")"

                [ c ] ->
                    "tcelm_tuple3(arena, "
                        ++ generateExpr a
                        ++ ", "
                        ++ generateExpr b
                        ++ ", "
                        ++ generateExpr c
                        ++ ")"

                _ ->
                    "/* tuple with more than 3 elements not supported */"


{-| Generate a list expression
-}
generateList : List Expr -> String
generateList exprs =
    case exprs of
        [] ->
            "TCELM_NIL"

        x :: xs ->
            "tcelm_cons(arena, "
                ++ generateExpr x
                ++ ", "
                ++ generateList xs
                ++ ")"


{-| Generate a chain of binary operations
-}
generateBinops : List ( Expr, Src.Located String ) -> Expr -> String
generateBinops pairs finalExpr =
    case pairs of
        [] ->
            generateExpr finalExpr

        ( leftExpr, Src.At _ op ) :: rest ->
            let
                rightExpr =
                    generateBinops rest finalExpr

                l =
                    generateExpr leftExpr
            in
            generateBinop op l rightExpr


{-| Generate a single binary operation
-}
generateBinop : String -> String -> String -> String
generateBinop op l r =
    case op of
        "+" ->
            "tcelm_add_int(arena, " ++ l ++ ", " ++ r ++ ")"

        "-" ->
            "tcelm_sub_int(arena, " ++ l ++ ", " ++ r ++ ")"

        "*" ->
            "tcelm_mul_int(arena, " ++ l ++ ", " ++ r ++ ")"

        "//" ->
            "tcelm_div_int(arena, " ++ l ++ ", " ++ r ++ ")"

        "/" ->
            "tcelm_div_float(arena, " ++ l ++ ", " ++ r ++ ")"

        "==" ->
            "tcelm_eq(arena, " ++ l ++ ", " ++ r ++ ")"

        "/=" ->
            "tcelm_neq(arena, " ++ l ++ ", " ++ r ++ ")"

        "<" ->
            "tcelm_lt(arena, " ++ l ++ ", " ++ r ++ ")"

        ">" ->
            "tcelm_gt(arena, " ++ l ++ ", " ++ r ++ ")"

        "<=" ->
            "tcelm_le(arena, " ++ l ++ ", " ++ r ++ ")"

        ">=" ->
            "tcelm_ge(arena, " ++ l ++ ", " ++ r ++ ")"

        "&&" ->
            "tcelm_and(arena, " ++ l ++ ", " ++ r ++ ")"

        "||" ->
            "tcelm_or(arena, " ++ l ++ ", " ++ r ++ ")"

        "::" ->
            "tcelm_cons(arena, " ++ l ++ ", " ++ r ++ ")"

        "++" ->
            "tcelm_string_append(arena, " ++ l ++ ", " ++ r ++ ")"

        "|>" ->
            -- Pipeline: x |> f  means  f(x)
            -- l is the value, r is the function
            "tcelm_apply(arena, " ++ r ++ ", " ++ l ++ ")"

        "<|" ->
            -- Reverse pipeline: f <| x  means  f(x)
            -- l is the function, r is the value
            "tcelm_apply(arena, " ++ l ++ ", " ++ r ++ ")"

        ">>" ->
            -- Forward composition: f >> g  means  \x -> g(f(x))
            -- Use runtime composition function
            "tcelm_compose_fwd(arena, " ++ l ++ ", " ++ r ++ ")"

        "<<" ->
            -- Backward composition: f << g  means  \x -> f(g(x))
            -- Use runtime composition function
            "tcelm_compose_bwd(arena, " ++ l ++ ", " ++ r ++ ")"

        _ ->
            "/* unknown binop " ++ op ++ " */ tcelm_apply_n(arena, " ++ mangle op ++ ", 2, " ++ l ++ ", " ++ r ++ ")"


{-| Generate a lambda expression

Uses GCC nested functions (also supported by TCC) to create closures.
The nested function can capture variables from the enclosing scope.
-}
generateLambda : List Pattern -> Expr -> String
generateLambda args body =
    let
        arity =
            List.length args

        -- Generate parameter bindings
        paramBindings =
            List.indexedMap
                (\i pattern ->
                    let
                        argName = "args[" ++ String.fromInt i ++ "]"
                    in
                    generateLambdaArgBinding pattern argName
                )
                args
                |> List.concat
                |> String.join "\n                "

        bodyCode =
            generateExpr body
    in
    if arity == 0 then
        -- Zero-argument lambda (thunk)
        "({\n"
            ++ "            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                (void)args;\n"
            ++ "                tcelm_arena_t *arena = __a;\n"
            ++ "                return " ++ bodyCode ++ ";\n"
            ++ "            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, 0);\n"
            ++ "        })"
    else
        "({\n"
            ++ "            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                tcelm_arena_t *arena = __a;\n"
            ++ "                " ++ paramBindings ++ "\n"
            ++ "                return " ++ bodyCode ++ ";\n"
            ++ "            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, " ++ String.fromInt arity ++ ");\n"
            ++ "        })"


{-| Generate argument bindings for a lambda parameter
-}
generateLambdaArgBinding : Pattern -> String -> List String
generateLambdaArgBinding pattern argExpr =
    let
        -- Create unique temp names based on argExpr
        suffix =
            sanitizeForCIdent argExpr

        t1Name =
            "__t1_" ++ suffix

        t2Name =
            "__t2_" ++ suffix

        headName =
            "__head_" ++ suffix

        tailName =
            "__tail_" ++ suffix
    in
    case patternValue pattern of
        PVar varName ->
            [ "tcelm_value_t *" ++ mangle varName ++ " = " ++ argExpr ++ ";" ]

        PAnything ->
            [ "(void)" ++ argExpr ++ ";" ]

        PRecord fields ->
            List.map
                (\(Src.At _ fieldName) ->
                    "tcelm_value_t *"
                        ++ mangle fieldName
                        ++ " = tcelm_record_get("
                        ++ argExpr
                        ++ ", \""
                        ++ fieldName
                        ++ "\");"
                )
                fields

        PTuple p1 p2 _ ->
            [ "tcelm_value_t *" ++ t1Name ++ " = tcelm_tuple2_first(" ++ argExpr ++ ");"
            , "tcelm_value_t *" ++ t2Name ++ " = tcelm_tuple2_second(" ++ argExpr ++ ");"
            ]
                ++ generateLambdaArgBinding p1 t1Name
                ++ generateLambdaArgBinding p2 t2Name

        PCons head tail ->
            [ "tcelm_value_t *" ++ headName ++ " = tcelm_list_head(" ++ argExpr ++ ");"
            , "tcelm_value_t *" ++ tailName ++ " = tcelm_list_tail(" ++ argExpr ++ ");"
            ]
                ++ generateLambdaArgBinding head headName
                ++ generateLambdaArgBinding tail tailName

        _ ->
            [ "/* complex lambda pattern not yet supported */" ]


{-| Generate a function call

For direct calls to known functions (Var), we call them directly.
For constructor calls (CapVar), we generate tcelm_custom.
For calls to closures or computed functions, we use tcelm_apply.
-}
generateCall : Expr -> List Expr -> String
generateCall fn args =
    let
        argsC =
            List.map generateExpr args

        -- Check if this is a constructor call
        isConstructorCall =
            case fn of
                Src.At _ (Var Src.CapVar _) ->
                    True

                Src.At _ (VarQual Src.CapVar _ _) ->
                    True

                _ ->
                    False

        -- Check if this is a direct call to a named function
        -- Only qualified names (like List.map) are definitely direct calls
        -- Unqualified names might be pattern-bound variables holding closures
        isDirectCall =
            case fn of
                Src.At _ (VarQual Src.LowVar _ _) ->
                    True

                _ ->
                    False
    in
    if isConstructorCall then
        -- Constructor call: generate tcelm_custom
        let
            ( ctorNameUpper, ctorNameOrig ) =
                case fn of
                    Src.At _ (Var Src.CapVar name) ->
                        let
                            shortName = extractCtorName name
                        in
                        ( String.toUpper shortName, shortName )

                    Src.At _ (VarQual Src.CapVar _ name) ->
                        ( String.toUpper name, name )

                    _ ->
                        ( "UNKNOWN", "Unknown" )

            arity =
                List.length args
        in
        if arity == 0 then
            -- Nullary constructor
            "tcelm_custom(arena, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ ctorNameOrig ++ "\", 0)"
        else
            "tcelm_custom(arena, TCELM_CTOR_"
                ++ ctorNameUpper
                ++ ", \""
                ++ ctorNameOrig
                ++ "\", "
                ++ String.fromInt arity
                ++ ", "
                ++ String.join ", " argsC
                ++ ")"

    else if isDirectCall then
        -- Direct function call to a qualified function (VarQual LowVar)
        let
            -- Get module path and name directly (don't use generateExpr which generates closures)
            ( modulePath, fnNameLocal ) =
                case fn of
                    Src.At _ (VarQual Src.LowVar mp n) ->
                        ( mp, n )

                    _ ->
                        ( "", "" )

            -- Get the C function name for this stdlib function
            fnName =
                mapStdLibFunction modulePath fnNameLocal

            numArgs =
                List.length args

            maybeArity =
                getStdLibArity modulePath fnNameLocal

            needsArena =
                stdLibNeedsArena modulePath fnNameLocal
        in
        case maybeArity of
            Just arity ->
                if numArgs >= arity then
                    if needsArena then
                        fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"
                    else
                        fnName ++ "(" ++ String.join ", " argsC ++ ")"

                else
                    let
                        remaining =
                            arity - numArgs

                        capturedVars =
                            List.indexedMap (\i _ -> "__c" ++ String.fromInt i) argsC

                        captureDecls =
                            List.map2 (\c a -> "tcelm_value_t *" ++ c ++ " = " ++ a ++ ";") capturedVars argsC

                        applyArgs =
                            capturedVars ++ List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (remaining - 1))

                        callArgs =
                            if needsArena then
                                "__a, " ++ String.join ", " applyArgs
                            else
                                String.join ", " applyArgs
                    in
                    "({\n"
                        ++ String.join "\n" (List.map (\d -> "                " ++ d) captureDecls)
                        ++ "\n                auto tcelm_value_t *__partial_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                        ++ "                    (void)__a;\n"
                        ++ "                    return "
                        ++ fnName
                        ++ "("
                        ++ callArgs
                        ++ ");\n"
                        ++ "                }\n"
                        ++ "                tcelm_closure(arena, __partial_impl, "
                        ++ String.fromInt remaining
                        ++ ");\n"
                        ++ "            })"

            Nothing ->
                fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"

    else
        -- Closure application
        -- For unqualified function names (LowVar), we might need to call the closure getter
        let
            -- Generate the function expression
            -- For Var LowVar:
            --   - If it's a local variable (from pattern binding), use mangleLocal
            --     which gives _lv_name - already a closure
            --   - If it's a top-level function, use mangle which gives elm_name,
            --     then call it to get the closure: elm_name(arena)
            -- The challenge is: we don't track which names are local vs top-level.
            -- Solution: generateExpr for Var uses mangle (top-level style),
            -- but pattern bindings use mangleLocal. So we check if the generated
            -- name starts with _lv_ to know it's a local var.
            fnExpr =
                case fn of
                    Src.At _ (Var Src.LowVar fnNameVar) ->
                        -- Check if this matches a local variable pattern
                        -- Since we can't know at this point, we generate the
                        -- top-level call style. But we need a way to reference
                        -- local variables...
                        -- For now: assume all LowVar in call position are functions
                        -- Local variables should be referenced with their _lv_ prefix
                        -- which is generated by pattern bindings.
                        mangle fnNameVar ++ "(arena)"

                    _ ->
                        generateExpr fn
        in
        case List.length args of
            0 ->
                fnExpr

            1 ->
                "tcelm_apply(arena, " ++ fnExpr ++ ", " ++ String.join "" argsC ++ ")"

            n ->
                "tcelm_apply_n(arena, "
                    ++ fnExpr
                    ++ ", "
                    ++ String.fromInt n
                    ++ ", "
                    ++ String.join ", " argsC
                    ++ ")"


{-| Generate an if expression with multiple branches (if/else if/else)
-}
generateIf : List ( Expr, Expr ) -> Expr -> String
generateIf branches elseExpr =
    case branches of
        [] ->
            generateExpr elseExpr

        [ ( cond, then_ ) ] ->
            "(TCELM_AS_BOOL("
                ++ generateExpr cond
                ++ ") ? "
                ++ generateExpr then_
                ++ " : "
                ++ generateExpr elseExpr
                ++ ")"

        ( cond, then_ ) :: rest ->
            "(TCELM_AS_BOOL("
                ++ generateExpr cond
                ++ ") ? "
                ++ generateExpr then_
                ++ " : "
                ++ generateIf rest elseExpr
                ++ ")"


{-| Generate a let expression
-}
generateLet : List (Src.Located Src.Def) -> Expr -> String
generateLet defs body =
    -- Generate as a compound statement expression (GCC extension)
    -- Or inline the definitions
    let
        defStrs =
            List.map generateLocatedDef defs

        bodyStr =
            generateExpr body
    in
    "({\n"
        ++ String.join "\n" (List.map (\d -> "        " ++ d) defStrs)
        ++ "\n        "
        ++ bodyStr
        ++ ";\n    })"


{-| Generate a located definition (in a let binding)
-}
generateLocatedDef : Src.Located Src.Def -> String
generateLocatedDef (Src.At _ def) =
    case def of
        Src.Define (Src.At _ name) args body _ ->
            if List.isEmpty args then
                "tcelm_value_t *" ++ mangle name ++ " = " ++ generateExpr body ++ ";"

            else
                "/* local function " ++ name ++ " */"

        Src.Destruct pattern body ->
            -- Destructuring let binding: let (Pattern x) = expr in ...
            let
                destExpr = generateExpr body
                bindings = generatePatternBindings "__destruct" pattern
            in
            "tcelm_value_t *__destruct = " ++ destExpr ++ ";\n        "
                ++ String.join "\n        " bindings


{-| Generate a case expression
-}
generateCase : Expr -> List ( Pattern, Expr ) -> String
generateCase subject branches =
    let
        subjectVar =
            "__case_subject"

        branchStrs =
            List.indexedMap (generateBranch subjectVar) branches
    in
    "({\n"
        ++ "        tcelm_value_t *"
        ++ subjectVar
        ++ " = "
        ++ generateExpr subject
        ++ ";\n"
        ++ String.join "\n" branchStrs
        ++ "\n        TCELM_UNIT; /* unreachable */\n    })"


{-| Generate a case branch
-}
generateBranch : String -> Int -> ( Pattern, Expr ) -> String
generateBranch subjectVar index ( pattern, body ) =
    let
        condition =
            generatePatternMatch subjectVar pattern

        bindings =
            generatePatternBindings subjectVar pattern

        bodyStr =
            generateExpr body
    in
    "        if ("
        ++ condition
        ++ ") {\n"
        ++ String.join "\n" (List.map (\b -> "            " ++ b) bindings)
        ++ (if List.isEmpty bindings then
                ""

            else
                "\n"
           )
        ++ "            "
        ++ bodyStr
        ++ ";\n        }"


{-| Generate a pattern match condition
-}
generatePatternMatch : String -> Pattern -> String
generatePatternMatch subject (Src.At _ pattern) =
    case pattern of
        PAnything ->
            "1"

        PVar _ ->
            "1"

        PInt n ->
            "TCELM_AS_INT(" ++ subject ++ ") == " ++ String.fromInt n

        PStr s ->
            "strcmp(TCELM_AS_STRING(" ++ subject ++ ")->data, \"" ++ escapeC s ++ "\") == 0"

        PChr c ->
            case String.uncons c of
                Just ( ch, _ ) ->
                    "TCELM_AS_CHAR(" ++ subject ++ ") == " ++ String.fromInt (Char.toCode ch)

                Nothing ->
                    "0"

        PCtor _ name args ->
            let
                shortName = extractCtorName name
            in
            "tcelm_custom_ctor(" ++ subject ++ ") == TCELM_CTOR_" ++ String.toUpper shortName

        PCtorQual _ _ name args ->
            "tcelm_custom_ctor(" ++ subject ++ ") == TCELM_CTOR_" ++ String.toUpper name

        PList patterns ->
            case patterns of
                [] ->
                    "tcelm_is_nil(" ++ subject ++ ")"

                [ _ ] ->
                    -- Single element list: not nil and tail is nil
                    "(!tcelm_is_nil(" ++ subject ++ ") && tcelm_is_nil(tcelm_list_tail(" ++ subject ++ ")))"

                [ _, _ ] ->
                    -- Two element list
                    "(!tcelm_is_nil(" ++ subject ++ ") && !tcelm_is_nil(tcelm_list_tail(" ++ subject ++ ")) && tcelm_is_nil(tcelm_list_tail(tcelm_list_tail(" ++ subject ++ "))))"

                [ _, _, _ ] ->
                    -- Three element list
                    "(!tcelm_is_nil(" ++ subject ++ ") && !tcelm_is_nil(tcelm_list_tail(" ++ subject ++ ")) && !tcelm_is_nil(tcelm_list_tail(tcelm_list_tail(" ++ subject ++ "))) && tcelm_is_nil(tcelm_list_tail(tcelm_list_tail(tcelm_list_tail(" ++ subject ++ ")))))"

                _ ->
                    -- For longer lists, use length check
                    "(tcelm_list_length_fn(arena, " ++ subject ++ ")->data.i == " ++ String.fromInt (List.length patterns) ++ ")"

        PCons head tail ->
            "!tcelm_is_nil(" ++ subject ++ ")"

        PUnit ->
            "1"

        PAlias innerPattern _ ->
            generatePatternMatch subject innerPattern

        PRecord _ ->
            "1"

        PTuple _ _ _ ->
            "1"


{-| Generate pattern bindings
-}
generatePatternBindings : String -> Pattern -> List String
generatePatternBindings subject (Src.At _ pattern) =
    case pattern of
        PVar name ->
            [ "tcelm_value_t *" ++ mangle name ++ " = " ++ subject ++ ";" ]

        PCons head tail ->
            let
                headBindings =
                    generatePatternBindings ("tcelm_list_head(" ++ subject ++ ")") head

                tailBindings =
                    generatePatternBindings ("tcelm_list_tail(" ++ subject ++ ")") tail
            in
            headBindings ++ tailBindings

        PCtor _ _ args ->
            List.indexedMap
                (\i arg ->
                    generatePatternBindings
                        ("tcelm_custom_arg(" ++ subject ++ ", " ++ String.fromInt i ++ ")")
                        arg
                )
                args
                |> List.concat

        PCtorQual _ _ _ args ->
            List.indexedMap
                (\i arg ->
                    generatePatternBindings
                        ("tcelm_custom_arg(" ++ subject ++ ", " ++ String.fromInt i ++ ")")
                        arg
                )
                args
                |> List.concat

        PAlias innerPattern (Src.At _ aliasName) ->
            [ "tcelm_value_t *" ++ mangle aliasName ++ " = " ++ subject ++ ";" ]
                ++ generatePatternBindings subject innerPattern

        PRecord fields ->
            List.map
                (\(Src.At _ fieldName) ->
                    "tcelm_value_t *"
                        ++ mangle fieldName
                        ++ " = tcelm_record_get("
                        ++ subject
                        ++ ", \""
                        ++ fieldName
                        ++ "\");"
                )
                fields

        PTuple p1 p2 rest ->
            let
                suffix =
                    sanitizeForCIdent subject

                t1Name =
                    "__tuple_1_" ++ suffix

                t2Name =
                    "__tuple_2_" ++ suffix

                t3Name =
                    "__tuple_3_" ++ suffix
            in
            case rest of
                [] ->
                    -- 2-tuple
                    [ "tcelm_value_t *" ++ t1Name ++ " = tcelm_tuple2_first(" ++ subject ++ ");"
                    , "tcelm_value_t *" ++ t2Name ++ " = tcelm_tuple2_second(" ++ subject ++ ");"
                    ]
                        ++ generatePatternBindings t1Name p1
                        ++ generatePatternBindings t2Name p2

                [ p3 ] ->
                    -- 3-tuple
                    [ "tcelm_value_t *" ++ t1Name ++ " = tcelm_tuple3_first(" ++ subject ++ ");"
                    , "tcelm_value_t *" ++ t2Name ++ " = tcelm_tuple3_second(" ++ subject ++ ");"
                    , "tcelm_value_t *" ++ t3Name ++ " = tcelm_tuple3_third(" ++ subject ++ ");"
                    ]
                        ++ generatePatternBindings t1Name p1
                        ++ generatePatternBindings t2Name p2
                        ++ generatePatternBindings t3Name p3

                _ ->
                    [ "/* tuple with more than 3 elements not supported */" ]

        PList patterns ->
            -- Generate bindings for list element patterns
            -- For [a, b, c]: a = head(s), b = head(tail(s)), c = head(tail(tail(s)))
            List.indexedMap
                (\i pat ->
                    let
                        -- Build nested tail calls: tail(tail(tail(subject)))...
                        nestedTails =
                            if i == 0 then
                                subject
                            else
                                List.repeat i "tcelm_list_tail("
                                    |> String.concat
                                    |> (\prefix -> prefix ++ subject ++ String.repeat i ")")

                        accessor =
                            "tcelm_list_head(" ++ nestedTails ++ ")"
                    in
                    generatePatternBindings accessor pat
                )
                patterns
                |> List.concat

        _ ->
            []


{-| Generate a record literal
-}
generateRecord : List ( Src.Located String, Expr ) -> String
generateRecord fields =
    let
        fieldCount =
            List.length fields

        fieldStrs =
            List.map
                (\( Src.At _ name, value ) ->
                    "\"" ++ name ++ "\", " ++ generateExpr value
                )
                fields
    in
    "tcelm_record(arena, "
        ++ String.fromInt fieldCount
        ++ ", "
        ++ String.join ", " fieldStrs
        ++ ")"


{-| Generate a record update
-}
generateRecordUpdate : String -> List ( Src.Located String, Expr ) -> String
generateRecordUpdate recordName fields =
    case fields of
        [] ->
            mangle recordName

        ( Src.At _ fieldName, value ) :: rest ->
            "tcelm_record_update(arena, "
                ++ generateRecordUpdate recordName rest
                ++ ", \""
                ++ fieldName
                ++ "\", "
                ++ generateExpr value
                ++ ")"


{-| Generate a union type definition
-}
generateUnion : Src.Located Src.Union -> String
generateUnion (Src.At _ union) =
    let
        (Src.At _ name) =
            union.name

        ctorDefs =
            List.indexedMap
                (\i ( Src.At _ ctorName, _ ) ->
                    "#define TCELM_CTOR_" ++ String.toUpper ctorName ++ " " ++ String.fromInt i
                )
                union.ctors
    in
    "/* type " ++ name ++ " */\n" ++ String.join "\n" ctorDefs


{-| Generate a type alias definition

For record type aliases, we also generate a constructor define
so that record constructor calls like `Region start end` work.
-}
generateAlias : Src.Located Src.Alias -> String
generateAlias (Src.At _ alias_) =
    let
        (Src.At _ name) =
            alias_.name

        isRecordAlias =
            case alias_.type_ of
                Src.At _ (Src.TRecord _ _) ->
                    True

                _ ->
                    False
    in
    if isRecordAlias then
        "/* type alias " ++ name ++ " */\n"
            ++ "#define TCELM_CTOR_" ++ String.toUpper name ++ " 0"
    else
        "/* type alias " ++ name ++ " */"


{-| Generate a stub for an Elm port.
    Outgoing ports (Value -> Cmd msg) return Cmd.none
    Incoming ports ((a -> msg) -> Sub msg) return Sub.none
-}
generatePortStub : String -> Src.Port -> String
generatePortStub modulePrefix port_ =
    let
        (Src.At _ name) =
            port_.name

        funcName =
            "elm_" ++ modulePrefix ++ "_" ++ name

        -- Determine port arity from type
        -- Outgoing: Value -> Cmd msg (arity 1)
        -- Incoming: (a -> msg) -> Sub msg (arity 1)
        arity =
            1

        -- Generate forward declaration
        forwardDecl =
            "#define " ++ funcName ++ "_ARITY " ++ String.fromInt arity ++ "\n"
                ++ "tcelm_value_t *" ++ funcName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args);"

        -- Generate implementation that returns Cmd.none or Sub.none
        -- We check if the type contains "Sub" to determine if it's an incoming port
        isIncomingPort =
            String.contains "Sub" (typeToString port_.type_)

        impl =
            "tcelm_value_t *" ++ funcName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args) {\n"
                ++ "    (void)arena; (void)args;\n"
                ++ "    return "
                ++ (if isIncomingPort then "elm_Sub_none" else "elm_Cmd_none")
                ++ ";\n"
                ++ "}"
    in
    "/* port " ++ name ++ " */\n" ++ forwardDecl ++ "\n" ++ impl


{-| Simple type to string for port detection -}
typeToString : Src.Type -> String
typeToString (Src.At _ tipe) =
    case tipe of
        Src.TLambda a b ->
            typeToString a ++ " -> " ++ typeToString b

        Src.TVar name ->
            name

        Src.TType _ name args ->
            name ++ " " ++ String.join " " (List.map typeToString args)

        Src.TTypeQual _ mod name args ->
            mod ++ "." ++ name ++ " " ++ String.join " " (List.map typeToString args)

        Src.TRecord fields _ ->
            "{ " ++ String.join ", " (List.map (\(Src.At _ f, t) -> f ++ ": " ++ typeToString t) fields) ++ " }"

        Src.TUnit ->
            "()"

        Src.TTuple a b rest ->
            let
                allTypes =
                    [ a, b ] ++ rest
            in
            "(" ++ String.join ", " (List.map typeToString allTypes) ++ ")"


{-| Generate a closure that creates a constructor when called.
    For example, makeConstructorClosure "Just" 1 creates a closure that,
    when applied to one argument, creates Just(arg).
-}
makeConstructorClosure : String -> Int -> String
makeConstructorClosure name arity =
    let
        ctorNameUpper =
            String.toUpper name

        argBindings =
            List.range 0 (arity - 1)
                |> List.map (\i -> "args[" ++ String.fromInt i ++ "]")
                |> String.join ", "
    in
    "({\n"
        ++ "            auto tcelm_value_t *__ctor_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
        ++ "                return tcelm_custom(__a, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ name ++ "\", " ++ String.fromInt arity ++ ", " ++ argBindings ++ ");\n"
        ++ "            }\n"
        ++ "            tcelm_closure(arena, __ctor_impl, " ++ String.fromInt arity ++ ");\n"
        ++ "        })"


{-| Map standard library function calls to their C runtime equivalents.
    Some Elm standard library functions map directly to runtime functions.
-}
mapStdLibFunction : String -> String -> String
mapStdLibFunction modulePath name =
    case ( modulePath, name ) of
        -- String module
        ( "String", "slice" ) ->
            "tcelm_string_slice"

        ( "String", "length" ) ->
            "tcelm_string_length"

        ( "String", "append" ) ->
            "tcelm_string_append"

        ( "String", "concat" ) ->
            "tcelm_string_concat"

        ( "String", "fromInt" ) ->
            "tcelm_string_from_int"

        ( "String", "fromFloat" ) ->
            "tcelm_string_from_float"

        ( "String", "toInt" ) ->
            "tcelm_string_to_int"

        ( "String", "toFloat" ) ->
            "tcelm_string_to_float"

        ( "String", "dropLeft" ) ->
            "tcelm_string_dropLeft"

        ( "String", "left" ) ->
            "tcelm_string_left"

        ( "String", "uncons" ) ->
            "tcelm_string_uncons"

        ( "String", "join" ) ->
            "tcelm_string_join"

        ( "String", "replace" ) ->
            "tcelm_string_replace"

        ( "String", "split" ) ->
            "tcelm_string_split"

        ( "String", "toList" ) ->
            "tcelm_string_toList"

        ( "String", "fromList" ) ->
            "tcelm_string_fromList"

        ( "String", "fromChar" ) ->
            "tcelm_string_fromChar"

        ( "String", "toUpper" ) ->
            "tcelm_string_toUpper"

        ( "String", "toLower" ) ->
            "tcelm_string_toLower"

        ( "String", "repeat" ) ->
            "tcelm_string_repeat"

        ( "String", "reverse" ) ->
            "tcelm_string_reverse"

        ( "String", "contains" ) ->
            "tcelm_string_contains"

        ( "String", "isEmpty" ) ->
            "tcelm_string_isEmpty"

        ( "String", "startsWith" ) ->
            "tcelm_string_startsWith"

        ( "String", "endsWith" ) ->
            "tcelm_string_endsWith"

        -- Char module
        ( "Char", "isAlphaNum" ) ->
            "tcelm_char_isAlphaNum"

        ( "Char", "isAlpha" ) ->
            "tcelm_char_isAlpha"

        ( "Char", "isDigit" ) ->
            "tcelm_char_isDigit"

        ( "Char", "isUpper" ) ->
            "tcelm_char_isUpper"

        ( "Char", "isLower" ) ->
            "tcelm_char_isLower"

        ( "Char", "toCode" ) ->
            "tcelm_char_toCode"

        ( "Char", "fromCode" ) ->
            "tcelm_char_fromCode"

        -- List module
        ( "List", "map" ) ->
            "tcelm_list_map"

        ( "List", "foldl" ) ->
            "tcelm_list_foldl"

        ( "List", "foldr" ) ->
            "tcelm_list_foldr"

        ( "List", "filter" ) ->
            "tcelm_list_filter"

        ( "List", "length" ) ->
            "tcelm_list_length"

        ( "List", "reverse" ) ->
            "tcelm_list_reverse"

        ( "List", "head" ) ->
            "tcelm_list_head"

        ( "List", "tail" ) ->
            "tcelm_list_tail"

        ( "List", "concat" ) ->
            "tcelm_list_concat"

        ( "List", "concatMap" ) ->
            "tcelm_list_concatMap"

        ( "List", "map2" ) ->
            "tcelm_list_map2"

        ( "List", "indexedMap" ) ->
            "tcelm_list_indexedMap"

        ( "List", "isEmpty" ) ->
            "tcelm_list_isEmpty"

        ( "List", "member" ) ->
            "tcelm_list_member"

        ( "List", "range" ) ->
            "tcelm_list_range"

        ( "List", "repeat" ) ->
            "tcelm_list_repeat"

        ( "List", "any" ) ->
            "tcelm_list_any"

        ( "List", "all" ) ->
            "tcelm_list_all"

        ( "List", "drop" ) ->
            "tcelm_list_drop"

        ( "List", "take" ) ->
            "tcelm_list_take"

        ( "List", "filterMap" ) ->
            "tcelm_list_filterMap"

        ( "List", "partition" ) ->
            "tcelm_list_partition"

        ( "List", "sort" ) ->
            "tcelm_list_sort"

        ( "List", "sortBy" ) ->
            "tcelm_list_sortBy"

        ( "List", "sortWith" ) ->
            "tcelm_list_sortWith"

        ( "List", "last" ) ->
            "tcelm_list_last"

        ( "List", "sum" ) ->
            "tcelm_list_sum"

        ( "List", "product" ) ->
            "tcelm_list_product"

        ( "List", "maximum" ) ->
            "tcelm_list_maximum"

        ( "List", "minimum" ) ->
            "tcelm_list_minimum"

        ( "List", "singleton" ) ->
            "tcelm_list_singleton"

        ( "List", "intersperse" ) ->
            "tcelm_list_intersperse"

        ( "List", "unzip" ) ->
            "tcelm_list_unzip"

        ( "List", "append" ) ->
            "tcelm_list_append"

        -- Maybe module
        ( "Maybe", "map" ) ->
            "tcelm_maybe_map"

        ( "Maybe", "withDefault" ) ->
            "tcelm_maybe_withDefault"

        -- Tuple module
        ( "Tuple", "first" ) ->
            "tcelm_tuple2_first"

        ( "Tuple", "second" ) ->
            "tcelm_tuple2_second"

        -- Basics module
        ( "Basics", "identity" ) ->
            "tcelm_identity"

        ( "Basics", "toFloat" ) ->
            "tcelm_to_float"

        ( "Basics", "min" ) ->
            "tcelm_min"

        ( "Basics", "max" ) ->
            "tcelm_max"

        -- Platform module
        ( "Platform", "worker" ) ->
            "elm_Platform_worker"

        -- Default: mangle as elm_Module_name
        _ ->
            mangle (modulePath ++ "_" ++ name)


{-| Get the arity of a stdlib function (number of arguments excluding arena)
    Returns Nothing for unknown functions.
-}
getStdLibArity : String -> String -> Maybe Int
getStdLibArity modulePath name =
    case ( modulePath, name ) of
        ( "Maybe", "map" ) ->
            Just 2

        ( "Maybe", "withDefault" ) ->
            Just 2

        ( "Maybe", "andThen" ) ->
            Just 2

        ( "Tuple", "first" ) ->
            Just 1

        ( "Tuple", "second" ) ->
            Just 1

        ( "String", "slice" ) ->
            Just 3

        ( "String", "dropLeft" ) ->
            Just 2

        ( "String", "length" ) ->
            Just 1

        ( "String", "uncons" ) ->
            Just 1

        ( "String", "join" ) ->
            Just 2

        ( "String", "replace" ) ->
            Just 3

        ( "String", "split" ) ->
            Just 2

        ( "String", "toList" ) ->
            Just 1

        ( "String", "fromList" ) ->
            Just 1

        ( "String", "fromChar" ) ->
            Just 1

        ( "String", "append" ) ->
            Just 2

        ( "String", "concat" ) ->
            Just 1

        ( "String", "fromInt" ) ->
            Just 1

        ( "String", "fromFloat" ) ->
            Just 1

        ( "String", "toUpper" ) ->
            Just 1

        ( "String", "toLower" ) ->
            Just 1

        ( "String", "repeat" ) ->
            Just 2

        ( "String", "reverse" ) ->
            Just 1

        ( "String", "contains" ) ->
            Just 2

        ( "String", "isEmpty" ) ->
            Just 1

        ( "String", "startsWith" ) ->
            Just 2

        ( "String", "endsWith" ) ->
            Just 2

        ( "Char", "toCode" ) ->
            Just 1

        ( "Char", "fromCode" ) ->
            Just 1

        ( "List", "map" ) ->
            Just 2

        ( "List", "foldl" ) ->
            Just 3

        ( "List", "foldr" ) ->
            Just 3

        ( "List", "filter" ) ->
            Just 2

        ( "List", "head" ) ->
            Just 1

        ( "List", "tail" ) ->
            Just 1

        ( "List", "length" ) ->
            Just 1

        ( "List", "reverse" ) ->
            Just 1

        ( "List", "concat" ) ->
            Just 1

        ( "List", "concatMap" ) ->
            Just 2

        ( "List", "map2" ) ->
            Just 3

        ( "List", "indexedMap" ) ->
            Just 2

        ( "List", "isEmpty" ) ->
            Just 1

        ( "List", "member" ) ->
            Just 2

        ( "List", "range" ) ->
            Just 2

        ( "List", "repeat" ) ->
            Just 2

        ( "List", "any" ) ->
            Just 2

        ( "List", "all" ) ->
            Just 2

        ( "List", "drop" ) ->
            Just 2

        ( "List", "take" ) ->
            Just 2

        ( "List", "filterMap" ) ->
            Just 2

        ( "List", "partition" ) ->
            Just 2

        ( "List", "sort" ) ->
            Just 1

        ( "List", "sortBy" ) ->
            Just 2

        ( "List", "sortWith" ) ->
            Just 2

        ( "List", "last" ) ->
            Just 1

        ( "List", "sum" ) ->
            Just 1

        ( "List", "product" ) ->
            Just 1

        ( "List", "maximum" ) ->
            Just 1

        ( "List", "minimum" ) ->
            Just 1

        ( "List", "singleton" ) ->
            Just 1

        ( "List", "intersperse" ) ->
            Just 2

        ( "List", "unzip" ) ->
            Just 1

        ( "List", "append" ) ->
            Just 2

        ( "Basics", "identity" ) ->
            Just 1

        ( "Basics", "toFloat" ) ->
            Just 1

        ( "Basics", "min" ) ->
            Just 2

        ( "Basics", "max" ) ->
            Just 2

        -- Platform module
        ( "Platform", "worker" ) ->
            Just 1

        _ ->
            Nothing


{-| Check if a stdlib function takes arena as first argument.
    Most do, but some pure functions like tuple accessors don't.
-}
stdLibNeedsArena : String -> String -> Bool
stdLibNeedsArena modulePath name =
    case ( modulePath, name ) of
        ( "Tuple", "first" ) ->
            False

        ( "Tuple", "second" ) ->
            False

        ( "List", "head" ) ->
            False

        ( "List", "tail" ) ->
            False

        _ ->
            True





-- ============================================================================
-- RTEMS CODE GENERATION
-- ============================================================================


{-| Generate C code for an RTEMS module.

This generates:
- The standard module code
- A tcelm_task_def_t struct for the main function
- Shell registration code

-}
generateRtemsModule : Module -> String
generateRtemsModule mod =
    let
        moduleName =
            getModuleName mod

        baseCode =
            generateModule mod

        rtemsIncludes =
            [ ""
            , "/* RTEMS Integration */"
            , "#include \"tcelm_rtems.h\""
            , "#include \"tcelm_shell.h\""
            , ""
            ]

        -- Generate init function wrapper
        initWrapper =
            [ "/* Init function wrapper */"
            , "static tcelm_value_t *" ++ mangle moduleName ++ "_init_wrapper(tcelm_arena_t *arena) {"
            , "    return elm_init(arena);"
            , "}"
            , ""
            ]

        -- Generate update function wrapper
        updateWrapper =
            [ "/* Update function wrapper */"
            , "static tcelm_value_t *" ++ mangle moduleName ++ "_update_wrapper("
            , "        tcelm_arena_t *arena,"
            , "        tcelm_value_t *msg,"
            , "        tcelm_value_t *model) {"
            , "    return tcelm_apply_n(arena, elm_update(arena), 2, msg, model);"
            , "}"
            , ""
            ]

        -- Generate subscriptions function wrapper
        subscriptionsWrapper =
            [ "/* Subscriptions function wrapper */"
            , "static tcelm_value_t *" ++ mangle moduleName ++ "_subscriptions_wrapper("
            , "        tcelm_arena_t *arena,"
            , "        tcelm_value_t *model) {"
            , "    return tcelm_apply(arena, elm_subscriptions(arena), model);"
            , "}"
            , ""
            ]

        -- Generate task definition
        taskDef =
            [ "/* Task definition for RTEMS */"
            , "static const tcelm_task_def_t " ++ mangle moduleName ++ "_task_def = {"
            , "    .name = \"" ++ moduleName ++ "\","
            , "    .init = " ++ mangle moduleName ++ "_init_wrapper,"
            , "    .update = " ++ mangle moduleName ++ "_update_wrapper,"
            , "    .subscriptions = " ++ mangle moduleName ++ "_subscriptions_wrapper,"
            , "    .view = NULL,"
            , "    .priority = 0,  /* Use default */"
            , "    .stack_size = 0  /* Use default */"
            , "};"
            , ""
            ]

        -- Generate registration function
        registerFunc =
            [ "/* Register this module with tcelm shell */"
            , "void " ++ mangle moduleName ++ "_register(void) {"
            , "    tcelm_shell_register_module(\"" ++ moduleName ++ "\", &" ++ mangle moduleName ++ "_task_def);"
            , "}"
            , ""
            ]

        -- Generate auto-registration using constructor (GCC extension)
        autoRegister =
            [ "/* Auto-register on load (GCC extension) */"
            , "#ifdef __GNUC__"
            , "static void __attribute__((constructor)) " ++ mangle moduleName ++ "_auto_register(void) {"
            , "    " ++ mangle moduleName ++ "_register();"
            , "}"
            , "#endif"
            , ""
            ]

        -- Generate main entry point if this is the main module
        mainEntry =
            if moduleName == "Main" then
                [ "/* Main entry point for standalone RTEMS application */"
                , "#ifdef TCELM_STANDALONE"
                , "rtems_task Init(rtems_task_argument arg) {"
                , "    (void)arg;"
                , ""
                , "    /* Initialize tcelm runtime */"
                , "    tcelm_rtems_init(NULL);"
                , ""
                , "    /* Initialize shell commands */"
                , "    tcelm_shell_init();"
                , ""
                , "    /* Spawn main task */"
                , "    tcelm_task_t *main_task = tcelm_task_spawn(&" ++ mangle moduleName ++ "_task_def);"
                , "    if (!main_task) {"
                , "        printf(\"Failed to spawn main task\\n\");"
                , "        rtems_task_delete(RTEMS_SELF);"
                , "    }"
                , ""
                , "    /* Start RTEMS shell (optional) */"
                , "#ifdef TCELM_SHELL"
                , "    rtems_shell_init("
                , "        \"SHLL\","
                , "        32 * 1024,"
                , "        100,"
                , "        \"/dev/console\","
                , "        false,"
                , "        true,"
                , "        NULL"
                , "    );"
                , "#endif"
                , ""
                , "    /* Delete init task - application runs via spawned tasks */"
                , "    rtems_task_delete(RTEMS_SELF);"
                , "}"
                , "#endif /* TCELM_STANDALONE */"
                , ""
                ]

            else
                []
    in
    baseCode
        ++ "\n"
        ++ String.join "\n" rtemsIncludes
        ++ String.join "\n" initWrapper
        ++ String.join "\n" updateWrapper
        ++ String.join "\n" subscriptionsWrapper
        ++ String.join "\n" taskDef
        ++ String.join "\n" registerFunc
        ++ String.join "\n" autoRegister
        ++ String.join "\n" mainEntry


{-| Generate a native Platform.worker for file I/O based compilation.

This generates code that uses tcelm_worker_run instead of RTEMS tasks,
enabling self-hosting with TCC or GCC on native platforms.

The generated worker:
- Reads input from a file (passed via flags.source)
- Processes it through init/update
- Outputs result via worker commands
-}
generateNativeWorkerModule : Module -> String
generateNativeWorkerModule mod =
    let
        moduleName =
            getModuleName mod

        baseCode =
            generateModule mod

        workerIncludes =
            [ ""
            , "/* Native Worker Integration */"
            , "#include \"tcelm_worker.h\""
            , "#include \"tcelm_platform.h\""
            , ""
            ]

        -- Module prefix for function names
        modulePrefix =
            "elm_" ++ String.replace "." "_" moduleName

        -- Generate init function wrapper
        initWrapper =
            [ "/* Init function wrapper for native worker */"
            , "static tcelm_value_t *" ++ mangle moduleName ++ "_worker_init("
            , "        tcelm_arena_t *arena,"
            , "        tcelm_value_t *flags) {"
            , "    /* Extract source from flags record */"
            , "    tcelm_value_t *source = tcelm_record_get(flags, \"source\");"
            , "    (void)source;  /* Available for use in init */"
            , "    return " ++ modulePrefix ++ "_init(arena, TCELM_UNIT);"
            , "}"
            , ""
            ]

        -- Generate update function wrapper
        updateWrapper =
            [ "/* Update function wrapper for native worker */"
            , "static tcelm_value_t *" ++ mangle moduleName ++ "_worker_update("
            , "        tcelm_arena_t *arena,"
            , "        tcelm_value_t *msg,"
            , "        tcelm_value_t *model) {"
            , "    return " ++ modulePrefix ++ "_update(arena, msg, model);"
            , "}"
            , ""
            ]

        -- Generate worker program definition
        workerDef =
            [ "/* Worker program definition */"
            , "static const tcelm_worker_program_t " ++ mangle moduleName ++ "_worker_program = {"
            , "    .name = \"" ++ moduleName ++ "\","
            , "    .init = " ++ mangle moduleName ++ "_worker_init,"
            , "    .update = " ++ mangle moduleName ++ "_worker_update,"
            , "    .subscriptions = NULL"
            , "};"
            , ""
            ]

        -- Generate main entry point
        mainEntry =
            [ "/* Main entry point for native worker */"
            , "#ifndef TCELM_NO_MAIN"
            , "int main(int argc, char **argv) {"
            , "    return tcelm_worker_run(&" ++ mangle moduleName ++ "_worker_program, NULL, argc, argv);"
            , "}"
            , "#endif"
            , ""
            ]
    in
    baseCode
        ++ "\n"
        ++ String.join "\n" workerIncludes
        ++ String.join "\n" initWrapper
        ++ String.join "\n" updateWrapper
        ++ String.join "\n" workerDef
        ++ String.join "\n" mainEntry


{-| Generate RTEMS kernel function calls
-}
generateRtemsKernelCall : String -> List Expr -> String
generateRtemsKernelCall funcName args =
    case funcName of
        "Rtems.now" ->
            "tcelm_rtems_time_ms(arena)"

        "Rtems.ticks" ->
            "tcelm_rtems_tick_get(arena)"

        "Rtems.ticksPerSecond" ->
            "tcelm_rtems_ticks_per_second(arena)"

        "Rtems.every" ->
            case args of
                [ interval, toMsg ] ->
                    "tcelm_sub_every_ms(arena, "
                        ++ generateExpr interval
                        ++ ", "
                        ++ generateExpr toMsg
                        ++ ")"

                _ ->
                    "/* invalid Rtems.every call */"

        "Rtems.everyTick" ->
            case args of
                [ interval, toMsg ] ->
                    "tcelm_sub_every_ticks(arena, "
                        ++ generateExpr interval
                        ++ ", "
                        ++ generateExpr toMsg
                        ++ ")"

                _ ->
                    "/* invalid Rtems.everyTick call */"

        "Rtems.delay" ->
            case args of
                [ delayMs, msg ] ->
                    "tcelm_sub_delay_ms(arena, "
                        ++ generateExpr delayMs
                        ++ ", "
                        ++ generateExpr msg
                        ++ ")"

                _ ->
                    "/* invalid Rtems.delay call */"

        "Rtems.Gpio.read" ->
            case args of
                [ pin ] ->
                    "tcelm_gpio_read(arena, " ++ generateExpr pin ++ ")"

                _ ->
                    "/* invalid Rtems.Gpio.read call */"

        "Rtems.Gpio.write" ->
            case args of
                [ pin, value ] ->
                    "tcelm_gpio_write(arena, "
                        ++ generateExpr pin
                        ++ ", "
                        ++ generateExpr value
                        ++ ")"

                _ ->
                    "/* invalid Rtems.Gpio.write call */"

        "Rtems.Uart.write" ->
            case args of
                [ port_, data ] ->
                    "tcelm_uart_write(arena, "
                        ++ generateExpr port_
                        ++ ", "
                        ++ generateExpr data
                        ++ ")"

                _ ->
                    "/* invalid Rtems.Uart.write call */"

        "Rtems.Uart.print" ->
            case args of
                [ data ] ->
                    "tcelm_uart_write(arena, tcelm_int(arena, 0), " ++ generateExpr data ++ ")"

                _ ->
                    "/* invalid Rtems.Uart.print call */"

        "Cmd.none" ->
            "tcelm_cmd_none(arena)"

        "Cmd.batch" ->
            case args of
                [ cmds ] ->
                    "tcelm_cmd_batch(arena, " ++ generateExpr cmds ++ ")"

                _ ->
                    "/* invalid Cmd.batch call */"

        "Sub.none" ->
            "tcelm_sub_none(arena)"

        "Sub.batch" ->
            case args of
                [ subs ] ->
                    "tcelm_sub_batch(arena, " ++ generateExpr subs ++ ")"

                _ ->
                    "/* invalid Sub.batch call */"

        _ ->
            "/* unknown kernel call: " ++ funcName ++ " */"
