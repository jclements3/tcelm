module Generate.C exposing (generate, generateModule, generateNativeWorkerModule, generateRtemsModule)

{-| C Code Generator for tcelm

Transforms Elm AST into C code using the tcelm runtime with arena allocation.

For RTEMS targets, generates task definitions and shell registration.

-}

import AST.Source as Src exposing (Expr, Expr_(..), Module, Pattern, Pattern_(..), Type, Value)


{-| Generate C code for an entire module
-}
generateModule : Module -> String
generateModule mod =
    let
        moduleName =
            mod.name
                |> Maybe.map (\(Src.At _ n) -> n)
                |> Maybe.withDefault "Main"

        -- Convert module name to C prefix (e.g., "AST.Source" -> "AST_Source")
        modulePrefix =
            String.replace "." "_" moduleName

        includes =
            [ "#include <stdio.h>"
            , "#include <string.h>"
            , "#include \"tcelm_arena.h\""
            , "#include \"tcelm_types.h\""
            , "#include \"tcelm_basics.h\""
            , ""
            ]

        header =
            [ "/*"
            , " * Generated by tcelm from " ++ moduleName
            , " * DO NOT EDIT - This file is auto-generated"
            , " */"
            , ""
            ]

        -- Generate forward declarations with module prefix
        forwardDecls =
            List.map (generateForwardDeclWithPrefix modulePrefix) mod.values

        -- Generate function implementations with module prefix
        valueDefs =
            List.map (generateValueWithPrefix modulePrefix) mod.values

        -- Generate type definitions for custom types
        typeDefs =
            List.map generateUnion mod.unions
                ++ List.map generateAlias mod.aliases
    in
    String.join "\n"
        (header
            ++ includes
            ++ [ "/* Type definitions */" ]
            ++ typeDefs
            ++ [ "", "/* Forward declarations */" ]
            ++ forwardDecls
            ++ [ "", "/* Function implementations */" ]
            ++ valueDefs
        )


{-| Generate C code for a single expression (for testing)
-}
generate : Expr -> String
generate expr =
    generateExpr expr


{-| Generate forward declaration for a value

Includes the _impl function declaration and the _ARITY define.
-}
generateForwardDecl : Src.Located Value -> String
generateForwardDecl (Src.At _ value) =
    let
        (Src.At _ name) =
            value.name

        mangledName =
            mangle name

        arity =
            List.length value.args
    in
    "#define " ++ mangledName ++ "_ARITY " ++ String.fromInt arity ++ "\n"
        ++ "static tcelm_value_t *" ++ mangledName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args);"


{-| Generate forward declaration for a value with module prefix

The function name will be elm_Module_Name_functionName for cross-module linking.
Generates declarations for both _impl and direct-call versions.
-}
generateForwardDeclWithPrefix : String -> Src.Located Value -> String
generateForwardDeclWithPrefix modulePrefix (Src.At _ value) =
    let
        (Src.At _ name) =
            value.name

        -- Full name: elm_Module_Name_functionName
        fullName =
            "elm_" ++ modulePrefix ++ "_" ++ name

        arity =
            List.length value.args

        -- Parameter list for direct-call wrapper
        paramList =
            if arity == 0 then
                ""
            else
                ", " ++ (List.indexedMap (\i _ -> "tcelm_value_t *") value.args |> String.join ", ")
    in
    "#define " ++ fullName ++ "_ARITY " ++ String.fromInt arity ++ "\n"
        ++ "tcelm_value_t *" ++ fullName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args);\n"
        ++ "tcelm_value_t *" ++ fullName ++ "(tcelm_arena_t *arena" ++ paramList ++ ");"


{-| Generate a value definition

Generates just the implementation function. Closures are created inline when needed.
Also stores arity info in a #define for reference creation.
-}
generateValue : Src.Located Value -> String
generateValue (Src.At _ value) =
    let
        (Src.At _ name) =
            value.name

        args =
            value.args

        arity =
            List.length args

        mangledName =
            mangle name

        -- Collect local variable names from patterns
        localVars =
            collectPatternVars args

        -- Generate pattern bindings for arguments
        bindings =
            List.map2 generateArgBinding args (List.indexedMap (\i _ -> "arg" ++ String.fromInt i) args)
                |> List.concat

        body =
            generateExprWithLocals localVars value.body

        -- Implementation function (takes args array for closure compatibility)
        implFunc =
            String.join "\n"
                [ ""
                , "static tcelm_value_t *" ++ mangledName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args) {"
                , if arity == 0 then
                    "    (void)args;"
                  else
                    String.join "\n" (List.indexedMap (\i _ -> "    tcelm_value_t *arg" ++ String.fromInt i ++ " = args[" ++ String.fromInt i ++ "];") args)
                , String.join "\n" (List.map (\b -> "    " ++ b) bindings)
                , "    return " ++ body ++ ";"
                , "}"
                ]
    in
    implFunc


{-| Generate a value definition with module prefix for cross-module linking.

The function name will be elm_Module_Name_functionName.
Generates both:
- elm_Module_Name_func_impl(arena, args[]) - for closure-based calls
- elm_Module_Name_func(arena, arg0, arg1, ...) - for direct calls from other modules
-}
generateValueWithPrefix : String -> Src.Located Value -> String
generateValueWithPrefix modulePrefix (Src.At _ value) =
    let
        (Src.At _ name) =
            value.name

        args =
            value.args

        arity =
            List.length args

        -- Full name: elm_Module_Name_functionName
        fullName =
            "elm_" ++ modulePrefix ++ "_" ++ name

        -- Collect local variable names from patterns
        localVars =
            collectPatternVars args

        -- Generate pattern bindings for arguments
        bindings =
            List.map2 generateArgBinding args (List.indexedMap (\i _ -> "arg" ++ String.fromInt i) args)
                |> List.concat

        body =
            generateExprWithLocalsAndPrefix modulePrefix localVars value.body

        -- Implementation function (NOT static - exported for cross-module linking)
        implFunc =
            String.join "\n"
                [ ""
                , "tcelm_value_t *" ++ fullName ++ "_impl(tcelm_arena_t *arena, tcelm_value_t **args) {"
                , if arity == 0 then
                    "    (void)args;"
                  else
                    String.join "\n" (List.indexedMap (\i _ -> "    tcelm_value_t *arg" ++ String.fromInt i ++ " = args[" ++ String.fromInt i ++ "];") args)
                , String.join "\n" (List.map (\b -> "    " ++ b) bindings)
                , "    return " ++ body ++ ";"
                , "}"
                ]

        -- Direct-call wrapper for cross-module calls
        -- elm_Module_func(arena, a0, a1, ...) calls elm_Module_func_impl(arena, {a0, a1, ...})
        directCallWrapper =
            if arity == 0 then
                String.join "\n"
                    [ ""
                    , "tcelm_value_t *" ++ fullName ++ "(tcelm_arena_t *arena) {"
                    , "    return " ++ fullName ++ "_impl(arena, NULL);"
                    , "}"
                    ]
            else
                let
                    paramList =
                        List.indexedMap (\i _ -> "tcelm_value_t *__arg" ++ String.fromInt i) args
                            |> String.join ", "

                    argsArrayInit =
                        List.indexedMap (\i _ -> "__arg" ++ String.fromInt i) args
                            |> String.join ", "
                in
                String.join "\n"
                    [ ""
                    , "tcelm_value_t *" ++ fullName ++ "(tcelm_arena_t *arena, " ++ paramList ++ ") {"
                    , "    tcelm_value_t *__args[] = {" ++ argsArrayInit ++ "};"
                    , "    return " ++ fullName ++ "_impl(arena, __args);"
                    , "}"
                    ]
    in
    implFunc ++ directCallWrapper


{-| Collect variable names bound by a list of patterns
-}
collectPatternVars : List Pattern -> List String
collectPatternVars patterns =
    List.concatMap collectPatternVar patterns


{-| Collect variable names from a single pattern
-}
collectPatternVar : Pattern -> List String
collectPatternVar (Src.At _ pattern) =
    case pattern of
        PVar name ->
            [ name ]

        PRecord fields ->
            List.map (\(Src.At _ n) -> n) fields

        PTuple p1 p2 rest ->
            collectPatternVar p1 ++ collectPatternVar p2 ++ List.concatMap collectPatternVar rest

        PCtor _ _ args ->
            List.concatMap collectPatternVar args

        PCtorQual _ _ _ args ->
            List.concatMap collectPatternVar args

        PAlias inner (Src.At _ aliasName) ->
            aliasName :: collectPatternVar inner

        PCons head tail ->
            collectPatternVar head ++ collectPatternVar tail

        PList patterns ->
            List.concatMap collectPatternVar patterns

        _ ->
            []


{-| Generate expression with knowledge of local variables
-}
generateExprWithLocals : List String -> Expr -> String
generateExprWithLocals locals expr =
    -- For now, delegate to regular generateExpr but track locals
    -- This will be enhanced to use mangleLocal for local vars
    generateExprInContext locals expr


{-| Generate expression with knowledge of local variables and module prefix
-}
generateExprWithLocalsAndPrefix : String -> List String -> Expr -> String
generateExprWithLocalsAndPrefix modulePrefix locals expr =
    generateExprInContextWithPrefix modulePrefix locals expr


{-| Generate expression in context of local variables with module prefix for function names
-}
generateExprInContextWithPrefix : String -> List String -> Expr -> String
generateExprInContextWithPrefix modulePrefix locals (Src.At _ expr) =
    case expr of
        Int n ->
            "tcelm_int(arena, " ++ String.fromInt n ++ ")"

        Float f ->
            "tcelm_float(arena, " ++ String.fromFloat f ++ ")"

        Chr c ->
            case String.uncons c of
                Just ( ch, _ ) ->
                    "tcelm_char(arena, " ++ String.fromInt (Char.toCode ch) ++ ")"

                Nothing ->
                    "tcelm_char(arena, 0)"

        Str s ->
            "tcelm_string(arena, \"" ++ escapeString s ++ "\")"

        Var varType name ->
            case varType of
                Src.LowVar ->
                    if List.member name locals then
                        mangleLocal name
                    else
                        case name of
                            "identity" ->
                                "tcelm_closure(arena, tcelm_identity_impl, 1)"

                            "toFloat" ->
                                "tcelm_closure(arena, tcelm_to_float_impl, 1)"

                            "min" ->
                                "tcelm_closure(arena, tcelm_min_impl, 2)"

                            "max" ->
                                "tcelm_closure(arena, tcelm_max_impl, 2)"

                            _ ->
                                -- Use qualified name for intra-module function references
                                let
                                    qualName = mangleWithPrefix modulePrefix name
                                in
                                "tcelm_closure(arena, " ++ qualName ++ "_impl, " ++ qualName ++ "_ARITY)"

                Src.CapVar ->
                    let
                        shortName = extractCtorName name
                    in
                    case shortName of
                        "True" -> "tcelm_custom(arena, TCELM_CTOR_TRUE, \"True\", 0)"
                        "False" -> "tcelm_custom(arena, TCELM_CTOR_FALSE, \"False\", 0)"
                        "Nothing" -> "tcelm_custom(arena, TCELM_CTOR_NOTHING, \"Nothing\", 0)"
                        "Just" -> makeConstructorClosure "Just" 1
                        "Ok" -> makeConstructorClosure "Ok" 1
                        "Err" -> makeConstructorClosure "Err" 1
                        "LT" -> "tcelm_custom(arena, TCELM_CTOR_LT, \"LT\", 0)"
                        "EQ" -> "tcelm_custom(arena, TCELM_CTOR_EQ, \"EQ\", 0)"
                        "GT" -> "tcelm_custom(arena, TCELM_CTOR_GT, \"GT\", 0)"
                        "Parser" -> makeConstructorClosure "Parser" 1
                        "Good" -> makeConstructorClosure "Good" 3
                        "Bad" -> makeConstructorClosure "Bad" 2
                        "Empty" -> "tcelm_custom(arena, TCELM_CTOR_EMPTY, \"Empty\", 0)"
                        "AddRight" -> makeConstructorClosure "AddRight" 2
                        "Append" -> makeConstructorClosure "Append" 2
                        "At" -> makeConstructorClosure "At" 2
                        _ -> "tcelm_custom(arena, TCELM_CTOR_" ++ String.toUpper shortName ++ ", \"" ++ shortName ++ "\", 0)"

        VarQual varType modulePath name ->
            case varType of
                Src.LowVar ->
                    case getStdLibArity modulePath name of
                        Just arity ->
                            let
                                fnName = mapStdLibFunction modulePath name
                                needsArena = stdLibNeedsArena modulePath name
                                argBindings = List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (arity - 1))
                                callArgs = if needsArena then "__a, " ++ String.join ", " argBindings else String.join ", " argBindings
                            in
                            "({\n"
                                ++ "                auto tcelm_value_t *__fn_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                                ++ "                    (void)__a;\n"
                                ++ "                    return " ++ fnName ++ "(" ++ callArgs ++ ");\n"
                                ++ "                }\n"
                                ++ "                tcelm_closure(arena, __fn_impl, " ++ String.fromInt arity ++ ");\n"
                                ++ "            })"

                        Nothing ->
                            mapStdLibFunction modulePath name

                Src.CapVar ->
                    mapStdLibFunction modulePath name

        List exprs ->
            generateListInContextWithPrefix modulePrefix locals exprs

        Op opName ->
            "/* op " ++ opName ++ " */"

        Negate inner ->
            "tcelm_negate_int(arena, " ++ generateExprInContextWithPrefix modulePrefix locals inner ++ ")"

        Binops pairs finalExpr ->
            generateBinopsInContextWithPrefix modulePrefix locals pairs finalExpr

        Lambda args body ->
            generateLambdaInContextWithPrefix modulePrefix locals args body

        Call fn args ->
            generateCallInContextWithPrefix modulePrefix locals fn args

        If branches elseExpr ->
            generateIfInContextWithPrefix modulePrefix locals branches elseExpr

        Let defs body ->
            generateLetInContextWithPrefix modulePrefix locals defs body

        Case subject branches ->
            generateCaseInContextWithPrefix modulePrefix locals subject branches

        Accessor field ->
            "/* accessor ." ++ field ++ " */"

        Access record (Src.At _ field) ->
            "tcelm_record_get(" ++ generateExprInContextWithPrefix modulePrefix locals record ++ ", \"" ++ field ++ "\")"

        Update (Src.At _ recordName) fields ->
            generateRecordUpdateInContextWithPrefix modulePrefix locals recordName fields

        Record fields ->
            generateRecordInContextWithPrefix modulePrefix locals fields

        Unit ->
            "TCELM_UNIT"

        Tuple a b rest ->
            case rest of
                [] ->
                    "tcelm_tuple2(arena, " ++ generateExprInContextWithPrefix modulePrefix locals a ++ ", " ++ generateExprInContextWithPrefix modulePrefix locals b ++ ")"

                [ c ] ->
                    "tcelm_tuple3(arena, "
                        ++ generateExprInContextWithPrefix modulePrefix locals a ++ ", "
                        ++ generateExprInContextWithPrefix modulePrefix locals b ++ ", "
                        ++ generateExprInContextWithPrefix modulePrefix locals c ++ ")"

                _ ->
                    "/* tuple with more than 3 elements not supported */"


{-| Generate list with prefix
-}
generateListInContextWithPrefix : String -> List String -> List Expr -> String
generateListInContextWithPrefix modulePrefix locals exprs =
    case exprs of
        [] -> "TCELM_NIL"
        x :: xs -> "tcelm_cons(arena, " ++ generateExprInContextWithPrefix modulePrefix locals x ++ ", " ++ generateListInContextWithPrefix modulePrefix locals xs ++ ")"


{-| Generate binops with prefix
-}
generateBinopsInContextWithPrefix : String -> List String -> List ( Expr, Src.Located String ) -> Expr -> String
generateBinopsInContextWithPrefix modulePrefix locals pairs finalExpr =
    case pairs of
        [] -> generateExprInContextWithPrefix modulePrefix locals finalExpr
        ( leftExpr, Src.At _ op ) :: rest ->
            let
                rightExpr = generateBinopsInContextWithPrefix modulePrefix locals rest finalExpr
                l = generateExprInContextWithPrefix modulePrefix locals leftExpr
            in
            generateBinop op l rightExpr


{-| Generate lambda with prefix
-}
generateLambdaInContextWithPrefix : String -> List String -> List Pattern -> Expr -> String
generateLambdaInContextWithPrefix modulePrefix outerLocals args body =
    let
        arity = List.length args
        lambdaLocals = collectPatternVars args
        allLocals = lambdaLocals ++ outerLocals
        paramBindings = List.indexedMap (\i pattern -> generateLambdaArgBindingLocal pattern ("args[" ++ String.fromInt i ++ "]")) args
            |> List.concat |> String.join "\n                "
        bodyCode = generateExprInContextWithPrefix modulePrefix allLocals body
    in
    if arity == 0 then
        "({\n            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                (void)args;\n                tcelm_arena_t *arena = __a;\n"
            ++ "                return " ++ bodyCode ++ ";\n            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, 0);\n        })"
    else
        "({\n            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                tcelm_arena_t *arena = __a;\n                " ++ paramBindings ++ "\n"
            ++ "                return " ++ bodyCode ++ ";\n            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, " ++ String.fromInt arity ++ ");\n        })"


{-| Generate call with prefix
-}
generateCallInContextWithPrefix : String -> List String -> Expr -> List Expr -> String
generateCallInContextWithPrefix modulePrefix locals fn args =
    let
        argsC = List.map (generateExprInContextWithPrefix modulePrefix locals) args
        isConstructorCall = case fn of
            Src.At _ (Var Src.CapVar _) -> True
            Src.At _ (VarQual Src.CapVar _ _) -> True
            _ -> False
        isDirectCall = case fn of
            Src.At _ (VarQual Src.LowVar _ _) -> True
            _ -> False
    in
    if isConstructorCall then
        let
            ( ctorNameUpper, ctorNameOrig ) = case fn of
                Src.At _ (Var Src.CapVar name) -> let shortName = extractCtorName name in ( String.toUpper shortName, shortName )
                Src.At _ (VarQual Src.CapVar _ name) -> ( String.toUpper name, name )
                _ -> ( "UNKNOWN", "Unknown" )
            arity = List.length args
        in
        if arity == 0 then
            "tcelm_custom(arena, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ ctorNameOrig ++ "\", 0)"
        else
            "tcelm_custom(arena, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ ctorNameOrig ++ "\", " ++ String.fromInt arity ++ ", " ++ String.join ", " argsC ++ ")"
    else if isDirectCall then
        let
            ( modulePath, fnNameLocal ) = case fn of
                Src.At _ (VarQual Src.LowVar mp n) -> ( mp, n )
                _ -> ( "", "" )
            fnName = mapStdLibFunction modulePath fnNameLocal
            numArgs = List.length args
            maybeArity = getStdLibArity modulePath fnNameLocal
            needsArena = stdLibNeedsArena modulePath fnNameLocal
        in
        case maybeArity of
            Just arity ->
                if numArgs >= arity then
                    if needsArena then fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"
                    else fnName ++ "(" ++ String.join ", " argsC ++ ")"
                else
                    let
                        remaining = arity - numArgs
                        capturedVars = List.indexedMap (\i _ -> "__c" ++ String.fromInt i) argsC
                        captureDecls = List.map2 (\c a -> "tcelm_value_t *" ++ c ++ " = " ++ a ++ ";") capturedVars argsC
                        applyArgs = capturedVars ++ List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (remaining - 1))
                        callArgs = if needsArena then "__a, " ++ String.join ", " applyArgs else String.join ", " applyArgs
                    in
                    "({\n" ++ String.join "\n" (List.map (\d -> "                " ++ d) captureDecls)
                        ++ "\n                auto tcelm_value_t *__partial_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                        ++ "                    (void)__a;\n                    return " ++ fnName ++ "(" ++ callArgs ++ ");\n"
                        ++ "                }\n                tcelm_closure(arena, __partial_impl, " ++ String.fromInt remaining ++ ");\n            })"
            Nothing -> fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"
    else
        let
            fnExpr = generateExprInContextWithPrefix modulePrefix locals fn
        in
        case List.length args of
            0 -> fnExpr
            1 -> "tcelm_apply(arena, " ++ fnExpr ++ ", " ++ String.join "" argsC ++ ")"
            n -> "tcelm_apply_n(arena, " ++ fnExpr ++ ", " ++ String.fromInt n ++ ", " ++ String.join ", " argsC ++ ")"


{-| Generate if with prefix
-}
generateIfInContextWithPrefix : String -> List String -> List ( Expr, Expr ) -> Expr -> String
generateIfInContextWithPrefix modulePrefix locals branches elseExpr =
    case branches of
        [] -> generateExprInContextWithPrefix modulePrefix locals elseExpr
        [ ( cond, then_ ) ] ->
            "(TCELM_AS_BOOL(" ++ generateExprInContextWithPrefix modulePrefix locals cond ++ ") ? "
                ++ generateExprInContextWithPrefix modulePrefix locals then_ ++ " : "
                ++ generateExprInContextWithPrefix modulePrefix locals elseExpr ++ ")"
        ( cond, then_ ) :: rest ->
            "(TCELM_AS_BOOL(" ++ generateExprInContextWithPrefix modulePrefix locals cond ++ ") ? "
                ++ generateExprInContextWithPrefix modulePrefix locals then_ ++ " : "
                ++ generateIfInContextWithPrefix modulePrefix locals rest elseExpr ++ ")"


{-| Generate let with prefix
-}
generateLetInContextWithPrefix : String -> List String -> List (Src.Located Src.Def) -> Expr -> String
generateLetInContextWithPrefix modulePrefix outerLocals defs body =
    let
        -- Collect all local names (both simple bindings and local functions)
        letLocals = List.concatMap (\(Src.At _ def) ->
            case def of
                Src.Define (Src.At _ name) _ _ _ -> [ name ]
                Src.Destruct pat _ -> collectPatternVar pat
            ) defs
        allLocals = letLocals ++ outerLocals
        defStrs = List.map (generateLocatedDefInContextWithPrefix modulePrefix allLocals) defs
        bodyStr = generateExprInContextWithPrefix modulePrefix allLocals body
    in
    "({\n" ++ String.join "\n" (List.map (\d -> "        " ++ d) defStrs) ++ "\n        " ++ bodyStr ++ ";\n    })"


{-| Generate a located definition with prefix
-}
generateLocatedDefInContextWithPrefix : String -> List String -> Src.Located Src.Def -> String
generateLocatedDefInContextWithPrefix modulePrefix locals (Src.At _ def) =
    case def of
        Src.Define (Src.At _ name) args body _ ->
            if List.isEmpty args then
                "tcelm_value_t *" ++ mangleLocal name ++ " = " ++ generateExprInContextWithPrefix modulePrefix locals body ++ ";"
            else
                -- Local function with arguments - generate GCC nested function + closure
                let
                    arity = List.length args
                    funcLocals = collectPatternVars args
                    allLocals = funcLocals ++ locals
                    mangledName = mangleLocal name
                    implName = mangledName ++ "_impl"

                    argBindings =
                        List.map2 generateArgBinding args (List.indexedMap (\i _ -> "arg" ++ String.fromInt i) args)
                            |> List.concat

                    bodyCode = generateExprInContextWithPrefix modulePrefix allLocals body

                    -- Generate the nested function
                    nestedFunc =
                        "auto tcelm_value_t *" ++ implName ++ "(tcelm_arena_t *arena, tcelm_value_t **args) {\n"
                            ++ (if arity == 0 then
                                    "            (void)args;\n"
                                else
                                    String.join "\n"
                                        (List.indexedMap
                                            (\i _ -> "            tcelm_value_t *arg" ++ String.fromInt i ++ " = args[" ++ String.fromInt i ++ "];")
                                            args
                                        )
                                        ++ "\n"
                               )
                            ++ (if List.isEmpty argBindings then "" else String.join "\n" (List.map (\b -> "            " ++ b) argBindings) ++ "\n")
                            ++ "            return " ++ bodyCode ++ ";\n"
                            ++ "        }"

                    -- Create closure for the function
                    closureDecl =
                        "tcelm_value_t *" ++ mangledName ++ " = tcelm_closure(arena, " ++ implName ++ ", " ++ String.fromInt arity ++ ");"
                in
                nestedFunc ++ "\n        " ++ closureDecl
        Src.Destruct pattern body ->
            let
                destExpr = generateExprInContextWithPrefix modulePrefix locals body
                bindings = generatePatternBindingsLocal "__destruct" pattern
            in
            "tcelm_value_t *__destruct = " ++ destExpr ++ ";\n        " ++ String.join "\n        " bindings


{-| Generate case with prefix
-}
generateCaseInContextWithPrefix : String -> List String -> Expr -> List ( Pattern, Expr ) -> String
generateCaseInContextWithPrefix modulePrefix locals subject branches =
    let
        subjectVar = "__case_subject"
        branchStrs = List.indexedMap (generateBranchInContextWithPrefix modulePrefix locals subjectVar) branches
    in
    "({\n        tcelm_value_t *" ++ subjectVar ++ " = " ++ generateExprInContextWithPrefix modulePrefix locals subject ++ ";\n"
        ++ String.join "\n" branchStrs ++ "\n        TCELM_UNIT; /* unreachable */\n    })"


{-| Generate a case branch with prefix
-}
generateBranchInContextWithPrefix : String -> List String -> String -> Int -> ( Pattern, Expr ) -> String
generateBranchInContextWithPrefix modulePrefix outerLocals subjectVar index ( pattern, body ) =
    let
        patternLocals = collectPatternVar pattern
        allLocals = patternLocals ++ outerLocals
        condition = generatePatternMatch subjectVar pattern
        bindings = generatePatternBindingsLocal subjectVar pattern
        bodyStr = generateExprInContextWithPrefix modulePrefix allLocals body
    in
    "        if (" ++ condition ++ ") {\n"
        ++ String.join "\n" (List.map (\b -> "            " ++ b) bindings)
        ++ (if List.isEmpty bindings then "" else "\n")
        ++ "            " ++ bodyStr ++ ";\n        }"


{-| Generate record with prefix
-}
generateRecordInContextWithPrefix : String -> List String -> List ( Src.Located String, Expr ) -> String
generateRecordInContextWithPrefix modulePrefix locals fields =
    let
        fieldCount = List.length fields
        fieldStrs = List.map (\( Src.At _ name, value ) -> "\"" ++ name ++ "\", " ++ generateExprInContextWithPrefix modulePrefix locals value) fields
    in
    "tcelm_record(arena, " ++ String.fromInt fieldCount ++ ", " ++ String.join ", " fieldStrs ++ ")"


{-| Generate record update with prefix
-}
generateRecordUpdateInContextWithPrefix : String -> List String -> String -> List ( Src.Located String, Expr ) -> String
generateRecordUpdateInContextWithPrefix modulePrefix locals recordName fields =
    case fields of
        [] -> if List.member recordName locals then mangleLocal recordName else mangleWithPrefix modulePrefix recordName
        ( Src.At _ fieldName, value ) :: rest ->
            "tcelm_record_update(arena, " ++ generateRecordUpdateInContextWithPrefix modulePrefix locals recordName rest
                ++ ", \"" ++ fieldName ++ "\", " ++ generateExprInContextWithPrefix modulePrefix locals value ++ ")"


{-| Generate expression in context of local variables
-}
generateExprInContext : List String -> Expr -> String
generateExprInContext locals (Src.At _ expr) =
    case expr of
        Int n ->
            "tcelm_int(arena, " ++ String.fromInt n ++ ")"

        Float f ->
            "tcelm_float(arena, " ++ String.fromFloat f ++ ")"

        Chr c ->
            case String.uncons c of
                Just ( ch, _ ) ->
                    "tcelm_char(arena, " ++ String.fromInt (Char.toCode ch) ++ ")"

                Nothing ->
                    "tcelm_char(arena, 0)"

        Str s ->
            "tcelm_string(arena, \"" ++ escapeString s ++ "\")"

        Var varType name ->
            case varType of
                Src.LowVar ->
                    if List.member name locals then
                        -- Local variable - use directly
                        mangleLocal name
                    else
                        -- Check for known Basics functions used unqualified
                        case name of
                            "identity" ->
                                "tcelm_closure(arena, tcelm_identity_impl, 1)"

                            "toFloat" ->
                                "tcelm_closure(arena, tcelm_to_float_impl, 1)"

                            "min" ->
                                "tcelm_closure(arena, tcelm_min_impl, 2)"

                            "max" ->
                                "tcelm_closure(arena, tcelm_max_impl, 2)"

                            _ ->
                                -- Top-level function - create closure inline
                                "tcelm_closure(arena, " ++ mangle name ++ "_impl, " ++ mangle name ++ "_ARITY)"

                Src.CapVar ->
                    -- Constructor reference - handle known cases
                    -- Extract short name for qualified constructors like AST.Source.At -> At
                    let
                        shortName = extractCtorName name
                    in
                    case shortName of
                        -- Boolean
                        "True" ->
                            "tcelm_custom(arena, TCELM_CTOR_TRUE, \"True\", 0)"

                        "False" ->
                            "tcelm_custom(arena, TCELM_CTOR_FALSE, \"False\", 0)"

                        -- Maybe
                        "Nothing" ->
                            "tcelm_custom(arena, TCELM_CTOR_NOTHING, \"Nothing\", 0)"

                        "Just" ->
                            -- 1-ary constructor: closure that creates Just
                            makeConstructorClosure "Just" 1

                        -- Result
                        "Ok" ->
                            makeConstructorClosure "Ok" 1

                        "Err" ->
                            makeConstructorClosure "Err" 1

                        -- Ordering
                        "LT" ->
                            "tcelm_custom(arena, TCELM_CTOR_LT, \"LT\", 0)"

                        "EQ" ->
                            "tcelm_custom(arena, TCELM_CTOR_EQ, \"EQ\", 0)"

                        "GT" ->
                            "tcelm_custom(arena, TCELM_CTOR_GT, \"GT\", 0)"

                        -- Parser types from Parse/Primitives.elm
                        "Parser" ->
                            makeConstructorClosure "Parser" 1

                        "Good" ->
                            makeConstructorClosure "Good" 3

                        "Bad" ->
                            makeConstructorClosure "Bad" 2

                        "Empty" ->
                            "tcelm_custom(arena, TCELM_CTOR_EMPTY, \"Empty\", 0)"

                        "AddRight" ->
                            makeConstructorClosure "AddRight" 2

                        "Append" ->
                            makeConstructorClosure "Append" 2

                        -- AST types
                        "At" ->
                            makeConstructorClosure "At" 2

                        _ ->
                            -- Unknown constructor - generate as nullary by default
                            -- This may need extension for specific constructors
                            "tcelm_custom(arena, TCELM_CTOR_" ++ String.toUpper shortName ++ ", \"" ++ shortName ++ "\", 0)"

        VarQual varType modulePath name ->
            -- When used as a value, stdlib functions need to be wrapped in closures
            case varType of
                Src.LowVar ->
                    case getStdLibArity modulePath name of
                        Just arity ->
                            -- Generate a closure wrapper for the stdlib function
                            let
                                fnName =
                                    mapStdLibFunction modulePath name

                                needsArena =
                                    stdLibNeedsArena modulePath name

                                argBindings =
                                    List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (arity - 1))

                                callArgs =
                                    if needsArena then
                                        "__a, " ++ String.join ", " argBindings
                                    else
                                        String.join ", " argBindings
                            in
                            "({\n"
                                ++ "                auto tcelm_value_t *__fn_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                                ++ "                    (void)__a;\n"
                                ++ "                    return "
                                ++ fnName
                                ++ "("
                                ++ callArgs
                                ++ ");\n"
                                ++ "                }\n"
                                ++ "                tcelm_closure(arena, __fn_impl, "
                                ++ String.fromInt arity
                                ++ ");\n"
                                ++ "            })"

                        Nothing ->
                            -- Unknown function - just return the mangled name
                            mapStdLibFunction modulePath name

                Src.CapVar ->
                    -- Constructor reference
                    mapStdLibFunction modulePath name

        List exprs ->
            generateListInContext locals exprs

        Op opName ->
            "/* op " ++ opName ++ " */"

        Negate inner ->
            "tcelm_negate_int(arena, " ++ generateExprInContext locals inner ++ ")"

        Binops pairs finalExpr ->
            generateBinopsInContext locals pairs finalExpr

        Lambda args body ->
            generateLambdaInContext locals args body

        Call fn args ->
            generateCallInContext locals fn args

        If branches elseExpr ->
            generateIfInContext locals branches elseExpr

        Let defs body ->
            generateLetInContext locals defs body

        Case subject branches ->
            generateCaseInContext locals subject branches

        Accessor field ->
            "/* accessor ." ++ field ++ " */"

        Access record (Src.At _ field) ->
            "tcelm_record_get(" ++ generateExprInContext locals record ++ ", \"" ++ field ++ "\")"

        Update (Src.At _ recordName) fields ->
            generateRecordUpdateInContext locals recordName fields

        Record fields ->
            generateRecordInContext locals fields

        Unit ->
            "TCELM_UNIT"

        Tuple a b rest ->
            case rest of
                [] ->
                    "tcelm_tuple2(arena, " ++ generateExprInContext locals a ++ ", " ++ generateExprInContext locals b ++ ")"

                [ c ] ->
                    "tcelm_tuple3(arena, "
                        ++ generateExprInContext locals a
                        ++ ", "
                        ++ generateExprInContext locals b
                        ++ ", "
                        ++ generateExprInContext locals c
                        ++ ")"

                _ ->
                    "/* tuple with more than 3 elements not supported */"


{-| Generate list expression with locals context
-}
generateListInContext : List String -> List Expr -> String
generateListInContext locals exprs =
    case exprs of
        [] ->
            "TCELM_NIL"

        x :: xs ->
            "tcelm_cons(arena, "
                ++ generateExprInContext locals x
                ++ ", "
                ++ generateListInContext locals xs
                ++ ")"


{-| Generate binops with locals context
-}
generateBinopsInContext : List String -> List ( Expr, Src.Located String ) -> Expr -> String
generateBinopsInContext locals pairs finalExpr =
    case pairs of
        [] ->
            generateExprInContext locals finalExpr

        ( leftExpr, Src.At _ op ) :: rest ->
            let
                rightExpr =
                    generateBinopsInContext locals rest finalExpr

                l =
                    generateExprInContext locals leftExpr
            in
            generateBinopInContext locals op l rightExpr


{-| Generate a single binop with locals
-}
generateBinopInContext : List String -> String -> String -> String -> String
generateBinopInContext locals op l r =
    -- Same as generateBinop but with context
    generateBinop op l r


{-| Generate lambda with locals context
-}
generateLambdaInContext : List String -> List Pattern -> Expr -> String
generateLambdaInContext outerLocals args body =
    let
        arity =
            List.length args

        -- Collect new locals from lambda args
        lambdaLocals =
            collectPatternVars args

        allLocals =
            lambdaLocals ++ outerLocals

        paramBindings =
            List.indexedMap
                (\i pattern ->
                    let
                        argName = "args[" ++ String.fromInt i ++ "]"
                    in
                    generateLambdaArgBindingLocal pattern argName
                )
                args
                |> List.concat
                |> String.join "\n                "

        bodyCode =
            generateExprInContext allLocals body
    in
    if arity == 0 then
        "({\n"
            ++ "            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                (void)args;\n"
            ++ "                tcelm_arena_t *arena = __a;\n"
            ++ "                return " ++ bodyCode ++ ";\n"
            ++ "            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, 0);\n"
            ++ "        })"
    else
        "({\n"
            ++ "            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                tcelm_arena_t *arena = __a;\n"
            ++ "                " ++ paramBindings ++ "\n"
            ++ "                return " ++ bodyCode ++ ";\n"
            ++ "            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, " ++ String.fromInt arity ++ ");\n"
            ++ "        })"


{-| Generate lambda arg binding using local mangling
-}
generateLambdaArgBindingLocal : Pattern -> String -> List String
generateLambdaArgBindingLocal pattern argExpr =
    case patternValue pattern of
        PVar varName ->
            [ "tcelm_value_t *" ++ mangleLocal varName ++ " = " ++ argExpr ++ ";" ]

        PAnything ->
            [ "(void)" ++ argExpr ++ ";" ]

        PRecord fields ->
            List.map
                (\(Src.At _ fieldName) ->
                    "tcelm_value_t *"
                        ++ mangleLocal fieldName
                        ++ " = tcelm_record_get("
                        ++ argExpr
                        ++ ", \""
                        ++ fieldName
                        ++ "\");"
                )
                fields

        PTuple p1 p2 _ ->
            [ "tcelm_value_t *__t1 = tcelm_tuple2_first(" ++ argExpr ++ ");"
            , "tcelm_value_t *__t2 = tcelm_tuple2_second(" ++ argExpr ++ ");"
            ]
                ++ generateLambdaArgBindingLocal p1 "__t1"
                ++ generateLambdaArgBindingLocal p2 "__t2"

        PCons head tail ->
            [ "tcelm_value_t *__head = tcelm_list_head(" ++ argExpr ++ ");"
            , "tcelm_value_t *__tail = tcelm_list_tail(" ++ argExpr ++ ");"
            ]
                ++ generateLambdaArgBindingLocal head "__head"
                ++ generateLambdaArgBindingLocal tail "__tail"

        PCtor _ _ args ->
            List.indexedMap
                (\i arg ->
                    generateLambdaArgBindingLocal arg ("tcelm_custom_arg(" ++ argExpr ++ ", " ++ String.fromInt i ++ ")")
                )
                args
                |> List.concat

        PCtorQual _ _ _ args ->
            List.indexedMap
                (\i arg ->
                    generateLambdaArgBindingLocal arg ("tcelm_custom_arg(" ++ argExpr ++ ", " ++ String.fromInt i ++ ")")
                )
                args
                |> List.concat

        _ ->
            [ "/* complex lambda pattern not yet supported */" ]


{-| Generate call with locals context
-}
generateCallInContext : List String -> Expr -> List Expr -> String
generateCallInContext locals fn args =
    let
        argsC =
            List.map (generateExprInContext locals) args

        isConstructorCall =
            case fn of
                Src.At _ (Var Src.CapVar _) ->
                    True

                Src.At _ (VarQual Src.CapVar _ _) ->
                    True

                _ ->
                    False

        isDirectCall =
            case fn of
                Src.At _ (VarQual Src.LowVar _ _) ->
                    True

                _ ->
                    False
    in
    if isConstructorCall then
        let
            ( ctorNameUpper, ctorNameOrig ) =
                case fn of
                    Src.At _ (Var Src.CapVar name) ->
                        let
                            shortName = extractCtorName name
                        in
                        ( String.toUpper shortName, shortName )

                    Src.At _ (VarQual Src.CapVar _ name) ->
                        ( String.toUpper name, name )

                    _ ->
                        ( "UNKNOWN", "Unknown" )

            arity =
                List.length args
        in
        if arity == 0 then
            "tcelm_custom(arena, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ ctorNameOrig ++ "\", 0)"
        else
            "tcelm_custom(arena, TCELM_CTOR_"
                ++ ctorNameUpper
                ++ ", \""
                ++ ctorNameOrig
                ++ "\", "
                ++ String.fromInt arity
                ++ ", "
                ++ String.join ", " argsC
                ++ ")"

    else if isDirectCall then
        -- Direct call to a qualified function (VarQual LowVar)
        let
            -- Get module path and name directly (don't use generateExprInContext which generates closures)
            ( modulePath, fnNameLocal ) =
                case fn of
                    Src.At _ (VarQual Src.LowVar mp n) ->
                        ( mp, n )

                    _ ->
                        ( "", "" )

            -- Get the C function name for this stdlib function
            fnName =
                mapStdLibFunction modulePath fnNameLocal

            numArgs =
                List.length args

            maybeArity =
                getStdLibArity modulePath fnNameLocal

            needsArena =
                stdLibNeedsArena modulePath fnNameLocal
        in
        case maybeArity of
            Just arity ->
                if numArgs >= arity then
                    -- Full application - direct call
                    if needsArena then
                        fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"
                    else
                        fnName ++ "(" ++ String.join ", " argsC ++ ")"

                else
                    -- Partial application - generate closure
                    let
                        remaining =
                            arity - numArgs

                        capturedVars =
                            List.indexedMap (\i _ -> "__c" ++ String.fromInt i) argsC

                        captureDecls =
                            List.map2 (\c a -> "tcelm_value_t *" ++ c ++ " = " ++ a ++ ";") capturedVars argsC

                        applyArgs =
                            capturedVars ++ List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (remaining - 1))

                        callArgs =
                            if needsArena then
                                "__a, " ++ String.join ", " applyArgs
                            else
                                String.join ", " applyArgs
                    in
                    "({\n"
                        ++ String.join "\n" (List.map (\d -> "                " ++ d) captureDecls)
                        ++ "\n                auto tcelm_value_t *__partial_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                        ++ "                    (void)__a;\n"
                        ++ "                    return "
                        ++ fnName
                        ++ "("
                        ++ callArgs
                        ++ ");\n"
                        ++ "                }\n"
                        ++ "                tcelm_closure(arena, __partial_impl, "
                        ++ String.fromInt remaining
                        ++ ");\n"
                        ++ "            })"

            Nothing ->
                -- Unknown function - assume full application with arena
                fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"

    else
        -- Closure application - the function expression generates a closure
        let
            fnExpr =
                generateExprInContext locals fn
        in
        case List.length args of
            0 ->
                fnExpr

            1 ->
                "tcelm_apply(arena, " ++ fnExpr ++ ", " ++ String.join "" argsC ++ ")"

            n ->
                "tcelm_apply_n(arena, "
                    ++ fnExpr
                    ++ ", "
                    ++ String.fromInt n
                    ++ ", "
                    ++ String.join ", " argsC
                    ++ ")"


{-| Generate if expression with locals
-}
generateIfInContext : List String -> List ( Expr, Expr ) -> Expr -> String
generateIfInContext locals branches elseExpr =
    case branches of
        [] ->
            generateExprInContext locals elseExpr

        [ ( cond, then_ ) ] ->
            "(TCELM_AS_BOOL("
                ++ generateExprInContext locals cond
                ++ ") ? "
                ++ generateExprInContext locals then_
                ++ " : "
                ++ generateExprInContext locals elseExpr
                ++ ")"

        ( cond, then_ ) :: rest ->
            "(TCELM_AS_BOOL("
                ++ generateExprInContext locals cond
                ++ ") ? "
                ++ generateExprInContext locals then_
                ++ " : "
                ++ generateIfInContext locals rest elseExpr
                ++ ")"


{-| Generate let expression with locals
-}
generateLetInContext : List String -> List (Src.Located Src.Def) -> Expr -> String
generateLetInContext outerLocals defs body =
    let
        -- Collect new locals from let bindings (both simple bindings and local functions)
        letLocals =
            List.concatMap
                (\(Src.At _ def) ->
                    case def of
                        Src.Define (Src.At _ name) _ _ _ ->
                            [ name ]

                        Src.Destruct pat _ ->
                            collectPatternVar pat
                )
                defs

        allLocals =
            letLocals ++ outerLocals

        defStrs =
            List.map (generateLocatedDefInContext allLocals) defs

        bodyStr =
            generateExprInContext allLocals body
    in
    "({\n"
        ++ String.join "\n" (List.map (\d -> "        " ++ d) defStrs)
        ++ "\n        "
        ++ bodyStr
        ++ ";\n    })"


{-| Generate a located definition in context
-}
generateLocatedDefInContext : List String -> Src.Located Src.Def -> String
generateLocatedDefInContext locals (Src.At _ def) =
    case def of
        Src.Define (Src.At _ name) args body _ ->
            if List.isEmpty args then
                "tcelm_value_t *" ++ mangleLocal name ++ " = " ++ generateExprInContext locals body ++ ";"

            else
                -- Local function with arguments - generate GCC nested function + closure
                let
                    arity = List.length args
                    funcLocals = collectPatternVars args
                    allLocals = funcLocals ++ locals
                    mangledName = mangleLocal name
                    implName = mangledName ++ "_impl"

                    argBindings =
                        List.map2 generateArgBinding args (List.indexedMap (\i _ -> "arg" ++ String.fromInt i) args)
                            |> List.concat

                    bodyCode = generateExprInContext allLocals body

                    -- Generate the nested function
                    nestedFunc =
                        "auto tcelm_value_t *" ++ implName ++ "(tcelm_arena_t *arena, tcelm_value_t **args) {\n"
                            ++ (if arity == 0 then
                                    "            (void)args;\n"
                                else
                                    String.join "\n"
                                        (List.indexedMap
                                            (\i _ -> "            tcelm_value_t *arg" ++ String.fromInt i ++ " = args[" ++ String.fromInt i ++ "];")
                                            args
                                        )
                                        ++ "\n"
                               )
                            ++ (if List.isEmpty argBindings then "" else String.join "\n" (List.map (\b -> "            " ++ b) argBindings) ++ "\n")
                            ++ "            return " ++ bodyCode ++ ";\n"
                            ++ "        }"

                    -- Create closure for the function
                    closureDecl =
                        "tcelm_value_t *" ++ mangledName ++ " = tcelm_closure(arena, " ++ implName ++ ", " ++ String.fromInt arity ++ ");"
                in
                nestedFunc ++ "\n        " ++ closureDecl

        Src.Destruct pattern body ->
            -- Destructuring let binding: let (Pattern x) = expr in ...
            let
                destExpr = generateExprInContext locals body
                bindings = generatePatternBindingsLocal "__destruct" pattern
            in
            "tcelm_value_t *__destruct = " ++ destExpr ++ ";\n        "
                ++ String.join "\n        " bindings


{-| Generate case with locals
-}
generateCaseInContext : List String -> Expr -> List ( Pattern, Expr ) -> String
generateCaseInContext locals subject branches =
    let
        subjectVar =
            "__case_subject"

        branchStrs =
            List.indexedMap (generateBranchInContext locals subjectVar) branches
    in
    "({\n"
        ++ "        tcelm_value_t *"
        ++ subjectVar
        ++ " = "
        ++ generateExprInContext locals subject
        ++ ";\n"
        ++ String.join "\n" branchStrs
        ++ "\n        TCELM_UNIT; /* unreachable */\n    })"


{-| Generate a case branch with locals
-}
generateBranchInContext : List String -> String -> Int -> ( Pattern, Expr ) -> String
generateBranchInContext outerLocals subjectVar index ( pattern, body ) =
    let
        -- Collect new locals from pattern
        patternLocals =
            collectPatternVar pattern

        allLocals =
            patternLocals ++ outerLocals

        condition =
            generatePatternMatch subjectVar pattern

        bindings =
            generatePatternBindingsLocal subjectVar pattern

        bodyStr =
            generateExprInContext allLocals body
    in
    "        if ("
        ++ condition
        ++ ") {\n"
        ++ String.join "\n" (List.map (\b -> "            " ++ b) bindings)
        ++ (if List.isEmpty bindings then
                ""

            else
                "\n"
           )
        ++ "            "
        ++ bodyStr
        ++ ";\n        }"


{-| Generate pattern bindings using local mangling
-}
generatePatternBindingsLocal : String -> Pattern -> List String
generatePatternBindingsLocal subject (Src.At _ pattern) =
    case pattern of
        PVar name ->
            [ "tcelm_value_t *" ++ mangleLocal name ++ " = " ++ subject ++ ";" ]

        PCons head tail ->
            let
                headBindings =
                    generatePatternBindingsLocal ("tcelm_list_head(" ++ subject ++ ")") head

                tailBindings =
                    generatePatternBindingsLocal ("tcelm_list_tail(" ++ subject ++ ")") tail
            in
            headBindings ++ tailBindings

        PCtor _ _ args ->
            List.indexedMap
                (\i arg ->
                    generatePatternBindingsLocal
                        ("tcelm_custom_arg(" ++ subject ++ ", " ++ String.fromInt i ++ ")")
                        arg
                )
                args
                |> List.concat

        PCtorQual _ _ _ args ->
            List.indexedMap
                (\i arg ->
                    generatePatternBindingsLocal
                        ("tcelm_custom_arg(" ++ subject ++ ", " ++ String.fromInt i ++ ")")
                        arg
                )
                args
                |> List.concat

        PAlias innerPattern (Src.At _ aliasName) ->
            [ "tcelm_value_t *" ++ mangleLocal aliasName ++ " = " ++ subject ++ ";" ]
                ++ generatePatternBindingsLocal subject innerPattern

        PRecord fields ->
            List.map
                (\(Src.At _ fieldName) ->
                    "tcelm_value_t *"
                        ++ mangleLocal fieldName
                        ++ " = tcelm_record_get("
                        ++ subject
                        ++ ", \""
                        ++ fieldName
                        ++ "\");"
                )
                fields

        PTuple p1 p2 rest ->
            case rest of
                [] ->
                    -- 2-tuple
                    [ "tcelm_value_t *__tuple_1 = tcelm_tuple2_first(" ++ subject ++ ");"
                    , "tcelm_value_t *__tuple_2 = tcelm_tuple2_second(" ++ subject ++ ");"
                    ]
                        ++ generatePatternBindingsLocal "__tuple_1" p1
                        ++ generatePatternBindingsLocal "__tuple_2" p2

                [ p3 ] ->
                    -- 3-tuple
                    [ "tcelm_value_t *__tuple_1 = tcelm_tuple3_first(" ++ subject ++ ");"
                    , "tcelm_value_t *__tuple_2 = tcelm_tuple3_second(" ++ subject ++ ");"
                    , "tcelm_value_t *__tuple_3 = tcelm_tuple3_third(" ++ subject ++ ");"
                    ]
                        ++ generatePatternBindingsLocal "__tuple_1" p1
                        ++ generatePatternBindingsLocal "__tuple_2" p2
                        ++ generatePatternBindingsLocal "__tuple_3" p3

                _ ->
                    [ "/* tuple with more than 3 elements not supported */" ]

        PList patterns ->
            -- Generate bindings for list element patterns using local mangling
            List.indexedMap
                (\i pat ->
                    let
                        nestedTails =
                            if i == 0 then
                                subject
                            else
                                List.repeat i "tcelm_list_tail("
                                    |> String.concat
                                    |> (\prefix -> prefix ++ subject ++ String.repeat i ")")

                        accessor =
                            "tcelm_list_head(" ++ nestedTails ++ ")"
                    in
                    generatePatternBindingsLocal accessor pat
                )
                patterns
                |> List.concat

        _ ->
            []


{-| Generate record expression with locals
-}
generateRecordInContext : List String -> List ( Src.Located String, Expr ) -> String
generateRecordInContext locals fields =
    let
        fieldCount =
            List.length fields

        fieldStrs =
            List.map
                (\( Src.At _ name, value ) ->
                    "\"" ++ name ++ "\", " ++ generateExprInContext locals value
                )
                fields
    in
    "tcelm_record(arena, "
        ++ String.fromInt fieldCount
        ++ ", "
        ++ String.join ", " fieldStrs
        ++ ")"


{-| Generate record update with locals
-}
generateRecordUpdateInContext : List String -> String -> List ( Src.Located String, Expr ) -> String
generateRecordUpdateInContext locals recordName fields =
    case fields of
        [] ->
            if List.member recordName locals then
                mangleLocal recordName
            else
                mangle recordName

        ( Src.At _ fieldName, value ) :: rest ->
            "tcelm_record_update(arena, "
                ++ generateRecordUpdateInContext locals recordName rest
                ++ ", \""
                ++ fieldName
                ++ "\", "
                ++ generateExprInContext locals value
                ++ ")"


{-| Generate bindings for a function argument pattern

Uses a special prefix for local variables to distinguish from top-level functions.
-}
generateArgBinding : Pattern -> String -> List String
generateArgBinding pattern argName =
    case patternValue pattern of
        PVar varName ->
            [ "tcelm_value_t *" ++ mangleLocal varName ++ " = " ++ argName ++ ";" ]

        PAnything ->
            [ "(void)" ++ argName ++ ";" ]

        PRecord fields ->
            List.map
                (\(Src.At _ fieldName) ->
                    "tcelm_value_t *"
                        ++ mangle fieldName
                        ++ " = tcelm_record_get("
                        ++ argName
                        ++ ", \""
                        ++ fieldName
                        ++ "\");"
                )
                fields

        PTuple p1 p2 rest ->
            case rest of
                [] ->
                    -- 2-tuple
                    [ "tcelm_value_t *__t1 = tcelm_tuple2_first(" ++ argName ++ ");"
                    , "tcelm_value_t *__t2 = tcelm_tuple2_second(" ++ argName ++ ");"
                    ]
                        ++ generateArgBinding p1 "__t1"
                        ++ generateArgBinding p2 "__t2"

                [ p3 ] ->
                    -- 3-tuple
                    [ "tcelm_value_t *__t1 = tcelm_tuple3_first(" ++ argName ++ ");"
                    , "tcelm_value_t *__t2 = tcelm_tuple3_second(" ++ argName ++ ");"
                    , "tcelm_value_t *__t3 = tcelm_tuple3_third(" ++ argName ++ ");"
                    ]
                        ++ generateArgBinding p1 "__t1"
                        ++ generateArgBinding p2 "__t2"
                        ++ generateArgBinding p3 "__t3"

                _ ->
                    [ "/* tuple with more than 3 elements not supported */" ]

        PCtor _ _ args ->
            -- Constructor pattern: extract arguments from custom type
            List.indexedMap
                (\i arg ->
                    let
                        argExpr = "tcelm_custom_arg(" ++ argName ++ ", " ++ String.fromInt i ++ ")"
                    in
                    generateArgBinding arg argExpr
                )
                args
                |> List.concat

        PCtorQual _ _ _ args ->
            -- Qualified constructor pattern: extract arguments
            List.indexedMap
                (\i arg ->
                    let
                        argExpr = "tcelm_custom_arg(" ++ argName ++ ", " ++ String.fromInt i ++ ")"
                    in
                    generateArgBinding arg argExpr
                )
                args
                |> List.concat

        PAlias innerPattern (Src.At _ aliasName) ->
            [ "tcelm_value_t *" ++ mangle aliasName ++ " = " ++ argName ++ ";" ]
                ++ generateArgBinding innerPattern argName

        _ ->
            [ "/* complex pattern not yet supported */" ]


{-| Extract the pattern value from a located pattern
-}
patternValue : Pattern -> Pattern_
patternValue (Src.At _ p) =
    p


{-| Generate C code for an expression
-}
generateExpr : Expr -> String
generateExpr (Src.At _ expr) =
    case expr of
        Int n ->
            "tcelm_int(arena, " ++ String.fromInt n ++ ")"

        Float f ->
            "tcelm_float(arena, " ++ String.fromFloat f ++ ")"

        Chr c ->
            -- Chr contains a String (the character)
            case String.uncons c of
                Just ( ch, _ ) ->
                    "tcelm_char(arena, " ++ String.fromInt (Char.toCode ch) ++ ")"

                Nothing ->
                    "tcelm_char(arena, 0)"

        Str s ->
            "tcelm_string(arena, \"" ++ escapeString s ++ "\")"

        Var varType name ->
            case varType of
                Src.LowVar ->
                    -- Variable reference - just use the name
                    -- If this is used in a call context, it will be handled there
                    mangle name

                Src.CapVar ->
                    -- Constructor reference
                    -- Extract short name for qualified constructors like AST.Source.At -> At
                    let
                        shortName = extractCtorName name
                    in
                    case shortName of
                        "True" ->
                            "tcelm_custom(arena, TCELM_CTOR_TRUE, \"True\", 0)"

                        "False" ->
                            "tcelm_custom(arena, TCELM_CTOR_FALSE, \"False\", 0)"

                        "Nothing" ->
                            "tcelm_custom(arena, TCELM_CTOR_NOTHING, \"Nothing\", 0)"

                        "LT" ->
                            "tcelm_custom(arena, TCELM_CTOR_LT, \"LT\", 0)"

                        "EQ" ->
                            "tcelm_custom(arena, TCELM_CTOR_EQ, \"EQ\", 0)"

                        "GT" ->
                            "tcelm_custom(arena, TCELM_CTOR_GT, \"GT\", 0)"

                        _ ->
                            -- Other constructors - reference as closure for partial application
                            -- This will need enhancement for proper constructor currying
                            mangle shortName

        VarQual varType modulePath name ->
            -- Qualified variable like List.map
            -- When used as a value, stdlib functions need closures
            case varType of
                Src.LowVar ->
                    case getStdLibArity modulePath name of
                        Just arity ->
                            let
                                fnName =
                                    mapStdLibFunction modulePath name

                                needsArena =
                                    stdLibNeedsArena modulePath name

                                argBindings =
                                    List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (arity - 1))

                                callArgs =
                                    if needsArena then
                                        "__a, " ++ String.join ", " argBindings
                                    else
                                        String.join ", " argBindings
                            in
                            "({\n"
                                ++ "                auto tcelm_value_t *__fn_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                                ++ "                    (void)__a;\n"
                                ++ "                    return "
                                ++ fnName
                                ++ "("
                                ++ callArgs
                                ++ ");\n"
                                ++ "                }\n"
                                ++ "                tcelm_closure(arena, __fn_impl, "
                                ++ String.fromInt arity
                                ++ ");\n"
                                ++ "            })"

                        Nothing ->
                            mapStdLibFunction modulePath name

                Src.CapVar ->
                    mapStdLibFunction modulePath name

        List exprs ->
            generateList exprs

        Op opName ->
            -- Operator reference (for partial application)
            "/* op " ++ opName ++ " */"

        Negate inner ->
            let
                innerC =
                    generateExpr inner
            in
            "tcelm_negate_int(arena, " ++ innerC ++ ")"

        Binops pairs finalExpr ->
            generateBinops pairs finalExpr

        Lambda args body ->
            generateLambda args body

        Call fn args ->
            generateCall fn args

        If branches elseExpr ->
            generateIf branches elseExpr

        Let defs body ->
            generateLet defs body

        Case subject branches ->
            generateCase subject branches

        Accessor field ->
            "/* accessor ." ++ field ++ " */"

        Access record (Src.At _ field) ->
            "tcelm_record_get(" ++ generateExpr record ++ ", \"" ++ field ++ "\")"

        Update (Src.At _ recordName) fields ->
            generateRecordUpdate recordName fields

        Record fields ->
            generateRecord fields

        Unit ->
            "TCELM_UNIT"

        Tuple a b rest ->
            case rest of
                [] ->
                    "tcelm_tuple2(arena, " ++ generateExpr a ++ ", " ++ generateExpr b ++ ")"

                [ c ] ->
                    "tcelm_tuple3(arena, "
                        ++ generateExpr a
                        ++ ", "
                        ++ generateExpr b
                        ++ ", "
                        ++ generateExpr c
                        ++ ")"

                _ ->
                    "/* tuple with more than 3 elements not supported */"


{-| Generate a list expression
-}
generateList : List Expr -> String
generateList exprs =
    case exprs of
        [] ->
            "TCELM_NIL"

        x :: xs ->
            "tcelm_cons(arena, "
                ++ generateExpr x
                ++ ", "
                ++ generateList xs
                ++ ")"


{-| Generate a chain of binary operations
-}
generateBinops : List ( Expr, Src.Located String ) -> Expr -> String
generateBinops pairs finalExpr =
    case pairs of
        [] ->
            generateExpr finalExpr

        ( leftExpr, Src.At _ op ) :: rest ->
            let
                rightExpr =
                    generateBinops rest finalExpr

                l =
                    generateExpr leftExpr
            in
            generateBinop op l rightExpr


{-| Generate a single binary operation
-}
generateBinop : String -> String -> String -> String
generateBinop op l r =
    case op of
        "+" ->
            "tcelm_add_int(arena, " ++ l ++ ", " ++ r ++ ")"

        "-" ->
            "tcelm_sub_int(arena, " ++ l ++ ", " ++ r ++ ")"

        "*" ->
            "tcelm_mul_int(arena, " ++ l ++ ", " ++ r ++ ")"

        "//" ->
            "tcelm_div_int(arena, " ++ l ++ ", " ++ r ++ ")"

        "/" ->
            "tcelm_div_float(arena, " ++ l ++ ", " ++ r ++ ")"

        "==" ->
            "tcelm_eq(arena, " ++ l ++ ", " ++ r ++ ")"

        "/=" ->
            "tcelm_neq(arena, " ++ l ++ ", " ++ r ++ ")"

        "<" ->
            "tcelm_lt(arena, " ++ l ++ ", " ++ r ++ ")"

        ">" ->
            "tcelm_gt(arena, " ++ l ++ ", " ++ r ++ ")"

        "<=" ->
            "tcelm_le(arena, " ++ l ++ ", " ++ r ++ ")"

        ">=" ->
            "tcelm_ge(arena, " ++ l ++ ", " ++ r ++ ")"

        "&&" ->
            "tcelm_and(arena, " ++ l ++ ", " ++ r ++ ")"

        "||" ->
            "tcelm_or(arena, " ++ l ++ ", " ++ r ++ ")"

        "::" ->
            "tcelm_cons(arena, " ++ l ++ ", " ++ r ++ ")"

        "++" ->
            "tcelm_string_append(arena, " ++ l ++ ", " ++ r ++ ")"

        "|>" ->
            -- Pipeline: x |> f  means  f(x)
            -- l is the value, r is the function
            "tcelm_apply(arena, " ++ r ++ ", " ++ l ++ ")"

        "<|" ->
            -- Reverse pipeline: f <| x  means  f(x)
            -- l is the function, r is the value
            "tcelm_apply(arena, " ++ l ++ ", " ++ r ++ ")"

        ">>" ->
            -- Forward composition: f >> g  means  \x -> g(f(x))
            -- Create a closure that composes two functions
            "({\n"
                ++ "            tcelm_value_t *__f = " ++ l ++ ";\n"
                ++ "            tcelm_value_t *__g = " ++ r ++ ";\n"
                ++ "            auto tcelm_value_t *__compose_impl(tcelm_arena_t *a, tcelm_value_t **args) {\n"
                ++ "                return tcelm_apply(a, __g, tcelm_apply(a, __f, args[0]));\n"
                ++ "            }\n"
                ++ "            tcelm_closure(arena, __compose_impl, 1);\n"
                ++ "        })"

        "<<" ->
            -- Backward composition: f << g  means  \x -> f(g(x))
            -- Create a closure that composes two functions
            "({\n"
                ++ "            tcelm_value_t *__f = " ++ l ++ ";\n"
                ++ "            tcelm_value_t *__g = " ++ r ++ ";\n"
                ++ "            auto tcelm_value_t *__compose_impl(tcelm_arena_t *a, tcelm_value_t **args) {\n"
                ++ "                return tcelm_apply(a, __f, tcelm_apply(a, __g, args[0]));\n"
                ++ "            }\n"
                ++ "            tcelm_closure(arena, __compose_impl, 1);\n"
                ++ "        })"

        _ ->
            "/* unknown binop " ++ op ++ " */ tcelm_apply_n(arena, " ++ mangle op ++ ", 2, " ++ l ++ ", " ++ r ++ ")"


{-| Generate a lambda expression

Uses GCC nested functions (also supported by TCC) to create closures.
The nested function can capture variables from the enclosing scope.
-}
generateLambda : List Pattern -> Expr -> String
generateLambda args body =
    let
        arity =
            List.length args

        -- Generate parameter bindings
        paramBindings =
            List.indexedMap
                (\i pattern ->
                    let
                        argName = "args[" ++ String.fromInt i ++ "]"
                    in
                    generateLambdaArgBinding pattern argName
                )
                args
                |> List.concat
                |> String.join "\n                "

        bodyCode =
            generateExpr body
    in
    if arity == 0 then
        -- Zero-argument lambda (thunk)
        "({\n"
            ++ "            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                (void)args;\n"
            ++ "                tcelm_arena_t *arena = __a;\n"
            ++ "                return " ++ bodyCode ++ ";\n"
            ++ "            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, 0);\n"
            ++ "        })"
    else
        "({\n"
            ++ "            auto tcelm_value_t *__lambda_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
            ++ "                tcelm_arena_t *arena = __a;\n"
            ++ "                " ++ paramBindings ++ "\n"
            ++ "                return " ++ bodyCode ++ ";\n"
            ++ "            }\n"
            ++ "            tcelm_closure(arena, __lambda_impl, " ++ String.fromInt arity ++ ");\n"
            ++ "        })"


{-| Generate argument bindings for a lambda parameter
-}
generateLambdaArgBinding : Pattern -> String -> List String
generateLambdaArgBinding pattern argExpr =
    case patternValue pattern of
        PVar varName ->
            [ "tcelm_value_t *" ++ mangle varName ++ " = " ++ argExpr ++ ";" ]

        PAnything ->
            [ "(void)" ++ argExpr ++ ";" ]

        PRecord fields ->
            List.map
                (\(Src.At _ fieldName) ->
                    "tcelm_value_t *"
                        ++ mangle fieldName
                        ++ " = tcelm_record_get("
                        ++ argExpr
                        ++ ", \""
                        ++ fieldName
                        ++ "\");"
                )
                fields

        PTuple p1 p2 _ ->
            [ "tcelm_value_t *__t1 = tcelm_tuple2_first(" ++ argExpr ++ ");"
            , "tcelm_value_t *__t2 = tcelm_tuple2_second(" ++ argExpr ++ ");"
            ]
                ++ generateLambdaArgBinding p1 "__t1"
                ++ generateLambdaArgBinding p2 "__t2"

        PCons head tail ->
            [ "tcelm_value_t *__head = tcelm_list_head(" ++ argExpr ++ ");"
            , "tcelm_value_t *__tail = tcelm_list_tail(" ++ argExpr ++ ");"
            ]
                ++ generateLambdaArgBinding head "__head"
                ++ generateLambdaArgBinding tail "__tail"

        _ ->
            [ "/* complex lambda pattern not yet supported */" ]


{-| Generate a function call

For direct calls to known functions (Var), we call them directly.
For constructor calls (CapVar), we generate tcelm_custom.
For calls to closures or computed functions, we use tcelm_apply.
-}
generateCall : Expr -> List Expr -> String
generateCall fn args =
    let
        argsC =
            List.map generateExpr args

        -- Check if this is a constructor call
        isConstructorCall =
            case fn of
                Src.At _ (Var Src.CapVar _) ->
                    True

                Src.At _ (VarQual Src.CapVar _ _) ->
                    True

                _ ->
                    False

        -- Check if this is a direct call to a named function
        -- Only qualified names (like List.map) are definitely direct calls
        -- Unqualified names might be pattern-bound variables holding closures
        isDirectCall =
            case fn of
                Src.At _ (VarQual Src.LowVar _ _) ->
                    True

                _ ->
                    False
    in
    if isConstructorCall then
        -- Constructor call: generate tcelm_custom
        let
            ( ctorNameUpper, ctorNameOrig ) =
                case fn of
                    Src.At _ (Var Src.CapVar name) ->
                        let
                            shortName = extractCtorName name
                        in
                        ( String.toUpper shortName, shortName )

                    Src.At _ (VarQual Src.CapVar _ name) ->
                        ( String.toUpper name, name )

                    _ ->
                        ( "UNKNOWN", "Unknown" )

            arity =
                List.length args
        in
        if arity == 0 then
            -- Nullary constructor
            "tcelm_custom(arena, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ ctorNameOrig ++ "\", 0)"
        else
            "tcelm_custom(arena, TCELM_CTOR_"
                ++ ctorNameUpper
                ++ ", \""
                ++ ctorNameOrig
                ++ "\", "
                ++ String.fromInt arity
                ++ ", "
                ++ String.join ", " argsC
                ++ ")"

    else if isDirectCall then
        -- Direct function call to a qualified function (VarQual LowVar)
        let
            -- Get module path and name directly (don't use generateExpr which generates closures)
            ( modulePath, fnNameLocal ) =
                case fn of
                    Src.At _ (VarQual Src.LowVar mp n) ->
                        ( mp, n )

                    _ ->
                        ( "", "" )

            -- Get the C function name for this stdlib function
            fnName =
                mapStdLibFunction modulePath fnNameLocal

            numArgs =
                List.length args

            maybeArity =
                getStdLibArity modulePath fnNameLocal

            needsArena =
                stdLibNeedsArena modulePath fnNameLocal
        in
        case maybeArity of
            Just arity ->
                if numArgs >= arity then
                    if needsArena then
                        fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"
                    else
                        fnName ++ "(" ++ String.join ", " argsC ++ ")"

                else
                    let
                        remaining =
                            arity - numArgs

                        capturedVars =
                            List.indexedMap (\i _ -> "__c" ++ String.fromInt i) argsC

                        captureDecls =
                            List.map2 (\c a -> "tcelm_value_t *" ++ c ++ " = " ++ a ++ ";") capturedVars argsC

                        applyArgs =
                            capturedVars ++ List.indexedMap (\i _ -> "args[" ++ String.fromInt i ++ "]") (List.range 0 (remaining - 1))

                        callArgs =
                            if needsArena then
                                "__a, " ++ String.join ", " applyArgs
                            else
                                String.join ", " applyArgs
                    in
                    "({\n"
                        ++ String.join "\n" (List.map (\d -> "                " ++ d) captureDecls)
                        ++ "\n                auto tcelm_value_t *__partial_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
                        ++ "                    (void)__a;\n"
                        ++ "                    return "
                        ++ fnName
                        ++ "("
                        ++ callArgs
                        ++ ");\n"
                        ++ "                }\n"
                        ++ "                tcelm_closure(arena, __partial_impl, "
                        ++ String.fromInt remaining
                        ++ ");\n"
                        ++ "            })"

            Nothing ->
                fnName ++ "(arena" ++ (if List.isEmpty argsC then "" else ", " ++ String.join ", " argsC) ++ ")"

    else
        -- Closure application
        -- For unqualified function names (LowVar), we might need to call the closure getter
        let
            -- Generate the function expression
            -- For Var LowVar:
            --   - If it's a local variable (from pattern binding), use mangleLocal
            --     which gives _lv_name - already a closure
            --   - If it's a top-level function, use mangle which gives elm_name,
            --     then call it to get the closure: elm_name(arena)
            -- The challenge is: we don't track which names are local vs top-level.
            -- Solution: generateExpr for Var uses mangle (top-level style),
            -- but pattern bindings use mangleLocal. So we check if the generated
            -- name starts with _lv_ to know it's a local var.
            fnExpr =
                case fn of
                    Src.At _ (Var Src.LowVar fnNameVar) ->
                        -- Check if this matches a local variable pattern
                        -- Since we can't know at this point, we generate the
                        -- top-level call style. But we need a way to reference
                        -- local variables...
                        -- For now: assume all LowVar in call position are functions
                        -- Local variables should be referenced with their _lv_ prefix
                        -- which is generated by pattern bindings.
                        mangle fnNameVar ++ "(arena)"

                    _ ->
                        generateExpr fn
        in
        case List.length args of
            0 ->
                fnExpr

            1 ->
                "tcelm_apply(arena, " ++ fnExpr ++ ", " ++ String.join "" argsC ++ ")"

            n ->
                "tcelm_apply_n(arena, "
                    ++ fnExpr
                    ++ ", "
                    ++ String.fromInt n
                    ++ ", "
                    ++ String.join ", " argsC
                    ++ ")"


{-| Generate an if expression with multiple branches (if/else if/else)
-}
generateIf : List ( Expr, Expr ) -> Expr -> String
generateIf branches elseExpr =
    case branches of
        [] ->
            generateExpr elseExpr

        [ ( cond, then_ ) ] ->
            "(TCELM_AS_BOOL("
                ++ generateExpr cond
                ++ ") ? "
                ++ generateExpr then_
                ++ " : "
                ++ generateExpr elseExpr
                ++ ")"

        ( cond, then_ ) :: rest ->
            "(TCELM_AS_BOOL("
                ++ generateExpr cond
                ++ ") ? "
                ++ generateExpr then_
                ++ " : "
                ++ generateIf rest elseExpr
                ++ ")"


{-| Generate a let expression
-}
generateLet : List (Src.Located Src.Def) -> Expr -> String
generateLet defs body =
    -- Generate as a compound statement expression (GCC extension)
    -- Or inline the definitions
    let
        defStrs =
            List.map generateLocatedDef defs

        bodyStr =
            generateExpr body
    in
    "({\n"
        ++ String.join "\n" (List.map (\d -> "        " ++ d) defStrs)
        ++ "\n        "
        ++ bodyStr
        ++ ";\n    })"


{-| Generate a located definition (in a let binding)
-}
generateLocatedDef : Src.Located Src.Def -> String
generateLocatedDef (Src.At _ def) =
    case def of
        Src.Define (Src.At _ name) args body _ ->
            if List.isEmpty args then
                "tcelm_value_t *" ++ mangle name ++ " = " ++ generateExpr body ++ ";"

            else
                "/* local function " ++ name ++ " */"

        Src.Destruct pattern body ->
            -- Destructuring let binding: let (Pattern x) = expr in ...
            let
                destExpr = generateExpr body
                bindings = generatePatternBindings "__destruct" pattern
            in
            "tcelm_value_t *__destruct = " ++ destExpr ++ ";\n        "
                ++ String.join "\n        " bindings


{-| Generate a case expression
-}
generateCase : Expr -> List ( Pattern, Expr ) -> String
generateCase subject branches =
    let
        subjectVar =
            "__case_subject"

        branchStrs =
            List.indexedMap (generateBranch subjectVar) branches
    in
    "({\n"
        ++ "        tcelm_value_t *"
        ++ subjectVar
        ++ " = "
        ++ generateExpr subject
        ++ ";\n"
        ++ String.join "\n" branchStrs
        ++ "\n        TCELM_UNIT; /* unreachable */\n    })"


{-| Generate a case branch
-}
generateBranch : String -> Int -> ( Pattern, Expr ) -> String
generateBranch subjectVar index ( pattern, body ) =
    let
        condition =
            generatePatternMatch subjectVar pattern

        bindings =
            generatePatternBindings subjectVar pattern

        bodyStr =
            generateExpr body
    in
    "        if ("
        ++ condition
        ++ ") {\n"
        ++ String.join "\n" (List.map (\b -> "            " ++ b) bindings)
        ++ (if List.isEmpty bindings then
                ""

            else
                "\n"
           )
        ++ "            "
        ++ bodyStr
        ++ ";\n        }"


{-| Generate a pattern match condition
-}
generatePatternMatch : String -> Pattern -> String
generatePatternMatch subject (Src.At _ pattern) =
    case pattern of
        PAnything ->
            "1"

        PVar _ ->
            "1"

        PInt n ->
            "TCELM_AS_INT(" ++ subject ++ ") == " ++ String.fromInt n

        PStr s ->
            "strcmp(TCELM_AS_STRING(" ++ subject ++ ")->data, \"" ++ escapeString s ++ "\") == 0"

        PChr c ->
            case String.uncons c of
                Just ( ch, _ ) ->
                    "TCELM_AS_CHAR(" ++ subject ++ ") == " ++ String.fromInt (Char.toCode ch)

                Nothing ->
                    "0"

        PCtor _ name args ->
            let
                shortName = extractCtorName name
            in
            "tcelm_custom_ctor(" ++ subject ++ ") == TCELM_CTOR_" ++ String.toUpper shortName

        PCtorQual _ _ name args ->
            "tcelm_custom_ctor(" ++ subject ++ ") == TCELM_CTOR_" ++ String.toUpper name

        PList patterns ->
            case patterns of
                [] ->
                    "tcelm_is_nil(" ++ subject ++ ")"

                [ _ ] ->
                    -- Single element list: not nil and tail is nil
                    "(!tcelm_is_nil(" ++ subject ++ ") && tcelm_is_nil(tcelm_list_tail(" ++ subject ++ ")))"

                [ _, _ ] ->
                    -- Two element list
                    "(!tcelm_is_nil(" ++ subject ++ ") && !tcelm_is_nil(tcelm_list_tail(" ++ subject ++ ")) && tcelm_is_nil(tcelm_list_tail(tcelm_list_tail(" ++ subject ++ "))))"

                _ ->
                    -- For longer lists, check length
                    "/* list pattern with " ++ String.fromInt (List.length patterns) ++ " elements - TODO */"

        PCons head tail ->
            "!tcelm_is_nil(" ++ subject ++ ")"

        PUnit ->
            "1"

        PAlias innerPattern _ ->
            generatePatternMatch subject innerPattern

        PRecord _ ->
            "1"

        PTuple _ _ _ ->
            "1"


{-| Generate pattern bindings
-}
generatePatternBindings : String -> Pattern -> List String
generatePatternBindings subject (Src.At _ pattern) =
    case pattern of
        PVar name ->
            [ "tcelm_value_t *" ++ mangle name ++ " = " ++ subject ++ ";" ]

        PCons head tail ->
            let
                headBindings =
                    generatePatternBindings ("tcelm_list_head(" ++ subject ++ ")") head

                tailBindings =
                    generatePatternBindings ("tcelm_list_tail(" ++ subject ++ ")") tail
            in
            headBindings ++ tailBindings

        PCtor _ _ args ->
            List.indexedMap
                (\i arg ->
                    generatePatternBindings
                        ("tcelm_custom_arg(" ++ subject ++ ", " ++ String.fromInt i ++ ")")
                        arg
                )
                args
                |> List.concat

        PCtorQual _ _ _ args ->
            List.indexedMap
                (\i arg ->
                    generatePatternBindings
                        ("tcelm_custom_arg(" ++ subject ++ ", " ++ String.fromInt i ++ ")")
                        arg
                )
                args
                |> List.concat

        PAlias innerPattern (Src.At _ aliasName) ->
            [ "tcelm_value_t *" ++ mangle aliasName ++ " = " ++ subject ++ ";" ]
                ++ generatePatternBindings subject innerPattern

        PRecord fields ->
            List.map
                (\(Src.At _ fieldName) ->
                    "tcelm_value_t *"
                        ++ mangle fieldName
                        ++ " = tcelm_record_get("
                        ++ subject
                        ++ ", \""
                        ++ fieldName
                        ++ "\");"
                )
                fields

        PTuple p1 p2 rest ->
            case rest of
                [] ->
                    -- 2-tuple
                    [ "tcelm_value_t *__tuple_1 = tcelm_tuple2_first(" ++ subject ++ ");"
                    , "tcelm_value_t *__tuple_2 = tcelm_tuple2_second(" ++ subject ++ ");"
                    ]
                        ++ generatePatternBindings "__tuple_1" p1
                        ++ generatePatternBindings "__tuple_2" p2

                [ p3 ] ->
                    -- 3-tuple
                    [ "tcelm_value_t *__tuple_1 = tcelm_tuple3_first(" ++ subject ++ ");"
                    , "tcelm_value_t *__tuple_2 = tcelm_tuple3_second(" ++ subject ++ ");"
                    , "tcelm_value_t *__tuple_3 = tcelm_tuple3_third(" ++ subject ++ ");"
                    ]
                        ++ generatePatternBindings "__tuple_1" p1
                        ++ generatePatternBindings "__tuple_2" p2
                        ++ generatePatternBindings "__tuple_3" p3

                _ ->
                    [ "/* tuple with more than 3 elements not supported */" ]

        PList patterns ->
            -- Generate bindings for list element patterns
            -- For [a, b, c]: a = head(s), b = head(tail(s)), c = head(tail(tail(s)))
            List.indexedMap
                (\i pat ->
                    let
                        -- Build nested tail calls: tail(tail(tail(subject)))...
                        nestedTails =
                            if i == 0 then
                                subject
                            else
                                List.repeat i "tcelm_list_tail("
                                    |> String.concat
                                    |> (\prefix -> prefix ++ subject ++ String.repeat i ")")

                        accessor =
                            "tcelm_list_head(" ++ nestedTails ++ ")"
                    in
                    generatePatternBindings accessor pat
                )
                patterns
                |> List.concat

        _ ->
            []


{-| Generate a record literal
-}
generateRecord : List ( Src.Located String, Expr ) -> String
generateRecord fields =
    let
        fieldCount =
            List.length fields

        fieldStrs =
            List.map
                (\( Src.At _ name, value ) ->
                    "\"" ++ name ++ "\", " ++ generateExpr value
                )
                fields
    in
    "tcelm_record(arena, "
        ++ String.fromInt fieldCount
        ++ ", "
        ++ String.join ", " fieldStrs
        ++ ")"


{-| Generate a record update
-}
generateRecordUpdate : String -> List ( Src.Located String, Expr ) -> String
generateRecordUpdate recordName fields =
    case fields of
        [] ->
            mangle recordName

        ( Src.At _ fieldName, value ) :: rest ->
            "tcelm_record_update(arena, "
                ++ generateRecordUpdate recordName rest
                ++ ", \""
                ++ fieldName
                ++ "\", "
                ++ generateExpr value
                ++ ")"


{-| Generate a union type definition
-}
generateUnion : Src.Located Src.Union -> String
generateUnion (Src.At _ union) =
    let
        (Src.At _ name) =
            union.name

        ctorDefs =
            List.indexedMap
                (\i ( Src.At _ ctorName, _ ) ->
                    "#define TCELM_CTOR_" ++ String.toUpper ctorName ++ " " ++ String.fromInt i
                )
                union.ctors
    in
    "/* type " ++ name ++ " */\n" ++ String.join "\n" ctorDefs


{-| Generate a type alias definition

For record type aliases, we also generate a constructor define
so that record constructor calls like `Region start end` work.
-}
generateAlias : Src.Located Src.Alias -> String
generateAlias (Src.At _ alias_) =
    let
        (Src.At _ name) =
            alias_.name

        isRecordAlias =
            case alias_.type_ of
                Src.At _ (Src.TRecord _ _) ->
                    True

                _ ->
                    False
    in
    if isRecordAlias then
        "/* type alias " ++ name ++ " */\n"
            ++ "#define TCELM_CTOR_" ++ String.toUpper name ++ " 0"
    else
        "/* type alias " ++ name ++ " */"


{-| Generate a closure that creates a constructor when called.
    For example, makeConstructorClosure "Just" 1 creates a closure that,
    when applied to one argument, creates Just(arg).
-}
makeConstructorClosure : String -> Int -> String
makeConstructorClosure name arity =
    let
        ctorNameUpper =
            String.toUpper name

        argBindings =
            List.range 0 (arity - 1)
                |> List.map (\i -> "args[" ++ String.fromInt i ++ "]")
                |> String.join ", "
    in
    "({\n"
        ++ "            auto tcelm_value_t *__ctor_impl(tcelm_arena_t *__a, tcelm_value_t **args) {\n"
        ++ "                return tcelm_custom(__a, TCELM_CTOR_" ++ ctorNameUpper ++ ", \"" ++ name ++ "\", " ++ String.fromInt arity ++ ", " ++ argBindings ++ ");\n"
        ++ "            }\n"
        ++ "            tcelm_closure(arena, __ctor_impl, " ++ String.fromInt arity ++ ");\n"
        ++ "        })"


{-| Map standard library function calls to their C runtime equivalents.
    Some Elm standard library functions map directly to runtime functions.
-}
mapStdLibFunction : String -> String -> String
mapStdLibFunction modulePath name =
    case ( modulePath, name ) of
        -- String module
        ( "String", "slice" ) ->
            "tcelm_string_slice"

        ( "String", "length" ) ->
            "tcelm_string_length"

        ( "String", "append" ) ->
            "tcelm_string_append"

        ( "String", "concat" ) ->
            "tcelm_string_concat"

        ( "String", "fromInt" ) ->
            "tcelm_string_from_int"

        ( "String", "fromFloat" ) ->
            "tcelm_string_from_float"

        ( "String", "toInt" ) ->
            "tcelm_string_to_int"

        ( "String", "toFloat" ) ->
            "tcelm_string_to_float"

        ( "String", "dropLeft" ) ->
            "tcelm_string_dropLeft"

        ( "String", "left" ) ->
            "tcelm_string_left"

        ( "String", "uncons" ) ->
            "tcelm_string_uncons"

        ( "String", "join" ) ->
            "tcelm_string_join"

        ( "String", "replace" ) ->
            "tcelm_string_replace"

        ( "String", "split" ) ->
            "tcelm_string_split"

        ( "String", "toList" ) ->
            "tcelm_string_toList"

        ( "String", "fromList" ) ->
            "tcelm_string_fromList"

        ( "String", "fromChar" ) ->
            "tcelm_string_fromChar"

        ( "String", "toUpper" ) ->
            "tcelm_string_toUpper"

        ( "String", "toLower" ) ->
            "tcelm_string_toLower"

        ( "String", "repeat" ) ->
            "tcelm_string_repeat"

        ( "String", "reverse" ) ->
            "tcelm_string_reverse"

        -- Char module
        ( "Char", "isAlphaNum" ) ->
            "tcelm_char_isAlphaNum"

        ( "Char", "isAlpha" ) ->
            "tcelm_char_isAlpha"

        ( "Char", "isDigit" ) ->
            "tcelm_char_isDigit"

        ( "Char", "isUpper" ) ->
            "tcelm_char_isUpper"

        ( "Char", "isLower" ) ->
            "tcelm_char_isLower"

        ( "Char", "toCode" ) ->
            "tcelm_char_toCode"

        ( "Char", "fromCode" ) ->
            "tcelm_char_fromCode"

        -- List module
        ( "List", "map" ) ->
            "tcelm_list_map"

        ( "List", "foldl" ) ->
            "tcelm_list_foldl"

        ( "List", "foldr" ) ->
            "tcelm_list_foldr"

        ( "List", "filter" ) ->
            "tcelm_list_filter"

        ( "List", "length" ) ->
            "tcelm_list_length"

        ( "List", "reverse" ) ->
            "tcelm_list_reverse"

        ( "List", "head" ) ->
            "tcelm_list_head"

        ( "List", "tail" ) ->
            "tcelm_list_tail"

        ( "List", "concat" ) ->
            "tcelm_list_concat"

        ( "List", "concatMap" ) ->
            "tcelm_list_concatMap"

        ( "List", "map2" ) ->
            "tcelm_list_map2"

        ( "List", "indexedMap" ) ->
            "tcelm_list_indexedMap"

        ( "List", "isEmpty" ) ->
            "tcelm_list_isEmpty"

        ( "List", "member" ) ->
            "tcelm_list_member"

        ( "List", "range" ) ->
            "tcelm_list_range"

        ( "List", "repeat" ) ->
            "tcelm_list_repeat"

        -- Maybe module
        ( "Maybe", "map" ) ->
            "tcelm_maybe_map"

        ( "Maybe", "withDefault" ) ->
            "tcelm_maybe_withDefault"

        -- Tuple module
        ( "Tuple", "first" ) ->
            "tcelm_tuple2_first"

        ( "Tuple", "second" ) ->
            "tcelm_tuple2_second"

        -- Basics module
        ( "Basics", "identity" ) ->
            "tcelm_identity"

        ( "Basics", "toFloat" ) ->
            "tcelm_to_float"

        ( "Basics", "min" ) ->
            "tcelm_min"

        ( "Basics", "max" ) ->
            "tcelm_max"

        -- Default: mangle as elm_Module_name
        _ ->
            mangle (modulePath ++ "_" ++ name)


{-| Get the arity of a stdlib function (number of arguments excluding arena)
    Returns Nothing for unknown functions.
-}
getStdLibArity : String -> String -> Maybe Int
getStdLibArity modulePath name =
    case ( modulePath, name ) of
        ( "Maybe", "map" ) ->
            Just 2

        ( "Maybe", "withDefault" ) ->
            Just 2

        ( "Maybe", "andThen" ) ->
            Just 2

        ( "Tuple", "first" ) ->
            Just 1

        ( "Tuple", "second" ) ->
            Just 1

        ( "String", "slice" ) ->
            Just 3

        ( "String", "dropLeft" ) ->
            Just 2

        ( "String", "length" ) ->
            Just 1

        ( "String", "uncons" ) ->
            Just 1

        ( "String", "join" ) ->
            Just 2

        ( "String", "replace" ) ->
            Just 3

        ( "String", "split" ) ->
            Just 2

        ( "String", "toList" ) ->
            Just 1

        ( "String", "fromList" ) ->
            Just 1

        ( "String", "fromChar" ) ->
            Just 1

        ( "String", "append" ) ->
            Just 2

        ( "String", "concat" ) ->
            Just 1

        ( "String", "fromInt" ) ->
            Just 1

        ( "String", "fromFloat" ) ->
            Just 1

        ( "String", "toUpper" ) ->
            Just 1

        ( "String", "toLower" ) ->
            Just 1

        ( "String", "repeat" ) ->
            Just 2

        ( "String", "reverse" ) ->
            Just 1

        ( "Char", "toCode" ) ->
            Just 1

        ( "Char", "fromCode" ) ->
            Just 1

        ( "List", "map" ) ->
            Just 2

        ( "List", "foldl" ) ->
            Just 3

        ( "List", "foldr" ) ->
            Just 3

        ( "List", "filter" ) ->
            Just 2

        ( "List", "head" ) ->
            Just 1

        ( "List", "tail" ) ->
            Just 1

        ( "List", "length" ) ->
            Just 1

        ( "List", "reverse" ) ->
            Just 1

        ( "List", "concat" ) ->
            Just 1

        ( "List", "concatMap" ) ->
            Just 2

        ( "List", "map2" ) ->
            Just 3

        ( "List", "indexedMap" ) ->
            Just 2

        ( "List", "isEmpty" ) ->
            Just 1

        ( "List", "member" ) ->
            Just 2

        ( "List", "range" ) ->
            Just 2

        ( "List", "repeat" ) ->
            Just 2

        ( "Basics", "identity" ) ->
            Just 1

        ( "Basics", "toFloat" ) ->
            Just 1

        ( "Basics", "min" ) ->
            Just 2

        ( "Basics", "max" ) ->
            Just 2

        _ ->
            Nothing


{-| Check if a stdlib function takes arena as first argument.
    Most do, but some pure functions like tuple accessors don't.
-}
stdLibNeedsArena : String -> String -> Bool
stdLibNeedsArena modulePath name =
    case ( modulePath, name ) of
        ( "Tuple", "first" ) ->
            False

        ( "Tuple", "second" ) ->
            False

        ( "List", "head" ) ->
            False

        ( "List", "tail" ) ->
            False

        _ ->
            True


{-| Mangle an Elm identifier to a valid C identifier (for top-level names)
-}
mangle : String -> String
mangle name =
    let
        replaceChar c =
            case c of
                '\'' ->
                    "_prime"

                '.' ->
                    "_"

                _ ->
                    String.fromChar c
    in
    "elm_" ++ String.concat (List.map replaceChar (String.toList name))


{-| Mangle an Elm identifier with module prefix for cross-module linking
    E.g., mangleWithPrefix "AST_Source" "at" -> "elm_AST_Source_at"
-}
mangleWithPrefix : String -> String -> String
mangleWithPrefix modulePrefix name =
    let
        replaceChar c =
            case c of
                '\'' ->
                    "_prime"

                '.' ->
                    "_"

                _ ->
                    String.fromChar c
    in
    "elm_" ++ modulePrefix ++ "_" ++ String.concat (List.map replaceChar (String.toList name))


{-| Mangle a local variable name (from pattern bindings)
    Local variables get a different prefix to distinguish from top-level functions.
-}
mangleLocal : String -> String
mangleLocal name =
    let
        replaceChar c =
            case c of
                '\'' ->
                    "_prime"

                _ ->
                    String.fromChar c
    in
    "_lv_" ++ String.concat (List.map replaceChar (String.toList name))


{-| Extract the constructor name from a potentially qualified name.
    E.g., "AST.Source.At" -> "At", "Just" -> "Just"
-}
extractCtorName : String -> String
extractCtorName name =
    case List.reverse (String.split "." name) of
        lastPart :: _ ->
            lastPart

        [] ->
            name


{-| Escape a string for C
-}
escapeString : String -> String
escapeString s =
    String.toList s
        |> List.map
            (\c ->
                case c of
                    '"' ->
                        "\\\""

                    '\\' ->
                        "\\\\"

                    '\n' ->
                        "\\n"

                    '\t' ->
                        "\\t"

                    '\u{000D}' ->
                        "\\r"

                    _ ->
                        String.fromChar c
            )
        |> String.concat



-- ============================================================================
-- RTEMS CODE GENERATION
-- ============================================================================


{-| Generate C code for an RTEMS module.

This generates:
- The standard module code
- A tcelm_task_def_t struct for the main function
- Shell registration code

-}
generateRtemsModule : Module -> String
generateRtemsModule mod =
    let
        moduleName =
            mod.name
                |> Maybe.map (\(Src.At _ n) -> n)
                |> Maybe.withDefault "Main"

        baseCode =
            generateModule mod

        rtemsIncludes =
            [ ""
            , "/* RTEMS Integration */"
            , "#include \"tcelm_rtems.h\""
            , "#include \"tcelm_shell.h\""
            , ""
            ]

        -- Generate init function wrapper
        initWrapper =
            [ "/* Init function wrapper */"
            , "static tcelm_value_t *" ++ mangle moduleName ++ "_init_wrapper(tcelm_arena_t *arena) {"
            , "    return elm_init(arena);"
            , "}"
            , ""
            ]

        -- Generate update function wrapper
        updateWrapper =
            [ "/* Update function wrapper */"
            , "static tcelm_value_t *" ++ mangle moduleName ++ "_update_wrapper("
            , "        tcelm_arena_t *arena,"
            , "        tcelm_value_t *msg,"
            , "        tcelm_value_t *model) {"
            , "    return tcelm_apply_n(arena, elm_update(arena), 2, msg, model);"
            , "}"
            , ""
            ]

        -- Generate subscriptions function wrapper
        subscriptionsWrapper =
            [ "/* Subscriptions function wrapper */"
            , "static tcelm_value_t *" ++ mangle moduleName ++ "_subscriptions_wrapper("
            , "        tcelm_arena_t *arena,"
            , "        tcelm_value_t *model) {"
            , "    return tcelm_apply(arena, elm_subscriptions(arena), model);"
            , "}"
            , ""
            ]

        -- Generate task definition
        taskDef =
            [ "/* Task definition for RTEMS */"
            , "static const tcelm_task_def_t " ++ mangle moduleName ++ "_task_def = {"
            , "    .name = \"" ++ moduleName ++ "\","
            , "    .init = " ++ mangle moduleName ++ "_init_wrapper,"
            , "    .update = " ++ mangle moduleName ++ "_update_wrapper,"
            , "    .subscriptions = " ++ mangle moduleName ++ "_subscriptions_wrapper,"
            , "    .view = NULL,"
            , "    .priority = 0,  /* Use default */"
            , "    .stack_size = 0  /* Use default */"
            , "};"
            , ""
            ]

        -- Generate registration function
        registerFunc =
            [ "/* Register this module with tcelm shell */"
            , "void " ++ mangle moduleName ++ "_register(void) {"
            , "    tcelm_shell_register_module(\"" ++ moduleName ++ "\", &" ++ mangle moduleName ++ "_task_def);"
            , "}"
            , ""
            ]

        -- Generate auto-registration using constructor (GCC extension)
        autoRegister =
            [ "/* Auto-register on load (GCC extension) */"
            , "#ifdef __GNUC__"
            , "static void __attribute__((constructor)) " ++ mangle moduleName ++ "_auto_register(void) {"
            , "    " ++ mangle moduleName ++ "_register();"
            , "}"
            , "#endif"
            , ""
            ]

        -- Generate main entry point if this is the main module
        mainEntry =
            if moduleName == "Main" then
                [ "/* Main entry point for standalone RTEMS application */"
                , "#ifdef TCELM_STANDALONE"
                , "rtems_task Init(rtems_task_argument arg) {"
                , "    (void)arg;"
                , ""
                , "    /* Initialize tcelm runtime */"
                , "    tcelm_rtems_init(NULL);"
                , ""
                , "    /* Initialize shell commands */"
                , "    tcelm_shell_init();"
                , ""
                , "    /* Spawn main task */"
                , "    tcelm_task_t *main_task = tcelm_task_spawn(&" ++ mangle moduleName ++ "_task_def);"
                , "    if (!main_task) {"
                , "        printf(\"Failed to spawn main task\\n\");"
                , "        rtems_task_delete(RTEMS_SELF);"
                , "    }"
                , ""
                , "    /* Start RTEMS shell (optional) */"
                , "#ifdef TCELM_SHELL"
                , "    rtems_shell_init("
                , "        \"SHLL\","
                , "        32 * 1024,"
                , "        100,"
                , "        \"/dev/console\","
                , "        false,"
                , "        true,"
                , "        NULL"
                , "    );"
                , "#endif"
                , ""
                , "    /* Delete init task - application runs via spawned tasks */"
                , "    rtems_task_delete(RTEMS_SELF);"
                , "}"
                , "#endif /* TCELM_STANDALONE */"
                , ""
                ]

            else
                []
    in
    baseCode
        ++ "\n"
        ++ String.join "\n" rtemsIncludes
        ++ String.join "\n" initWrapper
        ++ String.join "\n" updateWrapper
        ++ String.join "\n" subscriptionsWrapper
        ++ String.join "\n" taskDef
        ++ String.join "\n" registerFunc
        ++ String.join "\n" autoRegister
        ++ String.join "\n" mainEntry


{-| Generate a native Platform.worker for file I/O based compilation.

This generates code that uses tcelm_worker_run instead of RTEMS tasks,
enabling self-hosting with TCC or GCC on native platforms.

The generated worker:
- Reads input from a file (passed via flags.source)
- Processes it through init/update
- Outputs result via worker commands
-}
generateNativeWorkerModule : Module -> String
generateNativeWorkerModule mod =
    let
        moduleName =
            mod.name
                |> Maybe.map (\(Src.At _ n) -> n)
                |> Maybe.withDefault "Main"

        baseCode =
            generateModule mod

        workerIncludes =
            [ ""
            , "/* Native Worker Integration */"
            , "#include \"tcelm_worker.h\""
            , ""
            ]

        -- Generate init function wrapper
        initWrapper =
            [ "/* Init function wrapper for native worker */"
            , "static tcelm_value_t *" ++ mangle moduleName ++ "_worker_init("
            , "        tcelm_arena_t *arena,"
            , "        tcelm_value_t *flags) {"
            , "    /* Extract source from flags record */"
            , "    tcelm_value_t *source = tcelm_record_get(flags, \"source\");"
            , "    return elm_init(arena);"
            , "}"
            , ""
            ]

        -- Generate update function wrapper
        updateWrapper =
            [ "/* Update function wrapper for native worker */"
            , "static tcelm_value_t *" ++ mangle moduleName ++ "_worker_update("
            , "        tcelm_arena_t *arena,"
            , "        tcelm_value_t *msg,"
            , "        tcelm_value_t *model) {"
            , "    return tcelm_apply_n(arena, elm_update(arena), 2, msg, model);"
            , "}"
            , ""
            ]

        -- Generate worker program definition
        workerDef =
            [ "/* Worker program definition */"
            , "static const tcelm_worker_program_t " ++ mangle moduleName ++ "_worker_program = {"
            , "    .name = \"" ++ moduleName ++ "\","
            , "    .init = " ++ mangle moduleName ++ "_worker_init,"
            , "    .update = " ++ mangle moduleName ++ "_worker_update,"
            , "    .subscriptions = NULL"
            , "};"
            , ""
            ]

        -- Generate main entry point
        mainEntry =
            [ "/* Main entry point for native worker */"
            , "#ifndef TCELM_NO_MAIN"
            , "int main(int argc, char **argv) {"
            , "    return tcelm_worker_run(&" ++ mangle moduleName ++ "_worker_program, NULL, argc, argv);"
            , "}"
            , "#endif"
            , ""
            ]
    in
    baseCode
        ++ "\n"
        ++ String.join "\n" workerIncludes
        ++ String.join "\n" initWrapper
        ++ String.join "\n" updateWrapper
        ++ String.join "\n" workerDef
        ++ String.join "\n" mainEntry


{-| Generate RTEMS kernel function calls
-}
generateRtemsKernelCall : String -> List Expr -> String
generateRtemsKernelCall funcName args =
    case funcName of
        "Rtems.now" ->
            "tcelm_rtems_time_ms(arena)"

        "Rtems.ticks" ->
            "tcelm_rtems_tick_get(arena)"

        "Rtems.ticksPerSecond" ->
            "tcelm_rtems_ticks_per_second(arena)"

        "Rtems.every" ->
            case args of
                [ interval, toMsg ] ->
                    "tcelm_sub_every_ms(arena, "
                        ++ generateExpr interval
                        ++ ", "
                        ++ generateExpr toMsg
                        ++ ")"

                _ ->
                    "/* invalid Rtems.every call */"

        "Rtems.everyTick" ->
            case args of
                [ interval, toMsg ] ->
                    "tcelm_sub_every_ticks(arena, "
                        ++ generateExpr interval
                        ++ ", "
                        ++ generateExpr toMsg
                        ++ ")"

                _ ->
                    "/* invalid Rtems.everyTick call */"

        "Rtems.delay" ->
            case args of
                [ delayMs, msg ] ->
                    "tcelm_sub_delay_ms(arena, "
                        ++ generateExpr delayMs
                        ++ ", "
                        ++ generateExpr msg
                        ++ ")"

                _ ->
                    "/* invalid Rtems.delay call */"

        "Rtems.Gpio.read" ->
            case args of
                [ pin ] ->
                    "tcelm_gpio_read(arena, " ++ generateExpr pin ++ ")"

                _ ->
                    "/* invalid Rtems.Gpio.read call */"

        "Rtems.Gpio.write" ->
            case args of
                [ pin, value ] ->
                    "tcelm_gpio_write(arena, "
                        ++ generateExpr pin
                        ++ ", "
                        ++ generateExpr value
                        ++ ")"

                _ ->
                    "/* invalid Rtems.Gpio.write call */"

        "Rtems.Uart.write" ->
            case args of
                [ port_, data ] ->
                    "tcelm_uart_write(arena, "
                        ++ generateExpr port_
                        ++ ", "
                        ++ generateExpr data
                        ++ ")"

                _ ->
                    "/* invalid Rtems.Uart.write call */"

        "Rtems.Uart.print" ->
            case args of
                [ data ] ->
                    "tcelm_uart_write(arena, tcelm_int(arena, 0), " ++ generateExpr data ++ ")"

                _ ->
                    "/* invalid Rtems.Uart.print call */"

        "Cmd.none" ->
            "tcelm_cmd_none(arena)"

        "Cmd.batch" ->
            case args of
                [ cmds ] ->
                    "tcelm_cmd_batch(arena, " ++ generateExpr cmds ++ ")"

                _ ->
                    "/* invalid Cmd.batch call */"

        "Sub.none" ->
            "tcelm_sub_none(arena)"

        "Sub.batch" ->
            case args of
                [ subs ] ->
                    "tcelm_sub_batch(arena, " ++ generateExpr subs ++ ")"

                _ ->
                    "/* invalid Sub.batch call */"

        _ ->
            "/* unknown kernel call: " ++ funcName ++ " */"
