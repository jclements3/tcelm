module Codegen.C exposing
    ( generateC
    , generateModule
    , Options
    , defaultOptions
    )

{-| C code generation from Core IR.

This module generates C code from the Core intermediate representation.
The generated code is designed to be:
- TCC compatible (no GCC extensions)
- Suitable for embedded systems (RTEMS, bare metal)
- Efficient for the target use cases

Key design decisions:
- Closures are heap-allocated structs
- Type class dictionaries are passed explicitly
- Tail calls are optimized where possible
- Pattern matching compiles to efficient switch/if chains
-}

import Core
import Types exposing (Type(..), Scheme(..), Constraint(..))
import Dict exposing (Dict)
import Set


-- OPTIONS


type alias Options =
    { targetName : String
    , emitDebugInfo : Bool
    , optimizeLevel : Int
    , maxClosureArgs : Int
    , maxTupleSize : Int
    }


defaultOptions : Options
defaultOptions =
    { targetName = "tcc"
    , emitDebugInfo = False
    , optimizeLevel = 1
    , maxClosureArgs = 8
    , maxTupleSize = 8
    }



-- CONTEXT


type alias GenCtx =
    { options : Options
    , moduleName : String
    , indent : Int
    , freshId : Int
    , dataTypes : Dict String Core.DataDef
    , functions : Dict String Core.FuncDef
    , classes : Dict String Core.ClassDef
    , instances : List Core.InstDef
    , closureParams : Set.Set String  -- Function parameters that are closures
    , localVars : Set.Set String       -- Local variables in scope (for free var computation)
    , liftedLambdas : List LiftedLambda -- Accumulated lifted lambda functions
    }


{-| A lambda that has been lifted to a top-level function.
-}
type alias LiftedLambda =
    { name : String           -- Generated function name (e.g., "__lambda_0")
    , definition : String     -- Full C function definition
    }


emptyCtx : Options -> GenCtx
emptyCtx opts =
    { options = opts
    , moduleName = "Main"
    , indent = 0
    , freshId = 0
    , dataTypes = Dict.empty
    , functions = Dict.empty
    , classes = Dict.empty
    , instances = []
    , closureParams = Set.empty
    , localVars = Set.empty
    , liftedLambdas = []
    }


freshName : String -> GenCtx -> ( String, GenCtx )
freshName prefix ctx =
    ( prefix ++ "_" ++ String.fromInt ctx.freshId
    , { ctx | freshId = ctx.freshId + 1 }
    )


withIndent : GenCtx -> GenCtx
withIndent ctx =
    { ctx | indent = ctx.indent + 1 }


indentStr : GenCtx -> String
indentStr ctx =
    String.repeat (ctx.indent * 4) " "



-- MAIN ENTRY POINT


generateC : Options -> Core.Module -> String
generateC opts module_ =
    let
        ctx = collectDecls (emptyCtx opts) module_.decls
        ctx1 = { ctx | moduleName = module_.name }

        -- First pass: collect all lifted lambdas by generating functions
        ( funcCode, finalCtx ) = generateFunctionsWithLambdas ctx1

        -- Generate lambda forward declarations and definitions
        lambdaForwardDecls =
            finalCtx.liftedLambdas
                |> List.reverse  -- Reverse to get declaration order
                |> List.map .name
                |> List.map (\name -> "static elm_value_t " ++ name ++ "();")
                |> String.join "\n"

        lambdaDefinitions =
            finalCtx.liftedLambdas
                |> List.reverse
                |> List.map .definition
                |> String.join "\n\n"
    in
    String.join "\n"
        [ generateHeader ctx1
        , ""
        , generateRuntime ctx1
        , ""
        , generateTypeDecls ctx1
        , ""
        , generateForwardDecls ctx1
        , if String.isEmpty lambdaForwardDecls then "" else "\n/* Lifted lambda forward declarations */\n" ++ lambdaForwardDecls
        , ""
        , if String.isEmpty lambdaDefinitions then "" else "/* ===== LIFTED LAMBDAS ===== */\n\n" ++ lambdaDefinitions
        , ""
        , "/* ===== FUNCTIONS ===== */\n\n" ++ funcCode
        , ""
        , generateMain finalCtx
        ]


generateModule : Core.Module -> String
generateModule =
    generateC defaultOptions


collectDecls : GenCtx -> List Core.Decl -> GenCtx
collectDecls ctx decls =
    List.foldl collectDecl ctx decls


collectDecl : Core.Decl -> GenCtx -> GenCtx
collectDecl decl ctx =
    case decl of
        Core.FuncDecl funcDef ->
            { ctx | functions = Dict.insert funcDef.name funcDef ctx.functions }

        Core.DataDecl dataDef ->
            { ctx | dataTypes = Dict.insert dataDef.name dataDef ctx.dataTypes }

        Core.ClassDecl classDef ->
            { ctx | classes = Dict.insert classDef.name classDef ctx.classes }

        Core.InstDecl instDef ->
            { ctx | instances = instDef :: ctx.instances }



-- HEADER


generateHeader : GenCtx -> String
generateHeader ctx =
    String.join "\n"
        [ "/*"
        , " * Generated by tcelm v2 from " ++ ctx.moduleName
        , " * Target: " ++ ctx.options.targetName
        , " */"
        , ""
        , "#include <stdio.h>"
        , "#include <stdlib.h>"
        , "#include <string.h>"
        , "#include <stdint.h>"
        , "#include <stdbool.h>"
        ]



-- RUNTIME


generateRuntime : GenCtx -> String
generateRuntime _ =
    String.join "\n"
        [ "/* ===== RUNTIME ===== */"
        , ""
        , "/* Tagged union for algebraic data types */"
        , "typedef struct elm_value_s {"
        , "    uint32_t tag;"
        , "    union {"
        , "        int64_t i;"
        , "        double f;"
        , "        const char *s;"
        , "        void *p;"
        , "        struct elm_value_s *c;  /* child */"
        , "    } data;"
        , "    struct elm_value_s *next;   /* for lists, additional fields */"
        , "} elm_value_t;"
        , ""
        , "/* Closure for partial application */"
        , "typedef struct elm_closure_s {"
        , "    void *func;                 /* function pointer */"
        , "    uint8_t arity;              /* total arity */"
        , "    uint8_t applied;            /* args already applied */"
        , "    elm_value_t args[8];        /* captured arguments */"
        , "} elm_closure_t;"
        , ""
        , "/* Type class dictionary */"
        , "typedef struct elm_dict_s {"
        , "    void *methods[16];          /* method function pointers */"
        , "} elm_dict_t;"
        , ""
        , "/* Memory allocation */"
        , "static elm_value_t *elm_alloc(void) {"
        , "    return (elm_value_t *)malloc(sizeof(elm_value_t));"
        , "}"
        , ""
        , "static elm_closure_t *elm_alloc_closure(void) {"
        , "    return (elm_closure_t *)malloc(sizeof(elm_closure_t));"
        , "}"
        , ""
        , "/* Value constructors */"
        , "static elm_value_t elm_int(int64_t n) {"
        , "    return (elm_value_t){ .tag = 0, .data.i = n, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_float(double f) {"
        , "    return (elm_value_t){ .tag = 1, .data.f = f, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_string(const char *s) {"
        , "    return (elm_value_t){ .tag = 2, .data.s = s, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_char(char c) {"
        , "    return (elm_value_t){ .tag = 3, .data.i = (int64_t)c, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_bool(bool b) {"
        , "    return (elm_value_t){ .tag = b ? 5 : 4, .data.i = b, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_unit(void) {"
        , "    return (elm_value_t){ .tag = 6, .data.i = 0, .next = NULL };"
        , "}"
        , ""
        , "/* List operations */"
        , "static elm_value_t elm_nil(void) {"
        , "    return (elm_value_t){ .tag = 100, .data.p = NULL, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_cons(elm_value_t head, elm_value_t tail) {"
        , "    elm_value_t *h = elm_alloc();"
        , "    elm_value_t *t = elm_alloc();"
        , "    *h = head;"
        , "    *t = tail;"
        , "    return (elm_value_t){ .tag = 101, .data.c = h, .next = t };"
        , "}"
        , ""
        , "/* Maybe operations */"
        , "static elm_value_t elm_nothing(void) {"
        , "    return (elm_value_t){ .tag = 200, .data.p = NULL, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_just(elm_value_t val) {"
        , "    elm_value_t *v = elm_alloc();"
        , "    *v = val;"
        , "    return (elm_value_t){ .tag = 201, .data.c = v, .next = NULL };"
        , "}"
        , ""
        , "/* Result operations */"
        , "static elm_value_t elm_err(elm_value_t val) {"
        , "    elm_value_t *v = elm_alloc();"
        , "    *v = val;"
        , "    return (elm_value_t){ .tag = 300, .data.c = v, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_ok(elm_value_t val) {"
        , "    elm_value_t *v = elm_alloc();"
        , "    *v = val;"
        , "    return (elm_value_t){ .tag = 301, .data.c = v, .next = NULL };"
        , "}"
        , ""
        , "/* Closure application */"
        , "static elm_value_t elm_apply1(elm_closure_t *c, elm_value_t arg) {"
        , "    if (c->applied + 1 < c->arity) {"
        , "        /* Still partial - create new closure */"
        , "        elm_closure_t *c2 = elm_alloc_closure();"
        , "        *c2 = *c;"
        , "        c2->args[c2->applied++] = arg;"
        , "        return (elm_value_t){ .tag = 400, .data.p = c2, .next = NULL };"
        , "    }"
        , "    /* Full application */"
        , "    switch (c->arity) {"
        , "        case 1: return ((elm_value_t (*)(elm_value_t))c->func)(arg);"
        , "        case 2: return ((elm_value_t (*)(elm_value_t, elm_value_t))c->func)(c->args[0], arg);"
        , "        case 3: return ((elm_value_t (*)(elm_value_t, elm_value_t, elm_value_t))c->func)(c->args[0], c->args[1], arg);"
        , "        case 4: return ((elm_value_t (*)(elm_value_t, elm_value_t, elm_value_t, elm_value_t))c->func)(c->args[0], c->args[1], c->args[2], arg);"
        , "        default: return elm_unit();"
        , "    }"
        , "}"
        , ""
        , "/* String operations */"
        , "static elm_value_t elm_str_append(elm_value_t a, elm_value_t b) {"
        , "    size_t la = strlen(a.data.s);"
        , "    size_t lb = strlen(b.data.s);"
        , "    char *buf = malloc(la + lb + 1);"
        , "    memcpy(buf, a.data.s, la);"
        , "    memcpy(buf + la, b.data.s, lb + 1);"
        , "    return elm_string(buf);"
        , "}"
        , ""
        , "static elm_value_t elm_str_length(elm_value_t s) {"
        , "    return elm_int((int64_t)strlen(s.data.s));"
        , "}"
        , ""
        , "/* Arithmetic */"
        , "static elm_value_t elm_add(elm_value_t a, elm_value_t b) {"
        , "    return elm_int(a.data.i + b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_sub(elm_value_t a, elm_value_t b) {"
        , "    return elm_int(a.data.i - b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_mul(elm_value_t a, elm_value_t b) {"
        , "    return elm_int(a.data.i * b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_div(elm_value_t a, elm_value_t b) {"
        , "    return elm_int(a.data.i / b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_mod(elm_value_t a, elm_value_t b) {"
        , "    return elm_int(a.data.i % b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_intDiv(elm_value_t a, elm_value_t b) {"
        , "    return elm_int(a.data.i / b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_pow(elm_value_t a, elm_value_t b) {"
        , "    int64_t result = 1;"
        , "    int64_t base = a.data.i;"
        , "    int64_t exp = b.data.i;"
        , "    while (exp > 0) { if (exp & 1) result *= base; base *= base; exp >>= 1; }"
        , "    return elm_int(result);"
        , "}"
        , ""
        , "/* Comparison */"
        , "static elm_value_t elm_eq(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i == b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_neq(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i != b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_lt(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i < b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_gt(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i > b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_lte(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i <= b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_gte(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i >= b.data.i);"
        , "}"
        , ""
        , "/* Boolean */"
        , "static elm_value_t elm_and(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i && b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_or(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i || b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_not(elm_value_t a) {"
        , "    return elm_bool(!a.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_negate(elm_value_t a) {"
        , "    return elm_int(-a.data.i);"
        , "}"
        ]



-- TYPE DECLARATIONS


generateTypeDecls : GenCtx -> String
generateTypeDecls ctx =
    let
        dataDecls =
            ctx.dataTypes
                |> Dict.values
                |> List.map (generateDataType ctx)
                |> String.join "\n\n"

        classDecls =
            ctx.classes
                |> Dict.values
                |> List.map (generateClassDecl ctx)
                |> String.join "\n\n"
    in
    if String.isEmpty dataDecls && String.isEmpty classDecls then
        ""
    else
        "/* ===== TYPES ===== */\n\n" ++ dataDecls ++ "\n\n" ++ classDecls


generateDataType : GenCtx -> Core.DataDef -> String
generateDataType ctx dataDef =
    let
        tagDefs =
            dataDef.constructors
                |> List.map (\ctor ->
                    "#define TAG_" ++ dataDef.name ++ "_" ++ ctor.name ++ " " ++ String.fromInt (1000 + ctor.tag)
                )
                |> String.join "\n"

        ctorFuncs =
            dataDef.constructors
                |> List.map (generateConstructor ctx dataDef.name)
                |> String.join "\n\n"
    in
    "/* " ++ dataDef.name ++ " type tags */\n" ++ tagDefs ++ "\n\n" ++ ctorFuncs


generateConstructor : GenCtx -> String -> Core.DataConDef -> String
generateConstructor _ typeName ctor =
    let
        tag = "TAG_" ++ typeName ++ "_" ++ ctor.name
    in
    if ctor.fields == [] then
        -- Nullary constructor
        "static elm_value_t elm_" ++ ctor.name ++ "(void) {\n"
            ++ "    return (elm_value_t){ .tag = " ++ tag ++ ", .data.p = NULL, .next = NULL };\n"
            ++ "}"
    else if List.length ctor.fields == 1 then
        -- Unary constructor
        "static elm_value_t elm_" ++ ctor.name ++ "(elm_value_t v0) {\n"
            ++ "    elm_value_t *p = elm_alloc();\n"
            ++ "    *p = v0;\n"
            ++ "    return (elm_value_t){ .tag = " ++ tag ++ ", .data.c = p, .next = NULL };\n"
            ++ "}"
    else
        -- Multi-arg constructor
        let
            params =
                List.indexedMap (\i _ -> "elm_value_t v" ++ String.fromInt i) ctor.fields
                    |> String.join ", "

            body =
                List.indexedMap
                    (\i _ ->
                        "    elm_value_t *p" ++ String.fromInt i ++ " = elm_alloc();\n"
                            ++ "    *p" ++ String.fromInt i ++ " = v" ++ String.fromInt i ++ ";"
                    )
                    ctor.fields
                    |> String.join "\n"

            -- Chain them together
            chainSetup =
                List.indexedMap
                    (\i _ ->
                        if i < List.length ctor.fields - 1 then
                            "    p" ++ String.fromInt i ++ "->next = p" ++ String.fromInt (i + 1) ++ ";"
                        else
                            ""
                    )
                    ctor.fields
                    |> List.filter (not << String.isEmpty)
                    |> String.join "\n"
        in
        "static elm_value_t elm_" ++ ctor.name ++ "(" ++ params ++ ") {\n"
            ++ body ++ "\n"
            ++ chainSetup ++ "\n"
            ++ "    return (elm_value_t){ .tag = " ++ tag ++ ", .data.c = p0, .next = NULL };\n"
            ++ "}"


generateClassDecl : GenCtx -> Core.ClassDef -> String
generateClassDecl _ classDef =
    let
        methodSlots =
            classDef.methods
                |> List.indexedMap (\i ( name, _ ) ->
                    "#define SLOT_" ++ classDef.name ++ "_" ++ name ++ " " ++ String.fromInt i
                )
                |> String.join "\n"
    in
    "/* " ++ classDef.name ++ " type class */\n" ++ methodSlots



-- FORWARD DECLARATIONS


generateForwardDecls : GenCtx -> String
generateForwardDecls ctx =
    let
        decls =
            ctx.functions
                |> Dict.values
                |> List.map (generateForwardDecl ctx)
                |> String.join "\n"
    in
    if String.isEmpty decls then
        ""
    else
        "/* ===== FORWARD DECLARATIONS ===== */\n" ++ decls


generateForwardDecl : GenCtx -> Core.FuncDef -> String
generateForwardDecl ctx funcDef =
    let
        params =
            if List.isEmpty funcDef.args then
                "void"
            else
                funcDef.args
                    |> List.map (\tv -> "elm_value_t " ++ mangle tv.name)
                    |> String.join ", "
    in
    "static elm_value_t " ++ mangle (ctx.moduleName ++ "_" ++ funcDef.name) ++ "(" ++ params ++ ");"



-- FUNCTIONS


{-| Generate all functions, accumulating lifted lambdas in the context.
Returns (function code, updated context with lifted lambdas).
-}
generateFunctionsWithLambdas : GenCtx -> ( String, GenCtx )
generateFunctionsWithLambdas ctx =
    let
        funcDefs = Dict.values ctx.functions

        -- Generate each function, threading the context through
        ( funcCodes, finalCtx ) =
            List.foldl
                (\funcDef ( codes, accCtx ) ->
                    let
                        ( code, newCtx ) = generateFunctionWithLambdas accCtx funcDef
                    in
                    ( codes ++ [ code ], newCtx )
                )
                ( [], ctx )
                funcDefs
    in
    ( String.join "\n\n" funcCodes, finalCtx )


{-| Generate a single function, accumulating any lifted lambdas.
-}
generateFunctionWithLambdas : GenCtx -> Core.FuncDef -> ( String, GenCtx )
generateFunctionWithLambdas ctx funcDef =
    let
        fullName = mangle (ctx.moduleName ++ "_" ++ funcDef.name)

        params =
            if List.isEmpty funcDef.args then
                "void"
            else
                funcDef.args
                    |> List.map (\tv -> "elm_value_t " ++ mangle tv.name)
                    |> String.join ", "

        -- Track function parameters as potential closures
        paramNames = List.map .name funcDef.args
        bodyCtx =
            { ctx
            | indent = ctx.indent + 1
            , closureParams = Set.union ctx.closureParams (Set.fromList paramNames)
            }

        ( bodyCode, finalCtx ) = generateExprAccum bodyCtx Dict.empty funcDef.body

        funcCode =
            "static elm_value_t " ++ fullName ++ "(" ++ params ++ ") {\n"
                ++ indentStr bodyCtx ++ "return " ++ bodyCode ++ ";\n"
                ++ "}"
    in
    ( funcCode, finalCtx )


-- Keep the old generateFunctions for backwards compatibility (not used in main path)
generateFunctions : GenCtx -> String
generateFunctions ctx =
    let
        ( code, _ ) = generateFunctionsWithLambdas ctx
    in
    code


generateFunction : GenCtx -> Core.FuncDef -> String
generateFunction ctx funcDef =
    let
        ( code, _ ) = generateFunctionWithLambdas ctx funcDef
    in
    code



-- EXPRESSIONS


{-| Generate expression code, accumulating lifted lambdas in context.
Returns (generated code, updated context).
-}
generateExprAccum : GenCtx -> Dict String String -> Core.Expr -> ( String, GenCtx )
generateExprAccum ctx renames expr =
    case expr of
        Core.EVar tv ->
            let
                name = tv.name
            in
            case Dict.get name renames of
                Just renamed ->
                    ( renamed, ctx )

                Nothing ->
                    let
                        mangledName = mangleWithModule ctx name
                        arity = getFunctionArity ctx name
                    in
                    if Set.member name ctx.closureParams then
                        ( mangledName, ctx )
                    else if Dict.member name ctx.functions && arity > 0 then
                        ( generateFunctionClosure ctx mangledName arity, ctx )
                    else if arity == 0 && Dict.member name ctx.functions then
                        ( mangledName ++ "()", ctx )
                    else
                        ( mangledName, ctx )

        Core.ELit lit _ ->
            ( generateLiteral lit, ctx )

        Core.EApp func arg _ ->
            generateAppAccum ctx renames func arg

        Core.ELam tv body _ ->
            generateLambdaAccum ctx renames tv body

        Core.ELet var value body _ ->
            generateLetAccum ctx renames var value body

        Core.ELetRec bindings body _ ->
            generateLetRecAccum ctx renames bindings body

        Core.ECase scrutinee alts _ ->
            generateCaseAccum ctx renames scrutinee alts

        Core.ECon name args _ ->
            generateConAccum ctx renames name args

        Core.ETuple exprs _ ->
            generateTupleAccum ctx renames exprs

        Core.ERecord fields _ ->
            generateRecordAccum ctx renames fields

        Core.ERecordAccess record field _ ->
            let
                ( recordCode, ctx1 ) = generateExprAccum ctx renames record
            in
            ( "((" ++ recordCode ++ ").data.p->" ++ field ++ ")", ctx1 )

        Core.ERecordUpdate record _ _ ->
            generateExprAccum ctx renames record

        Core.ETyApp e _ _ ->
            generateExprAccum ctx renames e

        Core.ETyLam _ e _ ->
            generateExprAccum ctx renames e

        Core.EDictApp func dict _ ->
            let
                ( funcCode, ctx1 ) = generateExprAccum ctx renames func
                ( dictCode, ctx2 ) = generateExprAccum ctx1 renames dict
            in
            ( funcCode ++ "(" ++ dictCode ++ ")", ctx2 )

        Core.EDictLam tv body _ ->
            generateLambdaAccum ctx renames tv body

        Core.EDict className _ _ ->
            ( "(elm_dict_t *)&dict_" ++ className, ctx )


{-| Generate a lambda as a top-level static function.
Adds the function to liftedLambdas and returns the closure creation code.
-}
generateLambdaAccum : GenCtx -> Dict String String -> Core.TypedVar -> Core.Expr -> ( String, GenCtx )
generateLambdaAccum ctx renames tv body =
    let
        ( funcName, ctx1 ) = freshName "__lambda" ctx
        argName = mangle tv.name

        -- Compute free variables
        bodyFreeVars = Core.freeVars body
        freeVarsExcludingParam = Set.remove tv.name bodyFreeVars

        captures =
            freeVarsExcludingParam
                |> Set.filter (\v ->
                    not (Dict.member v ctx1.functions)
                        && not (isBuiltin v)
                )
                |> Set.toList

        numCaptures = List.length captures

        -- Parameters for the lifted function
        captureParams =
            captures
                |> List.indexedMap (\i _ -> "elm_value_t _cap" ++ String.fromInt i)

        allParams = captureParams ++ [ "elm_value_t " ++ argName ]
        paramsStr = String.join ", " allParams

        -- Renames for the lambda body
        innerRenames =
            captures
                |> List.indexedMap (\i name -> ( name, "_cap" ++ String.fromInt i ))
                |> Dict.fromList

        bodyCtx =
            { ctx1
            | closureParams = Set.insert tv.name ctx1.closureParams
            , localVars = Set.union ctx1.localVars (Set.fromList captures)
            }

        -- Generate body with accumulated lambdas
        ( bodyCode, ctx2 ) = generateExprAccum bodyCtx innerRenames body

        -- Create the lifted lambda definition
        lambdaDef =
            "static elm_value_t " ++ funcName ++ "(" ++ paramsStr ++ ") {\n"
                ++ "    return " ++ bodyCode ++ ";\n"
                ++ "}"

        -- Add to lifted lambdas
        ctx3 =
            { ctx2
            | liftedLambdas = { name = funcName, definition = lambdaDef } :: ctx2.liftedLambdas
            }

        -- Generate closure creation code
        captureAssignments =
            captures
                |> List.indexedMap (\i name ->
                    let
                        sourceValue =
                            case Dict.get name renames of
                                Just outerRenamed -> outerRenamed
                                Nothing -> mangle name
                    in
                    "_c->args[" ++ String.fromInt i ++ "] = " ++ sourceValue ++ ";"
                )
                |> String.join " "

        totalArity = numCaptures + 1

        closureCode =
            "({"
                ++ " elm_closure_t *_c = elm_alloc_closure();"
                ++ " _c->func = (void *)" ++ funcName ++ ";"
                ++ " _c->arity = " ++ String.fromInt totalArity ++ ";"
                ++ " _c->applied = " ++ String.fromInt numCaptures ++ ";"
                ++ " " ++ captureAssignments
                ++ " (elm_value_t){ .tag = 400, .data.p = _c, .next = NULL };"
                ++ " })"
    in
    ( closureCode, ctx3 )


generateAppAccum : GenCtx -> Dict String String -> Core.Expr -> Core.Expr -> ( String, GenCtx )
generateAppAccum ctx renames func arg =
    let
        ( baseFunc, allArgs ) = collectArgs func [ arg ]
    in
    case baseFunc of
        Core.EVar tv ->
            let
                funcName = tv.name
            in
            case Dict.get funcName renames of
                Just renamed ->
                    generateClosureApplyAccum ctx renames renamed allArgs

                Nothing ->
                    let
                        mangledName = mangleWithModule ctx funcName
                        isKnownFunction = Dict.member funcName ctx.functions || isBuiltin funcName
                    in
                    if Set.member funcName ctx.closureParams || not isKnownFunction then
                        generateClosureApplyAccum ctx renames mangledName allArgs
                    else
                        let
                            arity = getFunctionArity ctx funcName
                            argCount = List.length allArgs
                        in
                        if arity == 0 then
                            generateClosureApplyAccum ctx renames (mangledName ++ "()") allArgs
                        else if argCount == arity then
                            -- Full application
                            let
                                ( argCodes, finalCtx ) =
                                    List.foldl
                                        (\a ( codes, accCtx ) ->
                                            let
                                                ( code, newCtx ) = generateExprAccum accCtx renames a
                                            in
                                            ( codes ++ [ code ], newCtx )
                                        )
                                        ( [], ctx )
                                        allArgs
                            in
                            ( mangledName ++ "(" ++ String.join ", " argCodes ++ ")", finalCtx )
                        else if argCount < arity then
                            generatePartialAppAccum ctx renames mangledName allArgs arity
                        else
                            let
                                ( directArgs, extraArgs ) = splitAt arity allArgs
                                ( directCodes, ctx1 ) =
                                    List.foldl
                                        (\a ( codes, accCtx ) ->
                                            let
                                                ( code, newCtx ) = generateExprAccum accCtx renames a
                                            in
                                            ( codes ++ [ code ], newCtx )
                                        )
                                        ( [], ctx )
                                        directArgs
                                baseCall = mangledName ++ "(" ++ String.join ", " directCodes ++ ")"
                            in
                            generateClosureApplyAccum ctx1 renames baseCall extraArgs

        Core.ECon name existingArgs _ ->
            generateConAccum ctx renames name (existingArgs ++ allArgs)

        _ ->
            let
                ( baseFuncCode, ctx1 ) = generateExprAccum ctx renames baseFunc
                ( argCode, ctx2 ) = generateExprAccum ctx1 renames arg
            in
            ( "elm_apply1((elm_closure_t *)(" ++ baseFuncCode ++ ").data.p, " ++ argCode ++ ")", ctx2 )


generateClosureApplyAccum : GenCtx -> Dict String String -> String -> List Core.Expr -> ( String, GenCtx )
generateClosureApplyAccum ctx renames closureExpr args =
    case args of
        [] ->
            ( closureExpr, ctx )

        arg :: rest ->
            let
                ( argCode, ctx1 ) = generateExprAccum ctx renames arg
                applied = "elm_apply1((elm_closure_t *)(" ++ closureExpr ++ ").data.p, " ++ argCode ++ ")"
            in
            generateClosureApplyAccum ctx1 renames applied rest


generatePartialAppAccum : GenCtx -> Dict String String -> String -> List Core.Expr -> Int -> ( String, GenCtx )
generatePartialAppAccum ctx renames funcName args arity =
    let
        ( argAssignments, finalCtx ) =
            List.foldl
                (\( i, a ) ( assigns, accCtx ) ->
                    let
                        ( argCode, newCtx ) = generateExprAccum accCtx renames a
                    in
                    ( assigns ++ [ "_c->args[" ++ String.fromInt i ++ "] = " ++ argCode ++ ";" ], newCtx )
                )
                ( [], ctx )
                (List.indexedMap Tuple.pair args)

        resultCode =
            "({"
                ++ " elm_closure_t *_c = elm_alloc_closure();"
                ++ " _c->func = (void *)" ++ funcName ++ ";"
                ++ " _c->arity = " ++ String.fromInt arity ++ ";"
                ++ " _c->applied = " ++ String.fromInt (List.length args) ++ ";"
                ++ " " ++ String.join " " argAssignments
                ++ " (elm_value_t){ .tag = 400, .data.p = _c, .next = NULL };"
                ++ " })"
    in
    ( resultCode, finalCtx )


generateLetAccum : GenCtx -> Dict String String -> String -> Core.Expr -> Core.Expr -> ( String, GenCtx )
generateLetAccum ctx renames var value body =
    let
        ( valueCode, ctx1 ) = generateExprAccum ctx renames value
        bodyRenames = Dict.remove var renames
        ( bodyCode, ctx2 ) = generateExprAccum ctx1 bodyRenames body
    in
    ( "({ elm_value_t " ++ mangle var ++ " = " ++ valueCode ++ "; " ++ bodyCode ++ "; })", ctx2 )


generateLetRecAccum : GenCtx -> Dict String String -> List ( String, Core.Expr ) -> Core.Expr -> ( String, GenCtx )
generateLetRecAccum ctx renames bindings body =
    let
        boundNames = List.map Tuple.first bindings
        innerRenames = List.foldl Dict.remove renames boundNames

        decls =
            bindings
                |> List.map (\( name, _ ) -> "elm_value_t " ++ mangle name ++ ";")
                |> String.join " "

        ( assigns, ctx1 ) =
            List.foldl
                (\( name, e ) ( strs, accCtx ) ->
                    let
                        ( code, newCtx ) = generateExprAccum accCtx innerRenames e
                    in
                    ( strs ++ [ mangle name ++ " = " ++ code ++ ";" ], newCtx )
                )
                ( [], ctx )
                bindings

        ( bodyCode, ctx2 ) = generateExprAccum ctx1 innerRenames body
    in
    ( "({ " ++ decls ++ " " ++ String.join " " assigns ++ " " ++ bodyCode ++ "; })", ctx2 )


generateCaseAccum : GenCtx -> Dict String String -> Core.Expr -> List Core.Alt -> ( String, GenCtx )
generateCaseAccum ctx renames scrutinee alts =
    let
        ( scrutCode, ctx1 ) = generateExprAccum ctx renames scrutinee
        ( scrutVar, ctx2 ) = freshName "scrut" ctx1
        ( resultVar, ctx3 ) = freshName "result" ctx2

        ( branches, ctx4 ) =
            List.foldl
                (\alt ( strs, accCtx ) ->
                    let
                        ( code, newCtx ) = generateAltAccum accCtx renames scrutVar resultVar alt
                    in
                    ( strs ++ [ code ], newCtx )
                )
                ( [], ctx3 )
                alts
    in
    ( "({ elm_value_t " ++ scrutVar ++ " = " ++ scrutCode ++ "; elm_value_t " ++ resultVar ++ "; " ++ String.join " else " branches ++ " " ++ resultVar ++ "; })", ctx4 )


generateAltAccum : GenCtx -> Dict String String -> String -> String -> Core.Alt -> ( String, GenCtx )
generateAltAccum ctx renames scrutVar resultVar (Core.Alt pattern guard body) =
    let
        ( condition, bindings ) = patternCondition ctx scrutVar pattern

        ( guardCode, ctx1 ) =
            case guard of
                Nothing ->
                    ( "", ctx )

                Just g ->
                    let
                        ( code, newCtx ) = generateExprAccum ctx renames g
                    in
                    ( " && (" ++ code ++ ").data.i", newCtx )

        ( bodyCode, ctx2 ) = generateExprAccum ctx1 renames body
    in
    ( "if (" ++ condition ++ guardCode ++ ") { " ++ bindings ++ resultVar ++ " = " ++ bodyCode ++ "; }", ctx2 )


generateConAccum : GenCtx -> Dict String String -> String -> List Core.Expr -> ( String, GenCtx )
generateConAccum ctx renames name args =
    let
        ( argCodes, finalCtx ) =
            List.foldl
                (\a ( codes, accCtx ) ->
                    let
                        ( argCode, newCtx ) = generateExprAccum accCtx renames a
                    in
                    ( codes ++ [ argCode ], newCtx )
                )
                ( [], ctx )
                args

        funcName =
            case name of
                "Nil" -> "elm_nil"
                "Cons" -> "elm_cons"
                "Nothing" -> "elm_nothing"
                "Just" -> "elm_just"
                "Ok" -> "elm_ok"
                "Err" -> "elm_err"
                "True" -> "elm_bool(true)"
                "False" -> "elm_bool(false)"
                _ -> "elm_" ++ name

        resultCode =
            if List.isEmpty args && (name == "True" || name == "False") then
                funcName
            else
                funcName ++ "(" ++ String.join ", " argCodes ++ ")"
    in
    ( resultCode, finalCtx )


generateTupleAccum : GenCtx -> Dict String String -> List Core.Expr -> ( String, GenCtx )
generateTupleAccum ctx renames exprs =
    case exprs of
        [] ->
            ( "elm_unit()", ctx )

        [ single ] ->
            generateExprAccum ctx renames single

        first :: rest ->
            let
                ( firstCode, ctx1 ) = generateExprAccum ctx renames first
                ( restCode, ctx2 ) = generateTupleAccum ctx1 renames rest
            in
            ( "elm_cons(" ++ firstCode ++ ", " ++ restCode ++ ")", ctx2 )


generateRecordAccum : GenCtx -> Dict String String -> List ( String, Core.Expr ) -> ( String, GenCtx )
generateRecordAccum ctx renames fields =
    let
        ( fieldCodes, finalCtx ) =
            List.foldl
                (\( name, e ) ( codes, accCtx ) ->
                    let
                        ( code, newCtx ) = generateExprAccum accCtx renames e
                    in
                    ( codes ++ [ "." ++ name ++ " = " ++ code ], newCtx )
                )
                ( [], ctx )
                fields

        fieldDecls = List.map (\( n, _ ) -> "elm_value_t " ++ n) fields
    in
    ( "((elm_value_t){ .tag = 500, .data.p = &(struct { " ++ String.join "; " fieldDecls ++ "; }){ " ++ String.join ", " fieldCodes ++ " }, .next = NULL })", finalCtx )


-- Old non-accumulating versions (kept for compatibility)
generateExpr : GenCtx -> Core.Expr -> String
generateExpr ctx expr =
    let
        ( code, _ ) = generateExprAccum ctx Dict.empty expr
    in
    code


generateLiteral : Core.Literal -> String
generateLiteral lit =
    case lit of
        Core.LInt n ->
            "elm_int(" ++ String.fromInt n ++ ")"

        Core.LFloat f ->
            "elm_float(" ++ String.fromFloat f ++ ")"

        Core.LString s ->
            "elm_string(\"" ++ escapeString s ++ "\")"

        Core.LChar c ->
            "elm_char('" ++ escapeChar c ++ "')"


generateApp : GenCtx -> Core.Expr -> Core.Expr -> String
generateApp ctx func arg =
    -- Collect all arguments from nested applications
    let
        ( baseFunc, allArgs ) = collectArgs func [ arg ]
    in
    case baseFunc of
        Core.EVar tv ->
            let
                funcName = tv.name
                mangledName = mangleWithModule ctx funcName
                isKnownFunction = Dict.member funcName ctx.functions || isBuiltin funcName
            in
            -- Check if this is a closure parameter or local variable (not a known function)
            if Set.member funcName ctx.closureParams || not isKnownFunction then
                -- Function parameter or local variable - use closure application
                generateClosureApply ctx mangledName allArgs
            else
                -- Known function or builtin
                let
                    arity = getFunctionArity ctx funcName
                    argCount = List.length allArgs
                in
                if arity == 0 then
                    -- Zero-arity function returns a closure - call it and apply args
                    generateClosureApply ctx (mangledName ++ "()") allArgs
                else if argCount == arity then
                    -- Full application - generate direct call
                    mangledName ++ "(" ++ String.join ", " (List.map (generateExpr ctx) allArgs) ++ ")"
                else if argCount < arity then
                    -- Partial application - generate closure
                    generatePartialApp ctx mangledName allArgs arity
                else
                    -- Over-application - call function, then apply extra args to result
                    let
                        ( directArgs, extraArgs ) = splitAt arity allArgs
                        baseCall = mangledName ++ "(" ++ String.join ", " (List.map (generateExpr ctx) directArgs) ++ ")"
                    in
                    generateClosureApply ctx baseCall extraArgs

        Core.ECon name existingArgs _ ->
            -- Constructor application - collect args and generate direct call
            generateCon ctx name (existingArgs ++ allArgs)

        _ ->
            -- Dynamic application (closure)
            "elm_apply1((elm_closure_t *)(" ++ generateExpr ctx baseFunc ++ ").data.p, " ++ generateExpr ctx arg ++ ")"


{-| Apply arguments to a closure expression one at a time.
-}
generateClosureApply : GenCtx -> String -> List Core.Expr -> String
generateClosureApply ctx closureExpr args =
    case args of
        [] ->
            closureExpr

        arg :: rest ->
            let
                applied = "elm_apply1((elm_closure_t *)(" ++ closureExpr ++ ").data.p, " ++ generateExpr ctx arg ++ ")"
            in
            generateClosureApply ctx applied rest


{-| Split a list at index n.
-}
splitAt : Int -> List a -> ( List a, List a )
splitAt n xs =
    ( List.take n xs, List.drop n xs )


{-| Collect all arguments from nested EApp nodes.
-}
collectArgs : Core.Expr -> List Core.Expr -> ( Core.Expr, List Core.Expr )
collectArgs expr args =
    case expr of
        Core.EApp innerFunc innerArg _ ->
            collectArgs innerFunc (innerArg :: args)

        _ ->
            ( expr, args )


{-| Get the arity of a known function.
-}
getFunctionArity : GenCtx -> String -> Int
getFunctionArity ctx name =
    case name of
        -- Binary operators (symbolic)
        "+" -> 2
        "-" -> 2
        "*" -> 2
        "/" -> 2
        "//" -> 2
        "^" -> 2
        "==" -> 2
        "/=" -> 2
        "<" -> 2
        ">" -> 2
        "<=" -> 2
        ">=" -> 2
        "&&" -> 2
        "||" -> 2
        "++" -> 2
        "::" -> 2
        "|>" -> 2
        "<|" -> 2
        ">>" -> 2
        "<<" -> 2

        -- Binary operators (desugared names from Desugar.elm)
        "add" -> 2
        "sub" -> 2
        "mul" -> 2
        "div" -> 2
        "intDiv" -> 2
        "pow" -> 2
        "mod" -> 2
        "eq" -> 2
        "neq" -> 2
        "lt" -> 2
        "gt" -> 2
        "lte" -> 2
        "gte" -> 2
        "and" -> 2
        "or" -> 2
        "append" -> 2
        "cons" -> 2
        "pipe" -> 2
        "pipeLeft" -> 2
        "compose" -> 2
        "composeLeft" -> 2

        -- Unary functions
        "not" -> 1
        "negate" -> 1

        -- User-defined functions - get arity from definition
        _ ->
            case Dict.get name ctx.functions of
                Just funcDef ->
                    List.length funcDef.args

                Nothing ->
                    -- Unknown function, assume unary
                    1


{-| Generate a closure wrapping a known function (for passing as value).
-}
generateFunctionClosure : GenCtx -> String -> Int -> String
generateFunctionClosure _ funcName arity =
    "({"
        ++ " elm_closure_t *_c = elm_alloc_closure();"
        ++ " _c->func = (void *)" ++ funcName ++ ";"
        ++ " _c->arity = " ++ String.fromInt arity ++ ";"
        ++ " _c->applied = 0;"
        ++ " (elm_value_t){ .tag = 400, .data.p = _c, .next = NULL };"
        ++ " })"


{-| Generate partial application as a closure.
-}
generatePartialApp : GenCtx -> String -> List Core.Expr -> Int -> String
generatePartialApp ctx funcName args arity =
    let
        argsCode =
            args
                |> List.indexedMap (\i a -> "_c->args[" ++ String.fromInt i ++ "] = " ++ generateExpr ctx a ++ ";")
                |> String.join " "
    in
    "({"
        ++ " elm_closure_t *_c = elm_alloc_closure();"
        ++ " _c->func = (void *)" ++ funcName ++ ";"
        ++ " _c->arity = " ++ String.fromInt arity ++ ";"
        ++ " _c->applied = " ++ String.fromInt (List.length args) ++ ";"
        ++ " " ++ argsCode
        ++ " (elm_value_t){ .tag = 400, .data.p = _c, .next = NULL };"
        ++ " })"


{-| Mangle a name with the module prefix if it's a local function.
-}
mangleWithModule : GenCtx -> String -> String
mangleWithModule ctx name =
    if isBuiltin name then
        mangle name
    else if Dict.member name ctx.functions then
        mangle (ctx.moduleName ++ "_" ++ name)
    else
        mangle name


{-| Check if a name is a builtin operator/function.
    Includes both symbolic operators and their desugared names.
-}
isBuiltin : String -> Bool
isBuiltin name =
    List.member name
        -- Symbolic operators
        [ "+", "-", "*", "/", "//", "^", "%"
        , "==", "/=", "<", ">", "<=", ">="
        , "&&", "||", "not", "negate"
        , "++", "::"
        , "|>", "<|", ">>", "<<"
        , "True", "False"
        -- Desugared operator names (from Desugar.elm desugarBinOp)
        , "add", "sub", "mul", "div", "intDiv", "pow", "mod"
        , "eq", "neq", "lt", "gt", "lte", "gte"
        , "and", "or"
        , "append", "cons"
        , "pipe", "pipeLeft", "compose", "composeLeft"
        ]


generateLambda : GenCtx -> Core.TypedVar -> Core.Expr -> String
generateLambda ctx tv body =
    -- Generate lambda with proper closure capture.
    -- Captured variables are passed as explicit parameters and stored in the closure's args[].
    -- This works with both GCC and TCC (no reliance on implicit stack capture).
    let
        ( funcName, ctx1 ) = freshName "lambda" ctx
        argName = mangle tv.name

        -- Compute free variables in the body (excluding the lambda param, known functions, and builtins)
        bodyFreeVars = Core.freeVars body
        freeVarsExcludingParam = Set.remove tv.name bodyFreeVars

        -- Filter out known top-level functions and builtins
        captures =
            freeVarsExcludingParam
                |> Set.filter (\v ->
                    not (Dict.member v ctx1.functions)
                        && not (isBuiltin v)
                )
                |> Set.toList

        numCaptures = List.length captures

        -- Generate parameter list for the nested function: (cap0, cap1, ..., arg)
        captureParams =
            captures
                |> List.indexedMap (\i _ -> "elm_value_t _cap" ++ String.fromInt i)

        allParams = captureParams ++ [ "elm_value_t " ++ argName ]
        paramsStr = String.join ", " allParams

        -- In the function body, we need to reference captures by their parameter names
        -- Create a context where capture names map to _cap0, _cap1, etc.
        captureRenames =
            captures
                |> List.indexedMap (\i name -> ( name, "_cap" ++ String.fromInt i ))
                |> Dict.fromList

        -- Add the lambda parameter to closureParams
        bodyCtx =
            { ctx1
            | closureParams = Set.insert tv.name ctx1.closureParams
            , localVars = Set.union ctx1.localVars (Set.fromList captures)
            }

        -- Generate body code with capture renaming
        bodyCode = generateExprWithRenames bodyCtx captureRenames body

        -- Store captured values in args[]
        captureAssignments =
            captures
                |> List.indexedMap (\i name ->
                    "_c->args[" ++ String.fromInt i ++ "] = " ++ mangle name ++ ";"
                )
                |> String.join " "

        totalArity = numCaptures + 1
    in
    "({"
        ++ " elm_value_t " ++ funcName ++ "(" ++ paramsStr ++ ") { return " ++ bodyCode ++ "; }"
        ++ " elm_closure_t *_c = elm_alloc_closure();"
        ++ " _c->func = (void *)" ++ funcName ++ ";"
        ++ " _c->arity = " ++ String.fromInt totalArity ++ ";"
        ++ " _c->applied = " ++ String.fromInt numCaptures ++ ";"
        ++ " " ++ captureAssignments
        ++ " (elm_value_t){ .tag = 400, .data.p = _c, .next = NULL };"
        ++ " })"


{-| Generate expression code with variable renaming for captured variables.
-}
generateExprWithRenames : GenCtx -> Dict String String -> Core.Expr -> String
generateExprWithRenames ctx renames expr =
    case expr of
        Core.EVar tv ->
            let
                name = tv.name
            in
            case Dict.get name renames of
                Just renamed ->
                    -- This is a captured variable, use the renamed parameter directly
                    renamed

                Nothing ->
                    -- Not renamed, use normal generation
                    let
                        mangledName = mangleWithModule ctx name
                        arity = getFunctionArity ctx name
                    in
                    if Set.member name ctx.closureParams then
                        mangledName
                    else if Dict.member name ctx.functions && arity > 0 then
                        generateFunctionClosure ctx mangledName arity
                    else if arity == 0 && Dict.member name ctx.functions then
                        mangledName ++ "()"
                    else
                        mangledName

        Core.ELit lit _ ->
            generateLiteral lit

        Core.EApp func arg _ ->
            generateAppWithRenames ctx renames func arg

        Core.ELam innerTv innerBody _ ->
            generateLambdaWithRenames ctx renames innerTv innerBody

        Core.ELet var value body _ ->
            let
                valueCode = generateExprWithRenames ctx renames value
                -- Remove var from renames in case it shadows a captured var
                bodyRenames = Dict.remove var renames
                bodyCode = generateExprWithRenames ctx bodyRenames body
            in
            "({ elm_value_t " ++ mangle var ++ " = " ++ valueCode ++ "; " ++ bodyCode ++ "; })"

        Core.ELetRec bindings body _ ->
            let
                boundNames = List.map Tuple.first bindings
                -- Remove all bound names from renames
                innerRenames = List.foldl Dict.remove renames boundNames

                decls =
                    bindings
                        |> List.map (\( name, _ ) -> "elm_value_t " ++ mangle name ++ ";")
                        |> String.join " "

                assigns =
                    bindings
                        |> List.map (\( name, e ) ->
                            mangle name ++ " = " ++ generateExprWithRenames ctx innerRenames e ++ ";"
                        )
                        |> String.join " "

                bodyCode = generateExprWithRenames ctx innerRenames body
            in
            "({ " ++ decls ++ " " ++ assigns ++ " " ++ bodyCode ++ "; })"

        Core.ECase scrutinee alts _ ->
            generateCaseWithRenames ctx renames scrutinee alts

        Core.ECon name args _ ->
            generateConWithRenames ctx renames name args

        Core.ETuple exprs _ ->
            generateTupleWithRenames ctx renames exprs

        Core.ERecord fields _ ->
            generateRecordWithRenames ctx renames fields

        Core.ERecordAccess record field _ ->
            let
                recordCode = generateExprWithRenames ctx renames record
            in
            "((" ++ recordCode ++ ").data.p->" ++ field ++ ")"

        Core.ERecordUpdate record fields _ ->
            generateExprWithRenames ctx renames record

        Core.ETyApp e _ _ ->
            generateExprWithRenames ctx renames e

        Core.ETyLam _ e _ ->
            generateExprWithRenames ctx renames e

        Core.EDictApp func dict _ ->
            generateExprWithRenames ctx renames func ++ "(" ++ generateExprWithRenames ctx renames dict ++ ")"

        Core.EDictLam innerTv innerBody _ ->
            generateLambdaWithRenames ctx renames innerTv innerBody

        Core.EDict className _ _ ->
            "(elm_dict_t *)&dict_" ++ className


generateAppWithRenames : GenCtx -> Dict String String -> Core.Expr -> Core.Expr -> String
generateAppWithRenames ctx renames func arg =
    let
        ( baseFunc, allArgs ) = collectArgs func [ arg ]
    in
    case baseFunc of
        Core.EVar tv ->
            let
                funcName = tv.name
            in
            -- Check if this is a renamed capture
            case Dict.get funcName renames of
                Just renamed ->
                    -- Captured closure, apply via elm_apply1
                    generateClosureApplyWithRenames ctx renames renamed allArgs

                Nothing ->
                    let
                        mangledName = mangleWithModule ctx funcName
                        isKnownFunction = Dict.member funcName ctx.functions || isBuiltin funcName
                    in
                    if Set.member funcName ctx.closureParams || not isKnownFunction then
                        generateClosureApplyWithRenames ctx renames mangledName allArgs
                    else
                        let
                            arity = getFunctionArity ctx funcName
                            argCount = List.length allArgs
                        in
                        if arity == 0 then
                            generateClosureApplyWithRenames ctx renames (mangledName ++ "()") allArgs
                        else if argCount == arity then
                            mangledName ++ "(" ++ String.join ", " (List.map (generateExprWithRenames ctx renames) allArgs) ++ ")"
                        else if argCount < arity then
                            generatePartialAppWithRenames ctx renames mangledName allArgs arity
                        else
                            let
                                ( directArgs, extraArgs ) = splitAt arity allArgs
                                baseCall = mangledName ++ "(" ++ String.join ", " (List.map (generateExprWithRenames ctx renames) directArgs) ++ ")"
                            in
                            generateClosureApplyWithRenames ctx renames baseCall extraArgs

        Core.ECon name existingArgs _ ->
            generateConWithRenames ctx renames name (existingArgs ++ allArgs)

        _ ->
            "elm_apply1((elm_closure_t *)(" ++ generateExprWithRenames ctx renames baseFunc ++ ").data.p, " ++ generateExprWithRenames ctx renames arg ++ ")"


generateClosureApplyWithRenames : GenCtx -> Dict String String -> String -> List Core.Expr -> String
generateClosureApplyWithRenames ctx renames closureExpr args =
    case args of
        [] ->
            closureExpr

        arg :: rest ->
            let
                applied = "elm_apply1((elm_closure_t *)(" ++ closureExpr ++ ").data.p, " ++ generateExprWithRenames ctx renames arg ++ ")"
            in
            generateClosureApplyWithRenames ctx renames applied rest


generatePartialAppWithRenames : GenCtx -> Dict String String -> String -> List Core.Expr -> Int -> String
generatePartialAppWithRenames ctx renames funcName args arity =
    let
        argsCode =
            args
                |> List.indexedMap (\i a -> "_c->args[" ++ String.fromInt i ++ "] = " ++ generateExprWithRenames ctx renames a ++ ";")
                |> String.join " "
    in
    "({"
        ++ " elm_closure_t *_c = elm_alloc_closure();"
        ++ " _c->func = (void *)" ++ funcName ++ ";"
        ++ " _c->arity = " ++ String.fromInt arity ++ ";"
        ++ " _c->applied = " ++ String.fromInt (List.length args) ++ ";"
        ++ " " ++ argsCode
        ++ " (elm_value_t){ .tag = 400, .data.p = _c, .next = NULL };"
        ++ " })"


generateLambdaWithRenames : GenCtx -> Dict String String -> Core.TypedVar -> Core.Expr -> String
generateLambdaWithRenames ctx renames tv body =
    -- For nested lambdas, we need to compute captures relative to current scope
    let
        ( funcName, ctx1 ) = freshName "lambda" ctx
        argName = mangle tv.name

        bodyFreeVars = Core.freeVars body
        freeVarsExcludingParam = Set.remove tv.name bodyFreeVars

        -- Captures include both actual local variables and renamed captures from outer scope
        captures =
            freeVarsExcludingParam
                |> Set.filter (\v ->
                    not (Dict.member v ctx1.functions)
                        && not (isBuiltin v)
                )
                |> Set.toList

        numCaptures = List.length captures

        captureParams =
            captures
                |> List.indexedMap (\i _ -> "elm_value_t _cap" ++ String.fromInt i)

        allParams = captureParams ++ [ "elm_value_t " ++ argName ]
        paramsStr = String.join ", " allParams

        -- New rename map for inner lambda
        innerRenames =
            captures
                |> List.indexedMap (\i name -> ( name, "_cap" ++ String.fromInt i ))
                |> Dict.fromList

        bodyCtx =
            { ctx1
            | closureParams = Set.insert tv.name ctx1.closureParams
            , localVars = Set.union ctx1.localVars (Set.fromList captures)
            }

        bodyCode = generateExprWithRenames bodyCtx innerRenames body

        -- Store captured values - need to look up in outer renames for values
        captureAssignments =
            captures
                |> List.indexedMap (\i name ->
                    let
                        sourceValue =
                            case Dict.get name renames of
                                Just outerRenamed -> outerRenamed
                                Nothing -> mangle name
                    in
                    "_c->args[" ++ String.fromInt i ++ "] = " ++ sourceValue ++ ";"
                )
                |> String.join " "

        totalArity = numCaptures + 1
    in
    "({"
        ++ " elm_value_t " ++ funcName ++ "(" ++ paramsStr ++ ") { return " ++ bodyCode ++ "; }"
        ++ " elm_closure_t *_c = elm_alloc_closure();"
        ++ " _c->func = (void *)" ++ funcName ++ ";"
        ++ " _c->arity = " ++ String.fromInt totalArity ++ ";"
        ++ " _c->applied = " ++ String.fromInt numCaptures ++ ";"
        ++ " " ++ captureAssignments
        ++ " (elm_value_t){ .tag = 400, .data.p = _c, .next = NULL };"
        ++ " })"


generateCaseWithRenames : GenCtx -> Dict String String -> Core.Expr -> List Core.Alt -> String
generateCaseWithRenames ctx renames scrutinee alts =
    let
        scrutCode = generateExprWithRenames ctx renames scrutinee
        ( scrutVar, ctx1 ) = freshName "scrut" ctx
        ( resultVar, ctx2 ) = freshName "result" ctx1

        branches =
            alts
                |> List.map (generateAltWithRenames ctx2 renames scrutVar resultVar)
                |> String.join " else "
    in
    "({ elm_value_t " ++ scrutVar ++ " = " ++ scrutCode ++ "; elm_value_t " ++ resultVar ++ "; " ++ branches ++ " " ++ resultVar ++ "; })"


generateAltWithRenames : GenCtx -> Dict String String -> String -> String -> Core.Alt -> String
generateAltWithRenames ctx renames scrutVar resultVar (Core.Alt pattern guard body) =
    let
        ( condition, bindings ) = patternCondition ctx scrutVar pattern
        -- Remove pattern-bound variables from renames to avoid shadowing issues
        patVars = Core.freeVars body  -- Use body's free vars to find what pattern binds
        bodyRenames = renames  -- Pattern variables are fresh, don't shadow renames

        guardCode =
            case guard of
                Nothing -> ""
                Just g -> " && (" ++ generateExprWithRenames ctx bodyRenames g ++ ").data.i"

        bodyCode = generateExprWithRenames ctx bodyRenames body
    in
    "if (" ++ condition ++ guardCode ++ ") { " ++ bindings ++ resultVar ++ " = " ++ bodyCode ++ "; }"


generateConWithRenames : GenCtx -> Dict String String -> String -> List Core.Expr -> String
generateConWithRenames ctx renames name args =
    let
        argCodes =
            args
                |> List.map (generateExprWithRenames ctx renames)
                |> String.join ", "

        funcName =
            case name of
                "Nil" -> "elm_nil"
                "Cons" -> "elm_cons"
                "Nothing" -> "elm_nothing"
                "Just" -> "elm_just"
                "Ok" -> "elm_ok"
                "Err" -> "elm_err"
                "True" -> "elm_bool(true)"
                "False" -> "elm_bool(false)"
                _ -> "elm_" ++ name
    in
    if List.isEmpty args && (name == "True" || name == "False") then
        funcName
    else
        funcName ++ "(" ++ argCodes ++ ")"


generateTupleWithRenames : GenCtx -> Dict String String -> List Core.Expr -> String
generateTupleWithRenames ctx renames exprs =
    case exprs of
        [] ->
            "elm_unit()"

        [ single ] ->
            generateExprWithRenames ctx renames single

        first :: rest ->
            let
                firstCode = generateExprWithRenames ctx renames first
                restCode = generateTupleWithRenames ctx renames rest
            in
            "elm_cons(" ++ firstCode ++ ", " ++ restCode ++ ")"


generateRecordWithRenames : GenCtx -> Dict String String -> List ( String, Core.Expr ) -> String
generateRecordWithRenames ctx renames fields =
    let
        fieldCodes =
            fields
                |> List.map (\( name, e ) ->
                    "." ++ name ++ " = " ++ generateExprWithRenames ctx renames e
                )
                |> String.join ", "
    in
    "((elm_value_t){ .tag = 500, .data.p = &(struct { " ++
        String.join "; " (List.map (\( n, _ ) -> "elm_value_t " ++ n) fields) ++
        "; }){ " ++ fieldCodes ++ " }, .next = NULL })"


generateLet : GenCtx -> String -> Core.Expr -> Core.Expr -> String
generateLet ctx var value body =
    let
        valueCode = generateExpr ctx value
        bodyCode = generateExpr ctx body
    in
    "({ elm_value_t " ++ mangle var ++ " = " ++ valueCode ++ "; " ++ bodyCode ++ "; })"


generateLetRec : GenCtx -> List ( String, Core.Expr ) -> Core.Expr -> String
generateLetRec ctx bindings body =
    let
        decls =
            bindings
                |> List.map (\( name, _ ) ->
                    "elm_value_t " ++ mangle name ++ ";"
                )
                |> String.join " "

        assigns =
            bindings
                |> List.map (\( name, expr ) ->
                    mangle name ++ " = " ++ generateExpr ctx expr ++ ";"
                )
                |> String.join " "

        bodyCode = generateExpr ctx body
    in
    "({ " ++ decls ++ " " ++ assigns ++ " " ++ bodyCode ++ "; })"


generateCase : GenCtx -> Core.Expr -> List Core.Alt -> String
generateCase ctx scrutinee alts =
    let
        scrutCode = generateExpr ctx scrutinee
        ( scrutVar, ctx1 ) = freshName "scrut" ctx
        ( resultVar, ctx2 ) = freshName "result" ctx1

        branches =
            alts
                |> List.map (generateAlt ctx2 scrutVar resultVar)
                |> String.join " else "
    in
    "({ elm_value_t " ++ scrutVar ++ " = " ++ scrutCode ++ "; elm_value_t " ++ resultVar ++ "; " ++ branches ++ " " ++ resultVar ++ "; })"


generateAlt : GenCtx -> String -> String -> Core.Alt -> String
generateAlt ctx scrutVar resultVar (Core.Alt pattern guard body) =
    let
        ( condition, bindings ) = patternCondition ctx scrutVar pattern
        guardCode =
            case guard of
                Nothing -> ""
                Just g -> " && (" ++ generateExpr ctx g ++ ").data.i"
        bodyCode = generateExpr ctx body
    in
    "if (" ++ condition ++ guardCode ++ ") { " ++ bindings ++ resultVar ++ " = " ++ bodyCode ++ "; }"


patternCondition : GenCtx -> String -> Core.Pattern -> ( String, String )
patternCondition ctx scrutVar pattern =
    case pattern of
        Core.PVar tv ->
            ( "1", "elm_value_t " ++ mangle tv.name ++ " = " ++ scrutVar ++ "; " )

        Core.PWildcard _ ->
            ( "1", "" )

        Core.PLit lit _ ->
            case lit of
                Core.LInt n ->
                    ( scrutVar ++ ".data.i == " ++ String.fromInt n, "" )
                Core.LFloat f ->
                    ( scrutVar ++ ".data.f == " ++ String.fromFloat f, "" )
                Core.LString s ->
                    ( "strcmp(" ++ scrutVar ++ ".data.s, \"" ++ escapeString s ++ "\") == 0", "" )
                Core.LChar c ->
                    ( scrutVar ++ ".data.i == '" ++ escapeChar c ++ "'", "" )

        Core.PCon name subPats _ ->
            let
                -- Use actual tag values for known types
                tagValue =
                    case name of
                        "True" -> "5"
                        "False" -> "4"
                        "Nothing" -> "200"
                        "Just" -> "201"
                        "Err" -> "300"
                        "Ok" -> "301"
                        "[]" -> "100"  -- Nil (AST)
                        "::" -> "101"  -- Cons (AST)
                        "Nil" -> "100"  -- Nil (desugared)
                        "Cons" -> "101"  -- Cons (desugared)
                        _ -> "TAG_" ++ name

                tagCheck = scrutVar ++ ".tag == " ++ tagValue

                subConditions =
                    subPats
                        |> List.indexedMap (\i subPat ->
                            let
                                -- For list cons: first arg is .data.c (head), second is .next (tail)
                                -- For other constructors: chain through .data.c and .next
                                actualScrut =
                                    if name == "Cons" || name == "::" then
                                        if i == 0 then
                                            "(*" ++ scrutVar ++ ".data.c)"  -- head
                                        else
                                            "(*" ++ scrutVar ++ ".next)"     -- tail
                                    else
                                        if i == 0 then
                                            "(*" ++ scrutVar ++ ".data.c)"
                                        else
                                            -- Navigate through ->next chain for other constructors
                                            let
                                                nextChain = String.repeat i "->next"
                                            in
                                            "(*" ++ scrutVar ++ ".data.c" ++ nextChain ++ ")"
                            in
                            patternCondition ctx actualScrut subPat
                        )

                allConditions =
                    tagCheck :: List.map Tuple.first subConditions
                        |> String.join " && "

                allBindings =
                    List.map Tuple.second subConditions
                        |> String.join ""
            in
            ( allConditions, allBindings )

        Core.PTuple subPats _ ->
            -- Tuples are encoded as chained values
            let
                subConditions =
                    subPats
                        |> List.indexedMap (\i subPat ->
                            let
                                subScrut = scrutVar ++ "_" ++ String.fromInt i
                            in
                            patternCondition ctx subScrut subPat
                        )
            in
            ( String.join " && " (List.map Tuple.first subConditions)
            , String.join "" (List.map Tuple.second subConditions)
            )

        Core.PRecord fields _ ->
            -- Record patterns
            let
                bindings =
                    fields
                        |> List.map (\( name, subPat ) ->
                            case subPat of
                                Core.PVar tv ->
                                    "elm_value_t " ++ mangle tv.name ++ " = " ++ scrutVar ++ "." ++ name ++ "; "
                                _ ->
                                    ""
                        )
                        |> String.join ""
            in
            ( "1", bindings )


generateCon : GenCtx -> String -> List Core.Expr -> String
generateCon ctx name args =
    let
        argCodes =
            args
                |> List.map (generateExpr ctx)
                |> String.join ", "

        -- Map desugared names to runtime function names
        funcName =
            case name of
                "Nil" -> "elm_nil"
                "Cons" -> "elm_cons"
                "Nothing" -> "elm_nothing"
                "Just" -> "elm_just"
                "Ok" -> "elm_ok"
                "Err" -> "elm_err"
                "True" -> "elm_bool(true)"
                "False" -> "elm_bool(false)"
                _ -> "elm_" ++ name
    in
    if List.isEmpty args && (name == "True" || name == "False") then
        funcName
    else
        funcName ++ "(" ++ argCodes ++ ")"


generateTuple : GenCtx -> List Core.Expr -> String
generateTuple ctx exprs =
    -- Encode tuples as a chain
    case exprs of
        [] ->
            "elm_unit()"

        [ single ] ->
            generateExpr ctx single

        first :: rest ->
            let
                firstCode = generateExpr ctx first
                restCode = generateTuple ctx rest
            in
            "elm_cons(" ++ firstCode ++ ", " ++ restCode ++ ")"


generateRecord : GenCtx -> List ( String, Core.Expr ) -> String
generateRecord ctx fields =
    -- For now, encode records as a simple struct
    -- In a full implementation, we'd generate proper C structs
    let
        fieldCodes =
            fields
                |> List.map (\( name, expr ) ->
                    "." ++ name ++ " = " ++ generateExpr ctx expr
                )
                |> String.join ", "
    in
    "((elm_value_t){ .tag = 500, .data.p = &(struct { " ++
        String.join "; " (List.map (\( n, _ ) -> "elm_value_t " ++ n) fields) ++
        "; }){ " ++ fieldCodes ++ " }, .next = NULL })"


generateRecordAccess : GenCtx -> Core.Expr -> String -> String
generateRecordAccess ctx record field =
    let
        recordCode = generateExpr ctx record
    in
    "((" ++ recordCode ++ ").data.p->" ++ field ++ ")"


generateRecordUpdate : GenCtx -> Core.Expr -> List ( String, Core.Expr ) -> String
generateRecordUpdate ctx record fields =
    -- Record update: copy and modify
    -- This is simplified; full impl needs proper struct handling
    generateExpr ctx record


generateDictApp : GenCtx -> Core.Expr -> Core.Expr -> String
generateDictApp ctx func dict =
    -- Dictionary application - call function with dictionary
    generateExpr ctx func ++ "(" ++ generateExpr ctx dict ++ ")"


generateDictLam : GenCtx -> Core.TypedVar -> Core.Expr -> String
generateDictLam ctx tv body =
    -- Dictionary lambda - becomes a regular function
    generateLambda ctx tv body


generateDict : GenCtx -> String -> List Core.Expr -> String
generateDict ctx className _ =
    -- Dictionary literal
    "(elm_dict_t *)&dict_" ++ className



-- MAIN FUNCTION


generateMain : GenCtx -> String
generateMain ctx =
    let
        mainFunc = mangle (ctx.moduleName ++ "_main")

        hasMain = Dict.member "main" ctx.functions
    in
    if hasMain then
        String.join "\n"
            [ "/* ===== MAIN ===== */"
            , ""
            , "static void print_value(elm_value_t v) {"
            , "    switch (v.tag) {"
            , "        case 0: printf(\"%ld\", (long)v.data.i); break;"
            , "        case 1: printf(\"%g\", v.data.f); break;"
            , "        case 2: printf(\"\\\"%s\\\"\", v.data.s); break;"
            , "        case 3: printf(\"'%c'\", (char)v.data.i); break;"
            , "        case 4: printf(\"False\"); break;"
            , "        case 5: printf(\"True\"); break;"
            , "        case 6: printf(\"()\"); break;"
            , "        case 100: printf(\"[]\"); break;"
            , "        case 101: {"
            , "            printf(\"[\");"
            , "            elm_value_t curr = v;"
            , "            int first = 1;"
            , "            while (curr.tag == 101) {"
            , "                if (!first) printf(\", \");"
            , "                first = 0;"
            , "                print_value(*curr.data.c);"
            , "                curr = *curr.next;"
            , "            }"
            , "            printf(\"]\");"
            , "            break;"
            , "        }"
            , "        case 200: printf(\"Nothing\"); break;"
            , "        case 201: {"
            , "            printf(\"Just \");"
            , "            print_value(*v.data.c);"
            , "            break;"
            , "        }"
            , "        case 300: {"
            , "            printf(\"Err \");"
            , "            print_value(*v.data.c);"
            , "            break;"
            , "        }"
            , "        case 301: {"
            , "            printf(\"Ok \");"
            , "            print_value(*v.data.c);"
            , "            break;"
            , "        }"
            , "        default: printf(\"<value:%d>\", v.tag); break;"
            , "    }"
            , "}"
            , ""
            , "int main(void) {"
            , "    elm_value_t result = " ++ mainFunc ++ "();"
            , "    print_value(result);"
            , "    printf(\"\\n\");"
            , "    return 0;"
            , "}"
            ]
    else
        "/* No main function defined */"



-- HELPERS


mangle : String -> String
mangle name =
    "elm_" ++ String.map (\c -> if c == '.' then '_' else c) name


escapeString : String -> String
escapeString s =
    String.toList s
        |> List.map (\c ->
            case c of
                '"' -> "\\\""
                '\\' -> "\\\\"
                '\n' -> "\\n"
                '\t' -> "\\t"
                '\u{000D}' -> "\\r"
                _ -> String.fromChar c
        )
        |> String.concat


escapeChar : Char -> String
escapeChar c =
    case c of
        '\'' -> "\\'"
        '\\' -> "\\\\"
        '\n' -> "\\n"
        '\t' -> "\\t"
        '\u{000D}' -> "\\r"
        _ -> String.fromChar c
