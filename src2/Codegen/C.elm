module Codegen.C exposing
    ( generateC
    , generateModule
    , Options
    , defaultOptions
    )

{-| C code generation from Core IR.

This module generates C code from the Core intermediate representation.
The generated code is designed to be:
- TCC compatible (no GCC extensions)
- Suitable for embedded systems (RTEMS, bare metal)
- Efficient for the target use cases

Key design decisions:
- Closures are heap-allocated structs
- Type class dictionaries are passed explicitly
- Tail calls are optimized where possible
- Pattern matching compiles to efficient switch/if chains
-}

import Core
import Types exposing (Type(..), Scheme(..), Constraint(..))
import Dict exposing (Dict)
import Set exposing (Set)


-- OPTIONS


type alias Options =
    { targetName : String
    , emitDebugInfo : Bool
    , optimizeLevel : Int
    , maxClosureArgs : Int
    , maxTupleSize : Int
    }


defaultOptions : Options
defaultOptions =
    { targetName = "tcc"
    , emitDebugInfo = False
    , optimizeLevel = 1
    , maxClosureArgs = 8
    , maxTupleSize = 8
    }



-- CONTEXT


type alias GenCtx =
    { options : Options
    , moduleName : String
    , indent : Int
    , freshId : Int
    , dataTypes : Dict String Core.DataDef
    , functions : Dict String Core.FuncDef
    , classes : Dict String Core.ClassDef
    , instances : List Core.InstDef
    }


emptyCtx : Options -> GenCtx
emptyCtx opts =
    { options = opts
    , moduleName = "Main"
    , indent = 0
    , freshId = 0
    , dataTypes = Dict.empty
    , functions = Dict.empty
    , classes = Dict.empty
    , instances = []
    }


freshName : String -> GenCtx -> ( String, GenCtx )
freshName prefix ctx =
    ( prefix ++ "_" ++ String.fromInt ctx.freshId
    , { ctx | freshId = ctx.freshId + 1 }
    )


withIndent : GenCtx -> GenCtx
withIndent ctx =
    { ctx | indent = ctx.indent + 1 }


indentStr : GenCtx -> String
indentStr ctx =
    String.repeat (ctx.indent * 4) " "



-- MAIN ENTRY POINT


generateC : Options -> Core.Module -> String
generateC opts module_ =
    let
        ctx = collectDecls (emptyCtx opts) module_.decls
        ctx1 = { ctx | moduleName = module_.name }
    in
    String.join "\n"
        [ generateHeader ctx1
        , ""
        , generateRuntime ctx1
        , ""
        , generateTypeDecls ctx1
        , ""
        , generateForwardDecls ctx1
        , ""
        , generateFunctions ctx1
        , ""
        , generateMain ctx1
        ]


generateModule : Core.Module -> String
generateModule =
    generateC defaultOptions


collectDecls : GenCtx -> List Core.Decl -> GenCtx
collectDecls ctx decls =
    List.foldl collectDecl ctx decls


collectDecl : Core.Decl -> GenCtx -> GenCtx
collectDecl decl ctx =
    case decl of
        Core.FuncDecl funcDef ->
            { ctx | functions = Dict.insert funcDef.name funcDef ctx.functions }

        Core.DataDecl dataDef ->
            { ctx | dataTypes = Dict.insert dataDef.name dataDef ctx.dataTypes }

        Core.ClassDecl classDef ->
            { ctx | classes = Dict.insert classDef.name classDef ctx.classes }

        Core.InstDecl instDef ->
            { ctx | instances = instDef :: ctx.instances }



-- HEADER


generateHeader : GenCtx -> String
generateHeader ctx =
    String.join "\n"
        [ "/*"
        , " * Generated by tcelm v2 from " ++ ctx.moduleName
        , " * Target: " ++ ctx.options.targetName
        , " */"
        , ""
        , "#include <stdio.h>"
        , "#include <stdlib.h>"
        , "#include <string.h>"
        , "#include <stdint.h>"
        , "#include <stdbool.h>"
        ]



-- RUNTIME


generateRuntime : GenCtx -> String
generateRuntime _ =
    String.join "\n"
        [ "/* ===== RUNTIME ===== */"
        , ""
        , "/* Tagged union for algebraic data types */"
        , "typedef struct elm_value_s {"
        , "    uint32_t tag;"
        , "    union {"
        , "        int64_t i;"
        , "        double f;"
        , "        const char *s;"
        , "        void *p;"
        , "        struct elm_value_s *c;  /* child */"
        , "    } data;"
        , "    struct elm_value_s *next;   /* for lists, additional fields */"
        , "} elm_value_t;"
        , ""
        , "/* Closure for partial application */"
        , "typedef struct elm_closure_s {"
        , "    void *func;                 /* function pointer */"
        , "    uint8_t arity;              /* total arity */"
        , "    uint8_t applied;            /* args already applied */"
        , "    elm_value_t args[8];        /* captured arguments */"
        , "} elm_closure_t;"
        , ""
        , "/* Type class dictionary */"
        , "typedef struct elm_dict_s {"
        , "    void *methods[16];          /* method function pointers */"
        , "} elm_dict_t;"
        , ""
        , "/* Memory allocation */"
        , "static elm_value_t *elm_alloc(void) {"
        , "    return (elm_value_t *)malloc(sizeof(elm_value_t));"
        , "}"
        , ""
        , "static elm_closure_t *elm_alloc_closure(void) {"
        , "    return (elm_closure_t *)malloc(sizeof(elm_closure_t));"
        , "}"
        , ""
        , "/* Value constructors */"
        , "static elm_value_t elm_int(int64_t n) {"
        , "    return (elm_value_t){ .tag = 0, .data.i = n, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_float(double f) {"
        , "    return (elm_value_t){ .tag = 1, .data.f = f, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_string(const char *s) {"
        , "    return (elm_value_t){ .tag = 2, .data.s = s, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_char(char c) {"
        , "    return (elm_value_t){ .tag = 3, .data.i = (int64_t)c, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_bool(bool b) {"
        , "    return (elm_value_t){ .tag = b ? 5 : 4, .data.i = b, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_unit(void) {"
        , "    return (elm_value_t){ .tag = 6, .data.i = 0, .next = NULL };"
        , "}"
        , ""
        , "/* List operations */"
        , "static elm_value_t elm_nil(void) {"
        , "    return (elm_value_t){ .tag = 100, .data.p = NULL, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_cons(elm_value_t head, elm_value_t tail) {"
        , "    elm_value_t *h = elm_alloc();"
        , "    elm_value_t *t = elm_alloc();"
        , "    *h = head;"
        , "    *t = tail;"
        , "    return (elm_value_t){ .tag = 101, .data.c = h, .next = t };"
        , "}"
        , ""
        , "/* Maybe operations */"
        , "static elm_value_t elm_nothing(void) {"
        , "    return (elm_value_t){ .tag = 200, .data.p = NULL, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_just(elm_value_t val) {"
        , "    elm_value_t *v = elm_alloc();"
        , "    *v = val;"
        , "    return (elm_value_t){ .tag = 201, .data.c = v, .next = NULL };"
        , "}"
        , ""
        , "/* Result operations */"
        , "static elm_value_t elm_err(elm_value_t val) {"
        , "    elm_value_t *v = elm_alloc();"
        , "    *v = val;"
        , "    return (elm_value_t){ .tag = 300, .data.c = v, .next = NULL };"
        , "}"
        , ""
        , "static elm_value_t elm_ok(elm_value_t val) {"
        , "    elm_value_t *v = elm_alloc();"
        , "    *v = val;"
        , "    return (elm_value_t){ .tag = 301, .data.c = v, .next = NULL };"
        , "}"
        , ""
        , "/* Closure application */"
        , "static elm_value_t elm_apply1(elm_closure_t *c, elm_value_t arg) {"
        , "    if (c->applied + 1 < c->arity) {"
        , "        /* Still partial - create new closure */"
        , "        elm_closure_t *c2 = elm_alloc_closure();"
        , "        *c2 = *c;"
        , "        c2->args[c2->applied++] = arg;"
        , "        return (elm_value_t){ .tag = 400, .data.p = c2, .next = NULL };"
        , "    }"
        , "    /* Full application */"
        , "    switch (c->arity) {"
        , "        case 1: return ((elm_value_t (*)(elm_value_t))c->func)(arg);"
        , "        case 2: return ((elm_value_t (*)(elm_value_t, elm_value_t))c->func)(c->args[0], arg);"
        , "        case 3: return ((elm_value_t (*)(elm_value_t, elm_value_t, elm_value_t))c->func)(c->args[0], c->args[1], arg);"
        , "        case 4: return ((elm_value_t (*)(elm_value_t, elm_value_t, elm_value_t, elm_value_t))c->func)(c->args[0], c->args[1], c->args[2], arg);"
        , "        default: return elm_unit();"
        , "    }"
        , "}"
        , ""
        , "/* String operations */"
        , "static elm_value_t elm_str_append(elm_value_t a, elm_value_t b) {"
        , "    size_t la = strlen(a.data.s);"
        , "    size_t lb = strlen(b.data.s);"
        , "    char *buf = malloc(la + lb + 1);"
        , "    memcpy(buf, a.data.s, la);"
        , "    memcpy(buf + la, b.data.s, lb + 1);"
        , "    return elm_string(buf);"
        , "}"
        , ""
        , "static elm_value_t elm_str_length(elm_value_t s) {"
        , "    return elm_int((int64_t)strlen(s.data.s));"
        , "}"
        , ""
        , "/* Arithmetic */"
        , "static elm_value_t elm_add(elm_value_t a, elm_value_t b) {"
        , "    return elm_int(a.data.i + b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_sub(elm_value_t a, elm_value_t b) {"
        , "    return elm_int(a.data.i - b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_mul(elm_value_t a, elm_value_t b) {"
        , "    return elm_int(a.data.i * b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_div(elm_value_t a, elm_value_t b) {"
        , "    return elm_int(a.data.i / b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_mod(elm_value_t a, elm_value_t b) {"
        , "    return elm_int(a.data.i % b.data.i);"
        , "}"
        , ""
        , "/* Comparison */"
        , "static elm_value_t elm_eq(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i == b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_neq(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i != b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_lt(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i < b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_gt(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i > b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_lte(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i <= b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_gte(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i >= b.data.i);"
        , "}"
        , ""
        , "/* Boolean */"
        , "static elm_value_t elm_and(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i && b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_or(elm_value_t a, elm_value_t b) {"
        , "    return elm_bool(a.data.i || b.data.i);"
        , "}"
        , ""
        , "static elm_value_t elm_not(elm_value_t a) {"
        , "    return elm_bool(!a.data.i);"
        , "}"
        ]



-- TYPE DECLARATIONS


generateTypeDecls : GenCtx -> String
generateTypeDecls ctx =
    let
        dataDecls =
            ctx.dataTypes
                |> Dict.values
                |> List.map (generateDataType ctx)
                |> String.join "\n\n"

        classDecls =
            ctx.classes
                |> Dict.values
                |> List.map (generateClassDecl ctx)
                |> String.join "\n\n"
    in
    if String.isEmpty dataDecls && String.isEmpty classDecls then
        ""
    else
        "/* ===== TYPES ===== */\n\n" ++ dataDecls ++ "\n\n" ++ classDecls


generateDataType : GenCtx -> Core.DataDef -> String
generateDataType ctx dataDef =
    let
        tagDefs =
            dataDef.constructors
                |> List.map (\ctor ->
                    "#define TAG_" ++ dataDef.name ++ "_" ++ ctor.name ++ " " ++ String.fromInt (1000 + ctor.tag)
                )
                |> String.join "\n"

        ctorFuncs =
            dataDef.constructors
                |> List.map (generateConstructor ctx dataDef.name)
                |> String.join "\n\n"
    in
    "/* " ++ dataDef.name ++ " type tags */\n" ++ tagDefs ++ "\n\n" ++ ctorFuncs


generateConstructor : GenCtx -> String -> Core.DataConDef -> String
generateConstructor _ typeName ctor =
    let
        tag = "TAG_" ++ typeName ++ "_" ++ ctor.name
    in
    if ctor.fields == [] then
        -- Nullary constructor
        "static elm_value_t elm_" ++ ctor.name ++ "(void) {\n"
            ++ "    return (elm_value_t){ .tag = " ++ tag ++ ", .data.p = NULL, .next = NULL };\n"
            ++ "}"
    else if List.length ctor.fields == 1 then
        -- Unary constructor
        "static elm_value_t elm_" ++ ctor.name ++ "(elm_value_t v0) {\n"
            ++ "    elm_value_t *p = elm_alloc();\n"
            ++ "    *p = v0;\n"
            ++ "    return (elm_value_t){ .tag = " ++ tag ++ ", .data.c = p, .next = NULL };\n"
            ++ "}"
    else
        -- Multi-arg constructor
        let
            params =
                List.indexedMap (\i _ -> "elm_value_t v" ++ String.fromInt i) ctor.fields
                    |> String.join ", "

            body =
                List.indexedMap
                    (\i _ ->
                        "    elm_value_t *p" ++ String.fromInt i ++ " = elm_alloc();\n"
                            ++ "    *p" ++ String.fromInt i ++ " = v" ++ String.fromInt i ++ ";"
                    )
                    ctor.fields
                    |> String.join "\n"

            -- Chain them together
            chainSetup =
                List.indexedMap
                    (\i _ ->
                        if i < List.length ctor.fields - 1 then
                            "    p" ++ String.fromInt i ++ "->next = p" ++ String.fromInt (i + 1) ++ ";"
                        else
                            ""
                    )
                    ctor.fields
                    |> List.filter (not << String.isEmpty)
                    |> String.join "\n"
        in
        "static elm_value_t elm_" ++ ctor.name ++ "(" ++ params ++ ") {\n"
            ++ body ++ "\n"
            ++ chainSetup ++ "\n"
            ++ "    return (elm_value_t){ .tag = " ++ tag ++ ", .data.c = p0, .next = NULL };\n"
            ++ "}"


generateClassDecl : GenCtx -> Core.ClassDef -> String
generateClassDecl _ classDef =
    let
        methodSlots =
            classDef.methods
                |> List.indexedMap (\i ( name, _ ) ->
                    "#define SLOT_" ++ classDef.name ++ "_" ++ name ++ " " ++ String.fromInt i
                )
                |> String.join "\n"
    in
    "/* " ++ classDef.name ++ " type class */\n" ++ methodSlots



-- FORWARD DECLARATIONS


generateForwardDecls : GenCtx -> String
generateForwardDecls ctx =
    let
        decls =
            ctx.functions
                |> Dict.values
                |> List.map (generateForwardDecl ctx)
                |> String.join "\n"
    in
    if String.isEmpty decls then
        ""
    else
        "/* ===== FORWARD DECLARATIONS ===== */\n" ++ decls


generateForwardDecl : GenCtx -> Core.FuncDef -> String
generateForwardDecl ctx funcDef =
    let
        params =
            if List.isEmpty funcDef.args then
                "void"
            else
                funcDef.args
                    |> List.map (\tv -> "elm_value_t " ++ mangle tv.name)
                    |> String.join ", "
    in
    "static elm_value_t " ++ mangle (ctx.moduleName ++ "_" ++ funcDef.name) ++ "(" ++ params ++ ");"



-- FUNCTIONS


generateFunctions : GenCtx -> String
generateFunctions ctx =
    let
        funcs =
            ctx.functions
                |> Dict.values
                |> List.map (generateFunction ctx)
                |> String.join "\n\n"
    in
    if String.isEmpty funcs then
        ""
    else
        "/* ===== FUNCTIONS ===== */\n\n" ++ funcs


generateFunction : GenCtx -> Core.FuncDef -> String
generateFunction ctx funcDef =
    let
        fullName = mangle (ctx.moduleName ++ "_" ++ funcDef.name)

        params =
            if List.isEmpty funcDef.args then
                "void"
            else
                funcDef.args
                    |> List.map (\tv -> "elm_value_t " ++ mangle tv.name)
                    |> String.join ", "

        bodyCtx = withIndent ctx
        bodyCode = generateExpr bodyCtx funcDef.body
    in
    "static elm_value_t " ++ fullName ++ "(" ++ params ++ ") {\n"
        ++ indentStr bodyCtx ++ "return " ++ bodyCode ++ ";\n"
        ++ "}"



-- EXPRESSIONS


generateExpr : GenCtx -> Core.Expr -> String
generateExpr ctx expr =
    case expr of
        Core.EVar tv ->
            let
                name = tv.name
                mangledName = mangleWithModule ctx name
                arity = getFunctionArity ctx name
            in
            -- Zero-arity functions need to be called to get their value
            if arity == 0 && Dict.member name ctx.functions then
                mangledName ++ "()"
            else
                mangledName

        Core.ELit lit _ ->
            generateLiteral lit

        Core.EApp func arg _ ->
            generateApp ctx func arg

        Core.ELam tv body _ ->
            generateLambda ctx tv body

        Core.ELet var value body _ ->
            generateLet ctx var value body

        Core.ELetRec bindings body _ ->
            generateLetRec ctx bindings body

        Core.ECase scrutinee alts _ ->
            generateCase ctx scrutinee alts

        Core.ECon name args _ ->
            generateCon ctx name args

        Core.ETuple exprs _ ->
            generateTuple ctx exprs

        Core.ERecord fields _ ->
            generateRecord ctx fields

        Core.ERecordAccess record field _ ->
            generateRecordAccess ctx record field

        Core.ERecordUpdate record fields _ ->
            generateRecordUpdate ctx record fields

        Core.ETyApp e _ _ ->
            -- Type applications are erased
            generateExpr ctx e

        Core.ETyLam _ e _ ->
            -- Type lambdas are erased
            generateExpr ctx e

        Core.EDictApp func dict _ ->
            -- Dictionary application
            generateDictApp ctx func dict

        Core.EDictLam tv body _ ->
            -- Dictionary lambda
            generateDictLam ctx tv body

        Core.EDict className args _ ->
            generateDict ctx className args


generateLiteral : Core.Literal -> String
generateLiteral lit =
    case lit of
        Core.LInt n ->
            "elm_int(" ++ String.fromInt n ++ ")"

        Core.LFloat f ->
            "elm_float(" ++ String.fromFloat f ++ ")"

        Core.LString s ->
            "elm_string(\"" ++ escapeString s ++ "\")"

        Core.LChar c ->
            "elm_char('" ++ escapeChar c ++ "')"


generateApp : GenCtx -> Core.Expr -> Core.Expr -> String
generateApp ctx func arg =
    -- Collect all arguments from nested applications
    let
        ( baseFunc, allArgs ) = collectArgs func [ arg ]
    in
    case baseFunc of
        Core.EVar tv ->
            let
                funcName = tv.name
                arity = getFunctionArity ctx funcName
                mangledName = mangleWithModule ctx funcName
                argCount = List.length allArgs
            in
            if arity == 0 then
                -- Zero-arity function returns a closure - call it and apply args
                generateClosureApply ctx (mangledName ++ "()") allArgs
            else if argCount == arity then
                -- Full application - generate direct call
                mangledName ++ "(" ++ String.join ", " (List.map (generateExpr ctx) allArgs) ++ ")"
            else if argCount < arity then
                -- Partial application - generate closure
                generatePartialApp ctx mangledName allArgs arity
            else
                -- Over-application - call function, then apply extra args to result
                let
                    ( directArgs, extraArgs ) = splitAt arity allArgs
                    baseCall = mangledName ++ "(" ++ String.join ", " (List.map (generateExpr ctx) directArgs) ++ ")"
                in
                generateClosureApply ctx baseCall extraArgs

        _ ->
            -- Dynamic application (closure)
            "elm_apply1((elm_closure_t *)(" ++ generateExpr ctx baseFunc ++ ").data.p, " ++ generateExpr ctx arg ++ ")"


{-| Apply arguments to a closure expression one at a time.
-}
generateClosureApply : GenCtx -> String -> List Core.Expr -> String
generateClosureApply ctx closureExpr args =
    case args of
        [] ->
            closureExpr

        arg :: rest ->
            let
                applied = "elm_apply1((elm_closure_t *)(" ++ closureExpr ++ ").data.p, " ++ generateExpr ctx arg ++ ")"
            in
            generateClosureApply ctx applied rest


{-| Split a list at index n.
-}
splitAt : Int -> List a -> ( List a, List a )
splitAt n xs =
    ( List.take n xs, List.drop n xs )


{-| Collect all arguments from nested EApp nodes.
-}
collectArgs : Core.Expr -> List Core.Expr -> ( Core.Expr, List Core.Expr )
collectArgs expr args =
    case expr of
        Core.EApp innerFunc innerArg _ ->
            collectArgs innerFunc (innerArg :: args)

        _ ->
            ( expr, args )


{-| Get the arity of a known function.
-}
getFunctionArity : GenCtx -> String -> Int
getFunctionArity ctx name =
    case name of
        -- Binary operators (symbolic)
        "+" -> 2
        "-" -> 2
        "*" -> 2
        "/" -> 2
        "//" -> 2
        "^" -> 2
        "==" -> 2
        "/=" -> 2
        "<" -> 2
        ">" -> 2
        "<=" -> 2
        ">=" -> 2
        "&&" -> 2
        "||" -> 2
        "++" -> 2
        "::" -> 2
        "|>" -> 2
        "<|" -> 2
        ">>" -> 2
        "<<" -> 2

        -- Binary operators (desugared names from Desugar.elm)
        "add" -> 2
        "sub" -> 2
        "mul" -> 2
        "div" -> 2
        "eq" -> 2
        "neq" -> 2
        "lt" -> 2
        "gt" -> 2
        "lte" -> 2
        "gte" -> 2
        "and" -> 2
        "or" -> 2
        "append" -> 2
        "cons" -> 2
        "pipe" -> 2
        "pipeLeft" -> 2
        "compose" -> 2
        "composeLeft" -> 2

        -- Unary functions
        "not" -> 1
        "negate" -> 1

        -- User-defined functions - get arity from definition
        _ ->
            case Dict.get name ctx.functions of
                Just funcDef ->
                    List.length funcDef.args

                Nothing ->
                    -- Unknown function, assume unary
                    1


{-| Generate partial application as a closure.
-}
generatePartialApp : GenCtx -> String -> List Core.Expr -> Int -> String
generatePartialApp ctx funcName args arity =
    let
        argsCode =
            args
                |> List.indexedMap (\i a -> "_c->args[" ++ String.fromInt i ++ "] = " ++ generateExpr ctx a ++ ";")
                |> String.join " "
    in
    "({"
        ++ " elm_closure_t *_c = elm_alloc_closure();"
        ++ " _c->func = (void *)" ++ funcName ++ ";"
        ++ " _c->arity = " ++ String.fromInt arity ++ ";"
        ++ " _c->applied = " ++ String.fromInt (List.length args) ++ ";"
        ++ " " ++ argsCode
        ++ " (elm_value_t){ .tag = 400, .data.p = _c, .next = NULL };"
        ++ " })"


{-| Mangle a name with the module prefix if it's a local function.
-}
mangleWithModule : GenCtx -> String -> String
mangleWithModule ctx name =
    if isBuiltin name then
        mangle name
    else if Dict.member name ctx.functions then
        mangle (ctx.moduleName ++ "_" ++ name)
    else
        mangle name


{-| Check if a name is a builtin operator/function.
    Includes both symbolic operators and their desugared names.
-}
isBuiltin : String -> Bool
isBuiltin name =
    List.member name
        -- Symbolic operators
        [ "+", "-", "*", "/", "//", "^"
        , "==", "/=", "<", ">", "<=", ">="
        , "&&", "||", "not", "negate"
        , "++", "::"
        , "|>", "<|", ">>", "<<"
        , "True", "False"
        -- Desugared operator names (from Desugar.elm desugarBinOp)
        , "add", "sub", "mul", "div"
        , "eq", "neq", "lt", "gt", "lte", "gte"
        , "and", "or"
        , "append", "cons"
        , "pipe", "pipeLeft", "compose", "composeLeft"
        ]


generateLambda : GenCtx -> Core.TypedVar -> Core.Expr -> String
generateLambda ctx tv body =
    -- For now, generate a closure
    -- In a full implementation, we'd lift the lambda to a top-level function
    let
        ( funcName, ctx1 ) = freshName "lambda" ctx
        bodyCode = generateExpr ctx1 body
    in
    "({"
        ++ " elm_closure_t *_c = elm_alloc_closure();"
        ++ " _c->func = NULL; /* TODO: lift lambda */;"
        ++ " _c->arity = 1;"
        ++ " _c->applied = 0;"
        ++ " (elm_value_t){ .tag = 400, .data.p = _c, .next = NULL };"
        ++ " })"


generateLet : GenCtx -> String -> Core.Expr -> Core.Expr -> String
generateLet ctx var value body =
    let
        valueCode = generateExpr ctx value
        bodyCode = generateExpr ctx body
    in
    "({ elm_value_t " ++ mangle var ++ " = " ++ valueCode ++ "; " ++ bodyCode ++ "; })"


generateLetRec : GenCtx -> List ( String, Core.Expr ) -> Core.Expr -> String
generateLetRec ctx bindings body =
    let
        decls =
            bindings
                |> List.map (\( name, _ ) ->
                    "elm_value_t " ++ mangle name ++ ";"
                )
                |> String.join " "

        assigns =
            bindings
                |> List.map (\( name, expr ) ->
                    mangle name ++ " = " ++ generateExpr ctx expr ++ ";"
                )
                |> String.join " "

        bodyCode = generateExpr ctx body
    in
    "({ " ++ decls ++ " " ++ assigns ++ " " ++ bodyCode ++ "; })"


generateCase : GenCtx -> Core.Expr -> List Core.Alt -> String
generateCase ctx scrutinee alts =
    let
        scrutCode = generateExpr ctx scrutinee
        ( scrutVar, ctx1 ) = freshName "scrut" ctx

        branches =
            alts
                |> List.map (generateAlt ctx1 scrutVar)
                |> String.join " else "
    in
    "({ elm_value_t " ++ scrutVar ++ " = " ++ scrutCode ++ "; " ++ branches ++ "; })"


generateAlt : GenCtx -> String -> Core.Alt -> String
generateAlt ctx scrutVar (Core.Alt pattern guard body) =
    let
        ( condition, bindings ) = patternCondition ctx scrutVar pattern
        guardCode =
            case guard of
                Nothing -> ""
                Just g -> " && (" ++ generateExpr ctx g ++ ").data.i"
        bodyCode = generateExpr ctx body
    in
    "if (" ++ condition ++ guardCode ++ ") { " ++ bindings ++ bodyCode ++ "; }"


patternCondition : GenCtx -> String -> Core.Pattern -> ( String, String )
patternCondition ctx scrutVar pattern =
    case pattern of
        Core.PVar tv ->
            ( "1", "elm_value_t " ++ mangle tv.name ++ " = " ++ scrutVar ++ "; " )

        Core.PWildcard _ ->
            ( "1", "" )

        Core.PLit lit _ ->
            case lit of
                Core.LInt n ->
                    ( scrutVar ++ ".data.i == " ++ String.fromInt n, "" )
                Core.LFloat f ->
                    ( scrutVar ++ ".data.f == " ++ String.fromFloat f, "" )
                Core.LString s ->
                    ( "strcmp(" ++ scrutVar ++ ".data.s, \"" ++ escapeString s ++ "\") == 0", "" )
                Core.LChar c ->
                    ( scrutVar ++ ".data.i == '" ++ escapeChar c ++ "'", "" )

        Core.PCon name subPats _ ->
            let
                tagCheck = scrutVar ++ ".tag == TAG_" ++ name

                subConditions =
                    subPats
                        |> List.indexedMap (\i subPat ->
                            let
                                subScrutVar = scrutVar ++ ".data.c"
                                -- For chained fields, need to navigate ->next
                                actualScrut =
                                    if i == 0 then
                                        "(*" ++ subScrutVar ++ ")"
                                    else
                                        "(*" ++ String.repeat i (subScrutVar ++ "->next") ++ ")"
                            in
                            patternCondition ctx actualScrut subPat
                        )

                allConditions =
                    tagCheck :: List.map Tuple.first subConditions
                        |> String.join " && "

                allBindings =
                    List.map Tuple.second subConditions
                        |> String.join ""
            in
            ( allConditions, allBindings )

        Core.PTuple subPats _ ->
            -- Tuples are encoded as chained values
            let
                subConditions =
                    subPats
                        |> List.indexedMap (\i subPat ->
                            let
                                subScrut = scrutVar ++ "_" ++ String.fromInt i
                            in
                            patternCondition ctx subScrut subPat
                        )
            in
            ( String.join " && " (List.map Tuple.first subConditions)
            , String.join "" (List.map Tuple.second subConditions)
            )

        Core.PRecord fields _ ->
            -- Record patterns
            let
                bindings =
                    fields
                        |> List.map (\( name, subPat ) ->
                            case subPat of
                                Core.PVar tv ->
                                    "elm_value_t " ++ mangle tv.name ++ " = " ++ scrutVar ++ "." ++ name ++ "; "
                                _ ->
                                    ""
                        )
                        |> String.join ""
            in
            ( "1", bindings )


generateCon : GenCtx -> String -> List Core.Expr -> String
generateCon ctx name args =
    let
        argCodes =
            args
                |> List.map (generateExpr ctx)
                |> String.join ", "
    in
    "elm_" ++ name ++ "(" ++ argCodes ++ ")"


generateTuple : GenCtx -> List Core.Expr -> String
generateTuple ctx exprs =
    -- Encode tuples as a chain
    case exprs of
        [] ->
            "elm_unit()"

        [ single ] ->
            generateExpr ctx single

        first :: rest ->
            let
                firstCode = generateExpr ctx first
                restCode = generateTuple ctx rest
            in
            "elm_cons(" ++ firstCode ++ ", " ++ restCode ++ ")"


generateRecord : GenCtx -> List ( String, Core.Expr ) -> String
generateRecord ctx fields =
    -- For now, encode records as a simple struct
    -- In a full implementation, we'd generate proper C structs
    let
        fieldCodes =
            fields
                |> List.map (\( name, expr ) ->
                    "." ++ name ++ " = " ++ generateExpr ctx expr
                )
                |> String.join ", "
    in
    "((elm_value_t){ .tag = 500, .data.p = &(struct { " ++
        String.join "; " (List.map (\( n, _ ) -> "elm_value_t " ++ n) fields) ++
        "; }){ " ++ fieldCodes ++ " }, .next = NULL })"


generateRecordAccess : GenCtx -> Core.Expr -> String -> String
generateRecordAccess ctx record field =
    let
        recordCode = generateExpr ctx record
    in
    "((" ++ recordCode ++ ").data.p->" ++ field ++ ")"


generateRecordUpdate : GenCtx -> Core.Expr -> List ( String, Core.Expr ) -> String
generateRecordUpdate ctx record fields =
    -- Record update: copy and modify
    -- This is simplified; full impl needs proper struct handling
    generateExpr ctx record


generateDictApp : GenCtx -> Core.Expr -> Core.Expr -> String
generateDictApp ctx func dict =
    -- Dictionary application - call function with dictionary
    generateExpr ctx func ++ "(" ++ generateExpr ctx dict ++ ")"


generateDictLam : GenCtx -> Core.TypedVar -> Core.Expr -> String
generateDictLam ctx tv body =
    -- Dictionary lambda - becomes a regular function
    generateLambda ctx tv body


generateDict : GenCtx -> String -> List Core.Expr -> String
generateDict ctx className _ =
    -- Dictionary literal
    "(elm_dict_t *)&dict_" ++ className



-- MAIN FUNCTION


generateMain : GenCtx -> String
generateMain ctx =
    let
        mainFunc = mangle (ctx.moduleName ++ "_main")

        hasMain = Dict.member "main" ctx.functions
    in
    if hasMain then
        String.join "\n"
            [ "/* ===== MAIN ===== */"
            , ""
            , "int main(void) {"
            , "    elm_value_t result = " ++ mainFunc ++ "();"
            , "    switch (result.tag) {"
            , "        case 0: printf(\"%lld\\n\", result.data.i); break;"
            , "        case 1: printf(\"%g\\n\", result.data.f); break;"
            , "        case 2: printf(\"%s\\n\", result.data.s); break;"
            , "        case 4: printf(\"False\\n\"); break;"
            , "        case 5: printf(\"True\\n\"); break;"
            , "        default: printf(\"<value>\\n\"); break;"
            , "    }"
            , "    return 0;"
            , "}"
            ]
    else
        "/* No main function defined */"



-- HELPERS


mangle : String -> String
mangle name =
    "elm_" ++ String.map (\c -> if c == '.' then '_' else c) name


escapeString : String -> String
escapeString s =
    String.toList s
        |> List.map (\c ->
            case c of
                '"' -> "\\\""
                '\\' -> "\\\\"
                '\n' -> "\\n"
                '\t' -> "\\t"
                '\u{000D}' -> "\\r"
                _ -> String.fromChar c
        )
        |> String.concat


escapeChar : Char -> String
escapeChar c =
    case c of
        '\'' -> "\\'"
        '\\' -> "\\\\"
        '\n' -> "\\n"
        '\t' -> "\\t"
        '\u{000D}' -> "\\r"
        _ -> String.fromChar c
