/*
 * Generated by tcelm from PatternGuards
 * TCC-compatible version (no GCC extensions)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>


/* String.fromInt - convert int to string (uses rotating buffer pool) */
#define ELM_FROMINT_POOL_SIZE 64
static char __elm_fromint_pool[ELM_FROMINT_POOL_SIZE][32];
static int __elm_fromint_idx = 0;
static const char *elm_from_int(int n) {
    char *buf = __elm_fromint_pool[__elm_fromint_idx];
    __elm_fromint_idx = (__elm_fromint_idx + 1) % ELM_FROMINT_POOL_SIZE;
    char tmp[32];
    int i = 0, j = 0;
    int neg = 0;
    if (n < 0) { neg = 1; n = -n; }
    if (n == 0) { buf[0] = '0'; buf[1] = 0; return buf; }
    while (n > 0) { tmp[i++] = '0' + (n % 10); n /= 10; }
    if (neg) buf[j++] = '-';
    while (i > 0) buf[j++] = tmp[--i];
    buf[j] = 0;
    return buf;
}

/* String.fromFloat - convert double to string (uses rotating buffer pool) */
#define ELM_FROMFLOAT_POOL_SIZE 64
static char __elm_fromfloat_pool[ELM_FROMFLOAT_POOL_SIZE][64];
static int __elm_fromfloat_idx = 0;
static const char *elm_from_float(double f) {
    char *buf = __elm_fromfloat_pool[__elm_fromfloat_idx];
    __elm_fromfloat_idx = (__elm_fromfloat_idx + 1) % ELM_FROMFLOAT_POOL_SIZE;
    snprintf(buf, 64, "%g", f);
    return buf;
}

/* String.append - concatenate two strings (uses rotating buffer pool) */
#define ELM_STR_POOL_SIZE 32
#define ELM_STR_BUF_SIZE 4096
static char __elm_str_pool[ELM_STR_POOL_SIZE][ELM_STR_BUF_SIZE];
static int __elm_str_pool_idx = 0;
static const char *elm_str_append(const char *a, const char *b) {
    char *buf = __elm_str_pool[__elm_str_pool_idx];
    __elm_str_pool_idx = (__elm_str_pool_idx + 1) % ELM_STR_POOL_SIZE;
    int i = 0, j = 0;
    while (a[i] && i < ELM_STR_BUF_SIZE - 1) { buf[i] = a[i]; i++; }
    while (b[j] && i + j < ELM_STR_BUF_SIZE - 1) { buf[i + j] = b[j]; j++; }
    buf[i + j] = 0;
    return buf;
}

/* Power function */
static double elm_pow(double base, double exp) {
    return pow(base, exp);
}

/* String length */
static double elm_strlen(const char *s) {
    return (double)strlen(s);
}

/* String.endsWith - check if string ends with suffix */
static int elm_str_ends_with(const char *suffix, const char *s) {
    int slen = 0, suflen = 0;
    while (s[slen]) slen++;
    while (suffix[suflen]) suflen++;
    if (suflen > slen) return 0;
    for (int i = 0; i < suflen; i++) {
        if (s[slen - suflen + i] != suffix[i]) return 0;
    }
    return 1;
}

/* String.contains - check if string contains substring */
static int elm_str_contains(const char *needle, const char *haystack) {
    int nlen = 0, hlen = 0;
    while (needle[nlen]) nlen++;
    while (haystack[hlen]) hlen++;
    if (nlen == 0) return 1;
    for (int i = 0; i <= hlen - nlen; i++) {
        int match = 1;
        for (int j = 0; j < nlen && match; j++) {
            if (haystack[i + j] != needle[j]) match = 0;
        }
        if (match) return 1;
    }
    return 0;
}

/* Forward declarations for recursive types */
struct elm_list_s;
struct elm_union_s;

/* Generic tagged union type for custom types */
/* Supports both primitive values (.num) and nested unions (.child) */
/* data2 is optional second argument for binary constructors like Add Expr Expr */
typedef struct elm_union_s { int tag; union { double num; struct elm_union_s *child; const char *str; } data; struct elm_union_s *data2; } elm_union_t;

/* Helper to allocate a nested union on the heap */
static elm_union_t *elm_alloc_union(elm_union_t val) {
    elm_union_t *p = (elm_union_t*)malloc(sizeof(elm_union_t));
    *p = val;
    return p;
}

/* Built-in tuple types - use flexible data union for elements */
typedef union { double d; void *ptr; struct elm_list_s *lst; const char *str; } elm_elem_t;
typedef struct { elm_elem_t _0; elm_elem_t _1; } elm_tuple2_t;
typedef struct { elm_elem_t _0; elm_elem_t _1; elm_elem_t _2; } elm_tuple3_t;

/* Built-in Maybe type tags */
#define TAG_Nothing 0
#define TAG_Just 1

/* Built-in Maybe constructor functions */
static elm_union_t elm_Nothing(void) {
    elm_union_t result = { .tag = TAG_Nothing, .data = {.num = 0}, .data2 = 0 };
    return result;
}
static elm_union_t elm_Just(elm_union_t v1) {
    elm_union_t result = { .tag = TAG_Just, .data = {.child = elm_alloc_union(v1)}, .data2 = 0 };
    return result;
}

/* Built-in Result type tags */
#define TAG_Err 0
#define TAG_Ok 1

/* Built-in Result constructor functions */
static elm_union_t elm_Ok(elm_union_t v1) {
    elm_union_t result = { .tag = TAG_Ok, .data = {.child = elm_alloc_union(v1)}, .data2 = 0 };
    return result;
}
static elm_union_t elm_Err(elm_union_t v1) {
    elm_union_t result = { .tag = TAG_Err, .data = {.child = elm_alloc_union(v1)}, .data2 = 0 };
    return result;
}

/* Built-in Order type tags */
#define TAG_LT 0
#define TAG_EQ 1
#define TAG_GT 2

/* Src module AST type tags (for self-hosting) */
#define TAG_Src_Str 0
#define TAG_Src_Int 1
#define TAG_Src_Float 2
#define TAG_Src_Chr 3
#define TAG_Src_Var 4
#define TAG_Src_VarQual 5
#define TAG_Src_List 6
#define TAG_Src_Tuple 7
#define TAG_Src_Record 8
#define TAG_Src_Update 9
#define TAG_Src_Access 10
#define TAG_Src_Accessor 11
#define TAG_Src_If 12
#define TAG_Src_Let 13
#define TAG_Src_Case 14
#define TAG_Src_Lambda 15
#define TAG_Src_Binops 16
#define TAG_Src_Call 17
#define TAG_Src_Negate 18
#define TAG_Src_At 19
#define TAG_Src_PVar 0
#define TAG_Src_PAnything 1
#define TAG_Src_PInt 2
#define TAG_Src_PStr 3
#define TAG_Src_PChr 4
#define TAG_Src_PList 5
#define TAG_Src_PCons 6
#define TAG_Src_PTuple 7
#define TAG_Src_PCtor 8
#define TAG_Src_PCtorQual 9
#define TAG_Src_PRecord 10
#define TAG_Src_Define 0
#define TAG_Src_Destruct 1
#define TAG_Src_LowVar 0
#define TAG_Src_CapVar 1
#define TAG_Src_Unit 20
#define TAG_Src_Op 21
#define TAG_Src_PUnit 11
#define TAG_Src_PAlias 12

/* Built-in List type - fixed-size array with flexible element storage */
#define ELM_LIST_MAX 64
typedef union { double d; elm_tuple2_t t2; elm_tuple3_t t3; void *ptr; struct elm_list_s *lst; elm_union_t u; const char *str; } elm_data_t;
typedef struct elm_list_s { int length; elm_data_t data[ELM_LIST_MAX]; } elm_list_t;

/* String.replace - replace all occurrences */
static char __elm_replace_buf[4096];
static const char *elm_str_replace(const char *target, const char *replacement, const char *src) {
    int tlen = 0, rlen = 0, slen = 0;
    while (target[tlen]) tlen++;
    while (replacement[rlen]) rlen++;
    while (src[slen]) slen++;
    if (tlen == 0) { for (int i = 0; i <= slen && i < 4095; i++) __elm_replace_buf[i] = src[i]; return __elm_replace_buf; }
    int j = 0;
    for (int i = 0; src[i] && j < 4094; ) {
        int match = 1;
        for (int k = 0; k < tlen && match; k++) if (src[i + k] != target[k]) match = 0;
        if (match) { for (int k = 0; k < rlen && j < 4094; k++) __elm_replace_buf[j++] = replacement[k]; i += tlen; }
        else { __elm_replace_buf[j++] = src[i++]; }
    }
    __elm_replace_buf[j] = 0;
    return __elm_replace_buf;
}

/* Rate Monotonic Scheduler (RMS) stubs for TCC testing */
typedef enum { RMS_ON_TIME = 0, RMS_MISSED = 1, RMS_NOT_STARTED = 2 } rms_deadline_status_t;
typedef struct { unsigned int count, missed_count, min_cpu_time_us, max_cpu_time_us, avg_cpu_time_us, period_ms; rms_deadline_status_t last_status; } rms_stats_t;
typedef struct { unsigned int period_id, period_ms, period_ticks; int started; rms_deadline_status_t last_status; unsigned int local_missed_count; } rms_period_t;
static rms_period_t *rms_create(unsigned int period_ms) {
    rms_period_t *p = (rms_period_t *)malloc(sizeof(rms_period_t));
    if (!p) return 0;
    p->period_id = 1; p->period_ms = period_ms; p->period_ticks = period_ms;
    p->started = 0; p->last_status = RMS_NOT_STARTED; p->local_missed_count = 0;
    return p;
}
static rms_deadline_status_t rms_wait_period(rms_period_t *p) {
    if (!p) return RMS_NOT_STARTED;
    if (!p->started) { p->started = 1; return RMS_NOT_STARTED; }
    p->last_status = RMS_ON_TIME; return RMS_ON_TIME; /* Stub: always on time */
}
static int rms_get_stats(rms_period_t *p, rms_stats_t *s) {
    if (!p || !s) return -1; memset(s, 0, sizeof(*s));
    s->missed_count = p->local_missed_count; s->period_ms = p->period_ms; s->last_status = p->last_status;
    return 0;
}
static unsigned int rms_get_missed_count(rms_period_t *p) { return p ? p->local_missed_count : 0; }
static void rms_delete(rms_period_t *p) { if (p) free(p); }
static int rms_assign_priority(unsigned int period_ms) { (void)period_ms; return 0; }
static unsigned int rms_global_missed_count = 0;
static unsigned int rms_global_get_missed(void) { return rms_global_missed_count; }
static void rms_global_reset_missed(void) { rms_global_missed_count = 0; }

/* Record types for AST and internal structures */
typedef struct { double name; elm_list_t values; elm_list_t unions; } elm_module_t;
typedef struct { double name; elm_list_t args; double body; } elm_value_t;
typedef struct { double name; elm_list_t ctors; } elm_src_union_t;
typedef struct { const char *prefix; const char *name; elm_list_t args; double body; } elm_local_func_t;
typedef struct { const char *target; } elm_flags_t;
typedef struct { const char *target; } elm_model_t;

/* Forward declarations */
static const char * elm_classify(double elm_x);
static double elm_testGuards(double elm_x);

/* User-defined functions */
static const char * elm_classify(double elm_x) {
    return ({
        int elm_case_scrutinee = elm_x;
        ({
            double elm_n = elm_case_scrutinee;
            ((elm_n > 0) ? "positive" : ({
            double elm_n = elm_case_scrutinee;
            ((elm_n < 0) ? "negative" : "zero");
        }));
        });
    });
}

static double elm_testGuards(double elm_x) {
    return ({
        int elm_case_scrutinee = elm_x;
        ({
            double elm_n = elm_case_scrutinee;
            ((elm_n > 10) ? (elm_n * 2) : ({
            double elm_n = elm_case_scrutinee;
            ((elm_n > 5) ? (elm_n + 10) : ({
            double elm_n = elm_case_scrutinee;
            elm_n;
        }));
        }));
        });
    });
}

/* Elm main value */
static const char * elm_main(void) {
    return elm_str_append(elm_classify(5), elm_str_append(" ", elm_str_append(elm_classify((-3)), elm_str_append(" ", elm_str_append(elm_classify(0), elm_str_append(" ", elm_str_append(elm_from_int(elm_testGuards(15)), elm_str_append(" ", elm_str_append(elm_from_int(elm_testGuards(7)), elm_str_append(" ", elm_from_int(elm_testGuards(3))))))))))));
}

int main(void) {
    printf("%s\n", elm_main());
    return 0;
}
